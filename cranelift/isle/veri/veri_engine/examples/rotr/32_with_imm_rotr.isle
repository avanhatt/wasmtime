(type ImmLogic (primitive ImmLogic))
(type ImmShift (primitive ImmShift))
(type Imm12 (primitive Imm12))

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

;; Instruction formats.
(type MInst
  (enum
))

;; Add an assertion that the value fits, using the constand with 56 1's then 6 0's (~63)
;;@ (spec (sig (args ty, x) (r))
;;@   (assertions 
;;@     (= (r) (extract 5 0 (& (x) (- (int2bv 64 (ty)) (1i64:bv64))))),
;;@     (ult (& (x) (- (int2bv 64 (ty)) (1i64:bv64))) (64i64:bv64))
;;@   )
;;@ )
(decl pure imm_shift_from_imm64 (Type Imm64) ImmShift)
(extern constructor imm_shift_from_imm64 imm_shift_from_imm64)

;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assertions (= (ret) 
;;@                    (if (= (ty) (32i0:isleType))
;;@                        (zero_ext (regwidth) (rotr (extract 31 0 (x)) (zero_ext (32i0:isleType) (y)))) 
;;@                        (rotr (x) (zero_ext (regwidth) (y)))
;;@                    )
;;@                 ),
;;@                 (|| (= (ty) (32i0:isleType)) (= (ty) (64i0:isleType)))
;;@     )
;;@ )
(decl a64_rotr_imm (Type Reg ImmShift) Reg)
(extern constructor a64_rotr_imm a64_rotr_imm)

;; Specialization for the 32-bit case when the rotation amount is an immediate.
(rule (lower (has_type $I32 (rotr x (iconst k))))
      (if-let n (imm_shift_from_imm64 $I32 k))
      (a64_rotr_imm $I32 x n))
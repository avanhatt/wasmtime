(type ImmLogic (primitive ImmLogic))
(type ImmShift (primitive ImmShift))
(type Imm12 (primitive Imm12))

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: isleType) (conv_to (regwidth) (| (extract 31 0 (a)) (extract 31 0 (b)))))
;;@            ((64i8: isleType) (| (a) (b)))
;;@          )
;;@       )
;;@ ))
(decl orr (Type Reg Reg) Reg)
(extern constructor orr orr)

;;@ (spec (sig (args t, x, y) (ret))
;;@       (assume  
;;@          (= (ret) 
;;@             (switch (t)
;;@               ((8i8: isleType) (conv_to (regwidth) (rotr (extract 7 0 (x)) (zero_ext (8) (y)))))
;;@               ((16i8: isleType) (conv_to (regwidth) (rotr (extract 15 0 (x)) (zero_ext (16) (y)))))
;;@             )),
;;@          (|| (= (t) (8i8: isleType)) 
;;@              (= (t) (16i8: isleType))),
;;@          (switch (t)
;;@            ((8i8: isleType) (= (extract 31 8 (x)) (0i32:bv24)))
;;@            ((16i8: isleType) (= (extract 31 16 (x)) (0i32:bv16)))
;;@          ),
;;@          (ult (zero_ext (regwidth) (y)) (- (int2bv 64 (t)) (1i64:bv64)))
;;@       )
;;@ )
(decl small_rotr_imm (Type Reg ImmShift) Reg)

;; Helper for generating `lsr` instructions.
;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: isleType) (conv_to (regwidth) (shr (extract 31 0 (a)) (zero_ext (32) (b)))))
;;@            ((64i8: isleType) (shr (a) (zero_ext (regwidth) (b))))
;;@          )
;;@       )
;;@ ))
(decl lsr_imm (Type Reg ImmShift) Reg)
(extern constructor lsr_imm lsr_imm)
(extern extractor lsr_imm lsr_imm)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: isleType) (conv_to (regwidth) (shl (extract 31 0 (a)) (zero_ext (32) (b)))))
;;@            ((64i8: isleType) (shl (a) (zero_ext (regwidth) (b))))
;;@          )
;;@       )
;;@ ))
(decl lsl_imm (Type Reg ImmShift) Reg)
(extern constructor lsl_imm lsl_imm)
(extern extractor lsl_imm lsl_imm)

;; fn rotr_opposite_amount(&mut self, ty: Type, val: ImmShift) -> ImmShift {
;;     let amount = val.value() & u8::try_from(ty.bits() - 1).unwrap();
;;     ImmShift::maybe_from_u64(u64::from(ty.bits()) - u64::from(amount)).unwrap()
;; }

;;@ (spec (sig (args ty, x) (ret))
;;@   (assume  (= (- (int2bv 6 (ty)) (& (x) (- (int2bv 6 (ty)) (1i6:bv)))) (ret))))
(decl rotr_opposite_amount (Type ImmShift) ImmShift)
(extern constructor rotr_opposite_amount rotr_opposite_amount)

;; Instruction formats.
(type MInst
  (enum
))


;; For a constant amount, we can instead do:
;;
;;    rotr rd, val, #amt
;;
;;       =>
;;
;;    lsr val_rshift, val, #<amt>
;;    lsl val_lshift, val, <bitwidth - amt>
;;    orr rd, val_lshift, val_rshift
(rule (small_rotr_imm ty val amt)
      (let ((val_rshift Reg (lsr_imm $I32 val amt))
            (val_lshift Reg (lsl_imm $I32 val (rotr_opposite_amount ty amt))))
        (orr $I32 val_lshift val_rshift)))
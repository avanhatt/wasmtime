(type ImmLogic (primitive ImmLogic))
(type ImmShift (primitive ImmShift))
(type Imm12 (primitive Imm12))

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

;; Instruction formats.
(type MInst
  (enum
))

;; Add an assertion that the value fits, using the constand with 56 1's then 6 0's (~63)
;;@ (spec (sig (args ty, x) (r))
;;@   (assertions 
;;@     (= (r) (conv_to (widthof (r)) (x))),
;;@     (= (0i65:bv) (& (x) (~ (63i64:bv))))
;;@   )
;;@ )
(decl pure imm_shift_from_imm64 (Type Imm64) ImmShift)
(extern constructor imm_shift_from_imm64 imm_shift_from_imm64)

;; Place a `Value` into a register, zero extending it to 32-bits
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl put_in_reg_zext32 (Value) Reg)
(extern constructor put_in_reg_zext32 put_in_reg_zext32)

;;@ (spec (sig (args t, x, y) (ret))
;;@       (assertions 
;;@          (= (rotr (x) (y)) (ret)),
;;@          (= (widthof (x)) (t)), 
;;@          (<= (widthof (x)) (16i128: isleType)), 
;;@          (<= (widthof (y)) (16i128: isleType)), 
;;@       )
;;@ )
(decl small_rotr_imm (Type Reg ImmShift) Reg)

;; Specialization for the 8/16-bit case when the rotation amount is an immediate.
(rule -2 (lower (has_type (fits_in_16 ty) (rotr x (iconst k))))
      (if-let n (imm_shift_from_imm64 ty k))
      (small_rotr_imm ty (put_in_reg_zext32 x) n))
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

(type MInst
  (enum
))

;; We will represent this with a msb shift bit
;; and a 12 bit value
(type Imm12 (primitive Imm12))

(type ALUOp
  (enum
    (Add)
))

;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assertions (if (= (1i1:bv) (extract 12 12 (y))) {
;;@                     (if (= (0i13:bv) (& (y) (4095i13:bv))) {
;;@                         (= (ret) (+ (x) (shl (zero_ext (regwidth) (extract 11 0 (y))) (12i24:bv))))
;;@                      } else {
;;@                         (false)
;;@                      })
;;@                  } else {
;;@                     (= (ret) (+ (x) (zero_ext (regwidth) (extract 11 0 (y)))))
;;@                  })
;;@ ))
(decl add_imm (Type Reg Imm12) Reg)
(rule (add_imm ty x y) (alu_rr_imm12 (ALUOp.Add) ty x y))

(decl alu_rr_imm12 (ALUOp Type Reg Imm12) Reg)
(extern constructor alu_rr_imm12 alu_rr_imm12)

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (if (= (1i1:bv) (extract 12 12 (arg))) {
;;@                     (if (= (0i13:bv) (& (arg) (4095i13:bv))) {
;;@                         (= (ret) (shl (zero_ext (24) (extract 11 0 (arg))) (12i24:bv)))
;;@                      } else {
;;@                         (false)
;;@                      })
;;@                  } else {
;;@                     (= (ret) (zero_ext (24) (extract 11 0 (arg))))
;;@                  })
;;@ ))
(decl imm12_from_value (Imm12) Value)
(extern extractor imm12_from_value imm12_from_value)

(rule (lower (has_type (fits_in_64 ty) (iadd (imm12_from_value x) y)))
      (add_imm ty y x))


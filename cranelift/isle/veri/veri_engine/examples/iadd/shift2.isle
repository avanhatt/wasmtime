;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

(type MInst
  (enum
       (AluRRRShift
           (shiftop ShiftOpAndAmt))
))

;; ASSUMING 64 BIT MODE!!!
;; annotations will interpret this as an 8 bit field
;; the two msb encode the type of shift as follows:
;;   00: lsl
;;   01: lsr
;;   10: asr
;;   11: invalid
;; the rest will encode a 6-bit shift amount 
(type ShiftOpAndAmt (primitive ShiftOpAndAmt))

(type ALUOp
  (enum
    (Add)
))

(decl alu_rrr_shift (ALUOp Type Reg Reg ShiftOpAndAmt) Reg)
(extern constructor alu_rrr_shift alu_rrr_shift)

;;@ (spec (sig (args ty, a, b, shift) (ret))
;;@     (assertions (if (= (& (shift) (192i8:bv)) (0i8:bv)) {
;;@                     (= (ret) (+ (a) (shl (b) (zero_ext (widthof (b)) (extract 5 0 (shift))))))
;;@                  } else {
;;@                      (if (= (& (shift) (192i8:bv)) (64i8:bv)) {
;;@                          (= (ret) (+ (a) (shr (b) (zero_ext (widthof (b)) (extract 5 0 (shift))))))
;;@                      } else {
;;@                          (if (= (& (shift) (192i8:bv)) (128i8:bv)) {
;;@                              (= (ret) (+ (a) (ashr (b) (zero_ext (widthof (b)) (extract 5 0 (shift))))))
;;@                          } else {
;;@                                (= (true) (false)) 
;;@                          })
;;@                      })
;;@                  })
;;@ ))
(decl add_shift (Type Reg Reg ShiftOpAndAmt) Reg)
(rule (add_shift ty x y z) (alu_rrr_shift (ALUOp.Add) ty x y z))

;;@ (spec (sig (args ty, a) (ret))
;;@     (assertions (= (& (a) (192i64:bv)) (0i64:bv)),
;;@                 (= (ret) (extract 7 0 (a)))))
(decl pure lshl_from_imm64 (Type Imm64) ShiftOpAndAmt)
(extern constructor lshl_from_imm64 lshl_from_imm64)

(rule 6 (lower (has_type (fits_in_64 ty)
                       (iadd (ishl x (iconst k)) y)))
      (if-let amt (lshl_from_imm64 ty k))
      (add_shift ty y x amt))
(type MInst
  (enum)
)

;; A tuple of `ProducesFlags` and `IntCC`.
(type FlagsAndCC (enum (FlagsAndCC (flags ProducesFlags)
                                   (cc IntCC))))
                                   
(type Cond extern
  (enum
    (Eq)
    (Ne)
    (Hs)
    (Lo)
    (Mi)
    (Pl)
    (Vs)
    (Vc)
    (Hi)
    (Ls)
    (Ge)
    (Lt)
    (Gt)
    (Le)
    (Al)
    (Nv)
))


;; N: Set to 1 when the result of the operation is negative
;; Z: Set to 1 when the result of the operation is zero
;; C: Set to 1 when the operation results in a carry, or when a subtraction results in no borrow
;; V: Set to 1 when the operation causes overflow

;; Concat the 4 bits of flags to 8 bits with the CC, for 12 bits
;;  | 11  10  9   8 | 7 .......... 0|
;;  [ N | Z | C | V |   ... CC ...  ]

;; For the intermediate term, use the 64b version of subs for all widths
;; Zero- or sign- extend based on the condition code
;; Condition codes that require signed: 2i8, 3i8, 4i8, 5i8


;; NOTE: due to rule priorities, only applies to 32 and 64

;; (0i8:bv8) =
;; (1i8:bv8) != 
;; (2i8:bv8) sgt
;; (3i8:bv8) sgte
;; (4i8:bv8) slt
;; (5i8:bv8) slte
;; (6i8:bv8) ugt
;; (7i8:bv8) ugte
;; (8i8:bv8) ult
;; (9i8:bv8) ulte
;;@ (spec (sig (args c, x, y, in_ty) (ret))
;;@   (assertions 
;;@     (= (ret) 
;;@        (| (shl (zero_ext (12i8: isleType) 
;;@           (extract 67 64 
;;@           (if (&& (ugte (c) (2i8:bv8)) (ulte (c) (5i8:bv8))) 
;;@             (if (<= (in_ty) (32i8:isleType))
;;@               (subs (32i8:isleType) (sign_ext (regwidth) (x)) (sign_ext (regwidth) (y)))
;;@               (subs (64i8:isleType) (sign_ext (regwidth) (x)) (sign_ext (regwidth) (y)))
;;@             )
;;@             (if (<= (in_ty) (32i8:isleType))
;;@               (subs (32i8:isleType) (zero_ext (regwidth) (x)) (zero_ext (regwidth) (y)))
;;@               (subs (64i8:isleType) (zero_ext (regwidth) (x)) (zero_ext (regwidth) (y)))
;;@             )
;;@           ))
;;@          )
;;@          (8i12:bv12))
;;@       (zero_ext (12i8: isleType) (c)))
;;@     ),
;;@
;;@     (ulte (c) (9i8:bv8)),
;;@
;;@     (|| (= (in_ty) (32i8: isleType))
;;@     (= (in_ty) (64i8: isleType))),
;;@
;;@     (= (in_ty) (widthof (x))),
;;@     (= (in_ty) (widthof (y))),
;;@ ))
(decl lower_icmp (IntCC Value Value Type) FlagsAndCC)

;;@ (spec (sig (args c, x, y, in_ty) (ret))
;;@   (assertions 
;;@     (= (ret) 
;;@        (| (shl (zero_ext (12i8: isleType) 
;;@           (extract 67 64 
;;@           (if (&& (ugte (c) (2i8:bv8)) (ulte (c) (5i8:bv8))) 
;;@             (if (<= (in_ty) (32i8:isleType))
;;@               (subs (32i8:isleType) (sign_ext (regwidth) (x)) (y))
;;@               (subs (64i8:isleType) (sign_ext (regwidth) (x)) (y))
;;@             )
;;@             (if (<= (in_ty) (32i8:isleType))
;;@               (subs (32i8:isleType) (zero_ext (regwidth) (x)) (y))
;;@               (subs (64i8:isleType) (zero_ext (regwidth) (x)) (y))
;;@             )
;;@           ))
;;@          )
;;@          (8i12:bv12))
;;@       (zero_ext (12i8: isleType) (c)))
;;@     ),
;;@
;;@     (ulte (c) (9i8:bv8)),
;;@
;;@     (|| (= (in_ty) (8i8: isleType))
;;@     (|| (= (in_ty) (16i8: isleType))
;;@     (|| (= (in_ty) (32i8: isleType))
;;@     (= (in_ty) (64i8: isleType))))),
;;@
;;@     (= (in_ty) (widthof (x))),
;;@ ))
(decl lower_icmp_const (IntCC Value u64 Type) FlagsAndCC)
(extern constructor lower_icmp_const lower_icmp_const)

(rule -3 (lower_icmp cond rn (u64_from_iconst c) ty)
      (if (ty_int_ref_scalar_64 ty))
      (lower_icmp_const cond rn c ty))
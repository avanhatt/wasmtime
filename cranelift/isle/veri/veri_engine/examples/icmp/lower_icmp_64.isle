(type MInst
  (enum)
)

(type OperandSize extern
      (enum Size32
            Size64))


;; Helper for calculating the `OperandSize` corresponding to a type
;;@ (spec (sig (args ty) (ret))
;;@     (assertions (= (ret) 
;;@                    (if (<= (ty) (32i8:isleType)) 
;;@                        (32i8:isleType) 
;;@                        (64i8:isleType))),
;;@ ))
(decl operand_size (Type) OperandSize)
(rule (operand_size (fits_in_32 _ty)) (OperandSize.Size32))
(rule (operand_size (fits_in_64 _ty)) (OperandSize.Size64))

;; A tuple of `ProducesFlags` and `IntCC`.
(type FlagsAndCC (enum (FlagsAndCC (flags ProducesFlags)
                                   (cc IntCC))))
                                   
(type Cond extern
  (enum
    (Eq)
    (Ne)
    (Hs)
    (Lo)
    (Mi)
    (Pl)
    (Vs)
    (Vc)
    (Hi)
    (Ls)
    (Ge)
    (Lt)
    (Gt)
    (Le)
    (Al)
    (Nv)
))

;;@ (spec (sig (args c, x, y, in_ty) (ret))
;;@   (assertions 
;;@     (= (ret) 
;;@        (switch (c)
;;@          ((0i8:bv8) (if (= (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((1i8:bv8) (if (! (= (x) (y))) (0i8:bv8) (1i8:bv8)))
;;@          ((2i8:bv8) (if (sgt (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((3i8:bv8) (if (sgte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((4i8:bv8) (if (slt (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((5i8:bv8) (if (slte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((6i8:bv8) (if (ugt (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((7i8:bv8) (if (ugte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((8i8:bv8) (if (ult (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((9i8:bv8) (if (ulte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@        )),
;;@        (|| (= (in_ty) (8i8: isleType))
;;@        (|| (= (in_ty) (16i8: isleType))
;;@        (|| (= (in_ty) (32i8: isleType))
;;@        (= (in_ty) (64i8: isleType))))),
;;@
;;@        (= (in_ty) (widthof (x))),
;;@        (= (in_ty) (widthof (y))),
;;@ ))
(decl lower_icmp (IntCC Value Value Type) FlagsAndCC)
(extern extractor lower_icmp lower_icmp)

;;@ (spec (sig (args flags, arg) (ret))
;;@     (assertions (= (arg) (ret)),
;;@                 (= (flags) (flags))
;;@ ))

;;@ (spec (sig (args pflags, c) (ret))
;;@   (assertions 
;;@     (= (ret) 
;;@        (switch (c)
;;@          ((0i8:bv8) (if (= (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((1i8:bv8) (if (! (= (x) (y))) (0i8:bv8) (1i8:bv8)))
;;@          ((2i8:bv8) (if (sgt (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((3i8:bv8) (if (sgte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((4i8:bv8) (if (slt (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((5i8:bv8) (if (slte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((6i8:bv8) (if (ugt (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((7i8:bv8) (if (ugte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((8i8:bv8) (if (ult (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@          ((9i8:bv8) (if (ulte (x) (y)) (0i8:bv8) (1i8:bv8)))
;;@        )),
;;@        (|| (= (in_ty) (8i8: isleType))
;;@        (|| (= (in_ty) (16i8: isleType))
;;@        (|| (= (in_ty) (32i8: isleType))
;;@        (= (in_ty) (64i8: isleType))))),
;;@
;;@        (= (in_ty) (widthof (x))),
;;@        (= (in_ty) (widthof (y))),
;;@ ))
(decl flags_and_cc (ProducesFlags IntCC) FlagsAndCC)
(extern constructor flags_and_cc flags_and_cc_to_bool)

;; N: Set to 1 when the result of the operation is negative, cleared to 0 otherwise.
;; Z: Set to 1 when the result of the operation is zero, cleared to 0 otherwise.
;; C: Set to 1 when the operation results in a carry, or when a subtraction results in no borrow, cleared to 0 otherwise.
;; V: Set to 1 when the operation causes overflow, cleared to 0 otherwise.
;;@ (spec (sig (args ty, x, y) (ret))
;;@   (assertions 
;;@     (= (ret) 
;;@        (subs (ty) (x) (y))
;;@      ),
;;@      (|| (= (ty) (32i8: isleType))
;;@          (= (ty) (64i8: isleType))),
;;@ ))
(decl cmp (OperandSize Reg Reg) ProducesFlags)
(extern constructor cmp cmp)

(rule -4 (lower_icmp cond rn rm ty)
      (if (ty_int_ref_scalar_64 ty))
      (flags_and_cc (cmp (operand_size ty) rn rm) cond))
(type ImmLogic (primitive ImmLogic))
(type ImmShift (primitive ImmShift))
(type Imm12 (primitive Imm12))

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

;; Instruction formats.
(type MInst
  (enum
))

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assertions (= (- (a) (b)) (r))))
(decl sub (Type Reg Reg) Reg)
(extern constructor sub sub)

;;@ (spec (sig (args) (r))
;;@     (assertions (= (zero_ext (regwidth) (0i1:bv)) (r))))
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;;@ (spec (sig (args t, x, y) (ret))
;;@       (assertions 
;;@          (= (rotr (conv_to (t) (x)) (conv_to (t) (y))) (ret)),
;;@       )
;;@ )
(decl a64_rotr_imm (Type Reg ImmShift) Reg)
(extern constructor a64_rotr_imm a64_rotr_imm)

;; fn imm_shift_from_imm64(&mut self, ty: Type, val: Imm64) -> Option<ImmShift> {
;;     let imm_value = (val.bits() as u64) & ((ty.bits() - 1) as u64);
;;     ImmShift::maybe_from_u64(imm_value)
;; }

;; (= (conv_to (widthof (r)) (& (x) (- (int2bv 64 (ty)) (1i64:bv)))) (r)),
;; (= (0i64:bv) (& (& (x) (- (int2bv 64 (ty)) (1i64:bv))) (~ (63i64:bv))))

;; Add an assertion that the value fits, using the constand with 56 1's then 6 0's (~63)
;;@ (spec (sig (args ty, x) (r))
;;@   (assertions 
;;@     (= (r) (conv_to (widthof (r)) (x))),
;;@     (= (0i64:bv) (& (x) (~ (63i64:bv))))
;;@   )
;;@ )
(decl pure imm_shift_from_imm64 (Type Imm64) ImmShift)
(extern constructor imm_shift_from_imm64 imm_shift_from_imm64)

;; fn negate_imm_shift(&mut self, ty: Type, mut imm: ImmShift) -> ImmShift {
;;     let size = u8::try_from(ty.bits()).unwrap();
;;     imm.imm = size.wrapping_sub(imm.value());
;;     imm.imm &= size - 1;
;;     imm
;; }


;; (= (& (- (int2bv 6 (ty)) (x)) (- (int2bv 6 (ty)) (1i6:bv 6))) (r))


;;@ (spec (sig (args ty, x) (r))
;;@   (assertions 
;;@     (= (- (x)) (r))
;;@   )
;;@ )
(decl negate_imm_shift (Type ImmShift) ImmShift)
(extern constructor negate_imm_shift negate_imm_shift)

;; Specialization for the 64-bit case when the rotation amount is an immediate.
(rule 1 (lower (has_type $I64 (rotl x (iconst k))))
      (if-let n (imm_shift_from_imm64 $I64 k))
      (a64_rotr_imm $I64 x (negate_imm_shift $I64 n)))

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

;; Instruction formats.
(type MInst
  (enum
))

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assertions (= (- (a) (b)) (r))))
(decl sub (Type Reg Reg) Reg)
(extern constructor sub sub)

;;@ (spec (sig (args) (r))
;;@     (assertions (= (zero_ext (regwidth) (0i1:bv)) (r))))
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assertions (= (ret) 
;;@                    (if (= (ty) (32i0:isleType))
;;@                        { (rotr (conv_to (32i0:isleType) (x)) (conv_to (32i0:isleType) (y))) }
;;@                        else
;;@                        { (rotr (conv_to (64i0:isleType) (x)) (conv_to (64i0:isleType) (y))) }
;;@                    )
;;@                 ),
;;@                 (|| (= (ty) (32i0:isleType)) (= (ty) (64i0:isleType)))
;;@     )
;;@ )
(decl a64_rotr (Type Reg Reg) Reg)
(extern constructor a64_rotr a64_rotr)

;; General 32-bit case.
(rule (lower (has_type $I32 (rotl x y)))
      (let ((amt Reg (value_regs_get y 0))
            (neg_shift Reg (sub $I32 (zero_reg) amt)))
        (a64_rotr $I32 x neg_shift)))
(type ImmLogic (primitive ImmLogic))
(type Imm12 (primitive Imm12))

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

;;@ (spec (sig (args ty, a, b) (ret))
;;@     (assertions (= (ret) 
;;@                    (if (= (ty) (32i0:isleType))
;;@                        { (zero_ext (regwidth) (- (extract 31 0 (a)) (extract 31 0 (b)))) }
;;@                        else
;;@                        { (- (extract 63 0 (a)) (extract 63 0 (b))) }
;;@                    )
;;@                 ),
;;@                 (|| (= (ty) (32i0:isleType)) (= (ty) (64i0:isleType)))
;;@     )
;;@ )
(decl sub (Type Reg Reg) Reg)
(extern constructor sub sub)

;;@ (spec (sig (args) (r))
;;@     (assertions (= (zero_ext (regwidth) (0i1:bv)) (r))))
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;;@ (spec (sig (args a, b, c, d) (ret))
;;@     (assertions (if (b) {
;;@                     (= (ret) (sign_ext (bv2int (d)) (conv_to (bv2int (c)) (a))))
;;@                  } else { 
;;@                      (= (ret) (zero_ext (bv2int (d)) (conv_to (bv2int (c)) (a))))
;;@                  })
;;@     ))
(decl extend (Reg bool u8 u8) Reg)
(extern constructor extend extend)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assertions (= (& (a) (b)) (r))))
(decl and_imm (Type Reg ImmLogic) Reg)
(extern constructor and_imm and_imm)

;; Place a `Value` into a register, zero extending it to 32-bits
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl put_in_reg_zext32 (Value) Reg)
(extern constructor put_in_reg_zext32 put_in_reg_zext32)

;; Corresponding rust:
;; fn rotr_mask(&mut self, ty: Type) -> ImmLogic {
;;     ImmLogic::maybe_from_u64((ty.bits() - 1) as u64, I32).unwrap()
;; }
;;
;;@ (spec (sig (args x) (ret))
;;@   (assertions (= (- (int2bv 12 (x)) (1i12:bv)) (ret))))
(decl rotr_mask (Type) ImmLogic)
(extern constructor rotr_mask rotr_mask)

;; Note that 4094 = 0xffe and 16773119 = 0xffefff
;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assertions (|| (<= (bv2int (y)) (4094i0:isleType))
;;@                     (&& (<= (bv2int (y)) (16773119i0:isleType))
;;@                         (= (extract 2 0 (y)) (0i3:bv))
;;@                 )),
;;@                 (= (ret) (- (x) (zero_ext (regwidth) (y))))
;;@ ))
(decl sub_imm (Type Reg Imm12) Reg)
(extern constructor sub_imm sub_imm)

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (ret) (zero_ext (24) (arg)))))
(decl u8_into_imm12 (u8) Imm12)
(extern constructor u8_into_imm12 u8_into_imm12)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assertions (= (shr (a) (b)) (r))))
(decl lsr (Type Reg Reg) Reg)
(extern constructor lsr lsr)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assertions (= (shl (a) (b)) (r))))
(decl lsl (Type Reg Reg) Reg)
(extern constructor lsl lsl)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assertions (= (| (a) (b)) (r))))
(decl orr (Type Reg Reg) Reg)
(extern constructor orr orr)

;; Instruction formats.
(type MInst
  (enum
))

;; General 8/16-bit case.
(rule -2 (lower (has_type (fits_in_16 ty) (rotl x y)))
      (let ((amt Reg (value_regs_get y 0))
            (neg_shift Reg (sub $I32 (zero_reg) amt)))
        (small_rotr ty (put_in_reg_zext32 x) neg_shift)))


;;@ (spec (sig (args t, x, y) (ret))
;;@       (assertions 
;;@          (= (rotr (x) (y)) (ret)),
;;@          (= (widthof (x)) (t)), 
;;@          (<= (widthof (x)) (16i128: isleType)), 
;;@          (<= (widthof (y)) (16i128: isleType)), 
;;@       )
;;@ )
(decl small_rotr (Type Reg Reg) Reg)
(extern constructor small_rotr small_rotr)
(type ImmLogic (primitive ImmLogic))

;; Instruction formats.
(type MInst
  (enum
))

;;@ (spec (sig (args) (ret))
;;@       (assertions (= (0i64:bv) (ret))))
;;decl ALUOp.Lsl

;;@ (spec (sig (args) (ret))
;;@       (assertions (= (1i64:bv) (ret))))
;;decl ALUOp.Lsr

;;@ (spec (sig (args) (ret))
;;@       (assertions (= (2i64:bv) (ret))))
;;decl ALUOp.Asr

;; An ALU operation. This can be paired with several instruction formats
;; below (see `Inst`) in any combination.
(type ALUOp
  (enum
    (Add)
    (Sub)
    (Orr)
    (OrrNot)
    (And)
    (AndS)
    (AndNot)
    ;; XOR (AArch64 calls this "EOR")
    (Eor)
    ;; XNOR (AArch64 calls this "EOR-NOT")
    (EorNot)
    ;; Add, setting flags
    (AddS)
    ;; Sub, setting flags
    (SubS)
    ;; Signed multiply, high-word result
    (SMulH)
    ;; Unsigned multiply, high-word result
    (UMulH)
    (SDiv)
    (UDiv)
    (RotR)
    (Lsr)
    (Asr)
    (Lsl)
    ;; Add with carry
    (Adc)
    ;; Add with carry, settings flags
    (AdcS)
    ;; Subtract with carry
    (Sbc)
    ;; Subtract with carry, settings flags
    (SbcS)
))

;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assertions (|| (<= (bv2int (y)) (4094i0:isleType))
;;@                     (&& (<= (bv2int (y)) (16773119i0:isleType))
;;@                         (= (extract 2 0 (y)) (0i3:bv))
;;@                 )),
;;@       (= (ret) 
;;@          (switch (ty) 
;;@            ((32i8: isleType) (conv_to (regwidth) (& (extract 31 0 (x)) (extract 31 0 (y)))))
;;@            ((64i8: isleType) (& (x) (zero_ext (regwidth) (y))))
;;@          )
;;@       )
;;@ ))
(decl and_imm (Type Reg ImmLogic) Reg)
(extern constructor and_imm and_imm)

;;@ (spec (sig (args op, t, a, b) (ret))
;;@   (assertions 
;;@     (= (ret) 
;;@          (switch (op) 
;;@                  ((0i64:bv) (conv_to (regwidth) (shl (conv_to (t) (a)) (conv_to (t) (zero_ext (regwidth) (b))))))
;;@                  ((1i64:bv) (conv_to (regwidth) (shr (conv_to (t) (a)) (conv_to (t) (zero_ext (regwidth) (b))))))
;;@                  ((2i64:bv) (conv_to (regwidth) (ashr (conv_to (t) (a)) (conv_to (t) (zero_ext (regwidth) (b))))))
;;@                  )),
;;@                  (|| (= (op) (0i64:bv)) (|| (= (op) (1i64:bv)) (= (op) (2i64:bv)))),
;;@                  (|| (= (t) (8i8: isleType))
;;@                  (|| (= (t) (16i8: isleType))
;;@                  (|| (= (t) (32i8: isleType))
;;@                      (= (t) (64i8: isleType)))))
;;@     ))
(decl do_shift (ALUOp Type Reg Value) Reg)

;;@ (spec (sig (args op, t, a, b) (ret))
;;@     (assertions 
;;@       (= (ret) (switch (op)
;;@               ((0i64:bv) (conv_to (regwidth) (shl (conv_to (if (<= (t) (32i8: isleType)) (32i8: isleType) (64i8: isleType)) (a)) 
;;@                                                   (conv_to (if (<= (t) (32i8: isleType)) (32i8: isleType) (64i8: isleType)) (b)))))
;;@               ((1i64:bv) (conv_to (regwidth) (shr (conv_to (if (<= (t) (32i8: isleType)) (32i8: isleType) (64i8: isleType)) (a))
;;@                                                   (conv_to (if (<= (t) (32i8: isleType)) (32i8: isleType) (64i8: isleType)) (b)))))
;;@               ((2i64:bv) (conv_to (regwidth) (ashr (conv_to (if (<= (t) (32i8: isleType)) (32i8: isleType) (64i8: isleType)) (a)) 
;;@                                                   (conv_to (if (<= (t) (32i8: isleType)) (32i8: isleType) (64i8: isleType)) (b)))))
;;@       )),
;;@       (|| (= (op) (0i64:bv)) (|| (= (op) (1i64:bv)) (= (op) (2i64:bv)))),
;;@       (|| (= (t) (8i8: isleType))
;;@       (|| (= (t) (16i8: isleType))
;;@       (|| (= (t) (32i8: isleType))
;;@           (= (t) (64i8: isleType)))))
;;@     ))
(decl alu_rrr (ALUOp Type Reg Reg) Reg)
(extern constructor alu_rrr alu_rrr)

;;@ (spec (sig (args x) (ret))
;;@   (assertions (= (- (int2bv 64 (x)) (1i64:bv)) (ret))))
(decl shift_mask (Type) ImmLogic)
(extern constructor shift_mask shift_mask)

(rule -1 (do_shift op (fits_in_16 ty) x y)
      (let ((shift_amt Reg (value_regs_get y 0))
            (masked_shift_amt Reg (and_imm $I32 shift_amt (shift_mask ty))))
        (alu_rrr op $I32 x masked_shift_amt)))

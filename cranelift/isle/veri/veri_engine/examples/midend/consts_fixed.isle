(type Type (primitive Type))
(type Value (primitive Value))
(type u64 (primitive u64))
(type Imm64 (primitive Imm64))
(type bool (primitive bool))
(extern const $true bool)

;;@ (spec (sig (args x) (ret))
;;@       (assertions (= (x) (ret))))
(decl simplify (Value) Value)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (| (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y)))
;;@ ))
(decl bor (Type Value Value) Value)
(extern extractor bor bor)
(extern constructor bor bor)

;;@ (spec (sig (args ty, x) (ret))
;;@       (assertions (= (~ (x)) (ret)),
;;@                   (= (ty) (widthof (x)))
;;@ ))
(decl bnot (Type Value) Value)
(extern extractor bnot bnot)
(extern constructor bnot bnot)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (& (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y)))
;;@ ))
(decl band (Type Value Value) Value)
(extern extractor band band)
(extern constructor band band)

;; Specify to this rule with constants
;;@ (spec (sig (args ty, arg) (ret))
;;@     (assertions (= (arg) (zero_ext (64) (ret))),
;;@                 (= (ty) (widthof (ret)))
;;@ ))
(decl iconst (Type Imm64) Value)
(extern constructor iconst iconst)
(extern extractor iconst iconst)

;; Extract a `u64` from an `Imm64`.
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl u64_from_imm64 (u64) Imm64)
(extern extractor u64_from_imm64 u64_from_imm64)

;;@ (spec (sig (args x, y) (ret))
;;@       (assertions (= (if (= (x) (y)) { (true) } else { (false) }) (ret))))
(decl pure u64_eq (u64 u64) bool)
(extern constructor u64_eq u64_eq)

;;@ (spec (sig (args x, y) (ret))
;;@       (assertions (= (& (x) (y)) (ret))))
(decl pure u64_and (u64 u64) u64)
(extern constructor u64_and u64_and)

;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (~ (arg)) (ret))))
(decl pure u64_not (u64) u64)
(extern constructor u64_not u64_not)

;;@ (spec (sig (args ty) (ret))
;;@     (assertions (= (ret) (if (= (ty) (8i0:isleType)) {
;;@                     (zero_ext (64) (sign_ext (8) (1i1:bv)))
;;@                  } else { 
;;@                      (if (= (ty) (16i0:isleType)) {
;;@                          (zero_ext (64) (sign_ext (16) (1i1:bv)))
;;@                      } else { 
;;@                          (if (= (ty) (32i0:isleType)) {
;;@                              (zero_ext (64) (sign_ext (32) (1i1:bv)))
;;@                          } else { 
;;@                              (sign_ext (64) (1i1:bv))
;;@                          })
;;@                      })
;;@                  })
;;@                 )
;;@     )
;;@ )
(decl pure ty_mask (Type) u64)
(extern constructor ty_mask ty_mask)

;; `or(and(x, y), not(y)) == or(x, not(y))` specialized for constants, since
;; otherwise we may not know that `z == not(y)` since we don't generally expand
;; constants in the e-graph.
;;
;; (No need to duplicate for commutative `bor` for this constant version because
;; we move constants to the right.)
(rule (simplify (bor ty
                      (band ty x (iconst ty (u64_from_imm64 y)))
                      z @ (iconst ty (u64_from_imm64 zk))))
       (if-let $true (u64_eq (u64_and (ty_mask ty) zk)
                             (u64_and (ty_mask ty) (u64_not y))))
       (bor ty x z))
;; VERI: relevant parts of prelude/definitions
(type Type (primitive Type))
(type Value (primitive Value))
(type u64 (primitive u64))
(type Imm64 (primitive Imm64))
(type bool (primitive bool))
(extern const $true bool)

;;@ (spec (sig (args x) (ret))
;;@       (assertions (= (x) (ret))))
(decl simplify (Value) Value)

;;@ (spec (sig (args x) (ret))
;;@       (assertions (= (x) (ret))))
(decl subsume (Value) Value)
(extern constructor subsume subsume)

;; An extractor that only matches types that can fit in 64 bits.
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret)), (<= (arg) (64i128: isleType))))
(decl fits_in_64 (Type) Type)
(extern extractor fits_in_64 fits_in_64)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (+ (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y))),
;;@))
(decl iadd (Type Value Value) Value)
(extern constructor iadd iadd)
(extern extractor iadd iadd)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (- (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y))),
;;@))
(decl isub (Type Value Value) Value)
(extern constructor isub isub)
(extern extractor isub isub)

;;@ (spec (sig (args ty, x) (ret))
;;@       (assertions (= (- (x)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@))
(decl ineg (Type Value) Value)
(extern constructor ineg ineg)
(extern extractor ineg ineg)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (| (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y)))
;;@ ))
(decl bor (Type Value Value) Value)
(extern extractor bor bor)
(extern constructor bor bor)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (xor (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y)))
;;@ ))
(decl bxor (Type Value Value) Value)
(extern extractor bxor bxor)
(extern constructor bxor bxor)

;;@ (spec (sig (args ty, x) (ret))
;;@       (assertions (= (~ (x)) (ret)),
;;@                   (= (ty) (widthof (x)))
;;@ ))
(decl bnot (Type Value) Value)
(extern extractor bnot bnot)
(extern constructor bnot bnot)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assertions (= (& (x) (y)) (ret)),
;;@                   (= (ty) (widthof (x))),
;;@                   (= (ty) (widthof (y)))
;;@ ))
(decl band (Type Value Value) Value)
(extern extractor band band)
(extern constructor band band)

;; Specify to this rule with constants
;;@ (spec (sig (args ty, arg) (ret))
;;@     (assertions (= (arg) (zero_ext (64) (ret))),
;;@                 (= (ty) (widthof (ret)))
;;@ ))
(decl iconst (Type Imm64) Value)
(extern constructor iconst iconst)
(extern extractor iconst iconst)

;; Extract a `u64` from an `Imm64`.
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl u64_from_imm64 (u64) Imm64)
(extern extractor u64_from_imm64 u64_from_imm64)

;;@ (spec (sig (args x, y) (ret))
;;@       (assertions (= (+ (x) (y)) (ret))))
(decl pure u64_add (u64 u64) u64)
(extern constructor u64_add u64_add)

;;@ (spec (sig (args x, y) (ret))
;;@       (assertions (= (- (x) (y)) (ret))))
(decl pure u64_sub (u64 u64) u64)
(extern constructor u64_sub u64_sub)

;; Create a new Imm64, masked to the width of the given type.
;;@ (spec (sig (args ty, x) (ret))
;;@     (assertions (= (ret) (if (= (ty) (8i0:isleType)) {
;;@                     (zero_ext (64) (extract 7 0 (x)))
;;@                  } else { 
;;@                      (if (= (ty) (16i0:isleType)) {
;;@                          (zero_ext (64) (extract 15 0 (x)))
;;@                      } else { 
;;@                          (if (= (ty) (32i0:isleType)) {
;;@                              (zero_ext (64) (extract 31 0 (x)))
;;@                          } else { 
;;@                              (x)
;;@                          })
;;@                      })
;;@                  })
;;@                 )
;;@     )
;;@ )
(decl pure imm64_masked (Type u64) Imm64)
(extern constructor imm64_masked imm64_masked)

;; ISLE starts
;; Constant propagation.

(rule (simplify
       (iadd (fits_in_64 ty)
             ; NOTE: added "x @" to get around query width shortcoming
             x @ (iconst ty (u64_from_imm64 k1))
             (iconst ty (u64_from_imm64 k2))))
      (subsume (iconst ty (imm64_masked ty (u64_add k1 k2)))))

(rule (simplify
       (isub (fits_in_64 ty)
             ; NOTE: added "x @" to get around query width shortcoming
             x @ (iconst ty (u64_from_imm64 k1))
             (iconst ty (u64_from_imm64 k2))))
      (subsume (iconst ty (imm64_masked ty (u64_sub k1 k2)))))


;; (rule (simplify
;;        (imul (fits_in_64 ty)
;;              (iconst ty (u64_from_imm64 k1))
;;              (iconst ty (u64_from_imm64 k2))))
;;       (subsume (iconst ty (imm64_masked ty (u64_mul k1 k2)))))

;; (rule (simplify
;;        (sdiv (fits_in_64 ty)
;;              (iconst ty (u64_from_imm64 k1))
;;              (iconst ty (u64_from_imm64 k2))))
;;       (if-let d (u64_sdiv k1 k2))
;;       (subsume (iconst ty (imm64_masked ty d))))

;; (rule (simplify
;;        (udiv (fits_in_64 ty)
;;              (iconst ty (u64_from_imm64 k1))
;;              (iconst ty (u64_from_imm64 k2))))
;;       (if-let d (u64_udiv k1 k2))
;;       (subsume (iconst ty (imm64_masked ty d))))

;; (rule (simplify
;;        (bor (fits_in_64 ty)
;;             (iconst ty (u64_from_imm64 k1))
;;             (iconst ty (u64_from_imm64 k2))))
;;       (subsume (iconst ty (imm64_masked ty (u64_or k1 k2)))))

;; (rule (simplify
;;        (band (fits_in_64 ty)
;;             (iconst ty (u64_from_imm64 k1))
;;             (iconst ty (u64_from_imm64 k2))))
;;       (subsume (iconst ty (imm64_masked ty (u64_and k1 k2)))))

;; (rule (simplify
;;        (bxor (fits_in_64 ty)
;;             (iconst ty (u64_from_imm64 k1))
;;             (iconst ty (u64_from_imm64 k2))))
;;       (subsume (iconst ty (imm64_masked ty (u64_xor k1 k2)))))

;; (rule (simplify
;;        (bnot (fits_in_64 ty)
;;             (iconst ty (u64_from_imm64 k))))
;;       (subsume (iconst ty (imm64_masked ty (u64_not k)))))

;; (rule (simplify (ishl (fits_in_64 ty)
;;                       (iconst ty (u64_from_imm64 k1))
;;                       (iconst ty (u64_from_imm64 k2))))
;;       (subsume (iconst ty (imm64_masked ty (u64_shl k1 k2)))))

;; (rule (simplify (ushr (fits_in_64 ty)
;;                       (iconst ty k1)
;;                       (iconst ty k2)))
;;       (subsume (iconst ty (imm64_ushr ty k1 k2))))

;; (rule (simplify (sshr (fits_in_64 ty)
;;                       (iconst ty k1)
;;                       (iconst ty k2)))
;;       (subsume (iconst ty (imm64_sshr ty k1 k2))))

;; (rule (simplify
;;        (icmp result_ty
;;             cc
;;             (iconst ty k1)
;;             (iconst ty k2)))
;;       (subsume (iconst result_ty (imm64_icmp ty cc k1 k2))))


;; Canonicalize via commutativity: push immediates to the right.
;;
;;   (op k x) --> (op x k)

(rule (simplify
       (iadd ty k @ (iconst ty _) x))
      (iadd ty x k))
;; sub is not commutative, but we can flip the args and negate the
;; whole thing.
(rule (simplify
       (isub ty k @ (iconst ty _) x))
      (ineg ty (isub ty x k)))
;; (rule (simplify
;;        (imul ty k @ (iconst ty _) x))
;;       (imul ty x k))

;; (rule (simplify
;;        (bor ty k @ (iconst ty _) x))
;;       (bor ty x k))
;; (rule (simplify
;;        (band ty k @ (iconst ty _) x))
;;       (band ty x k))
;; (rule (simplify
;;        (bxor ty k @ (iconst ty _) x))
;;       (bxor ty x k))

;; Canonicalize via associativity: reassociate to a right-heavy tree
;; for constants.
;;
;;   (op (op x k) k) --> (op x (op k k))

(rule (simplify
       (iadd ty (iadd ty x k1 @ (iconst ty _)) k2 @ (iconst ty _)))
      (iadd ty x (iadd ty k1 k2)))
;; sub is not directly associative, but we can flip a sub to an add to
;; make it work:
;; - (sub (sub x k1) k2) -> (sub x (add k1 k2))
;; - (sub (sub k1 x) k2) -> (sub (sub k1 k2) x)
;; - (sub (add x k1) k2) -> (sub x (sub k2 k1))
;; - (add (sub x k1) k2) -> (add x (sub k2 k1))
;; - (add (sub k1 x) k2) -> (sub (add k1 k2) x)
(rule (simplify (isub ty
                      (isub ty x (iconst ty (u64_from_imm64 k1)))
                      (iconst ty (u64_from_imm64 k2))))
      (isub ty x (iconst ty (imm64_masked ty (u64_add k1 k2)))))
(rule (simplify (isub ty
                      (isub ty (iconst ty (u64_from_imm64 k1)) x)
                      (iconst ty (u64_from_imm64 k2))))
      (isub ty (iconst ty (imm64_masked ty (u64_sub k1 k2))) x))
(rule (simplify (isub ty
                      (iadd ty x (iconst ty (u64_from_imm64 k1)))
                      (iconst ty (u64_from_imm64 k2))))
      (isub ty x (iconst ty (imm64_masked ty (u64_sub k2 k1)))))
(rule (simplify (iadd ty
                      (isub ty x (iconst ty (u64_from_imm64 k1)))
                      (iconst ty (u64_from_imm64 k2))))
      (iadd ty x (iconst ty (imm64_masked ty (u64_sub k2 k1)))))
(rule (simplify (iadd ty
                      (isub ty (iconst ty (u64_from_imm64 k1)) x)
                      (iconst ty (u64_from_imm64 k2))))
      (isub ty (iconst ty (imm64_masked ty (u64_add k1 k2))) x))

;; (rule (simplify
;;        (imul ty (imul ty x k1 @ (iconst ty _)) k2 @ (iconst ty _)))
;;       (imul ty x (imul ty k1 k2)))
;; (rule (simplify
;;        (bor ty (bor ty x k1 @ (iconst ty _)) k2 @ (iconst ty _)))
;;       (bor ty x (bor ty k1 k2)))
;; (rule (simplify
;;        (band ty (band ty x k1 @ (iconst ty _)) k2 @ (iconst ty _)))
;;       (band ty x (band ty k1 k2)))
;; (rule (simplify
;;        (bxor ty (bxor ty x k1 @ (iconst ty _)) k2 @ (iconst ty _)))
;;       (bxor ty x (bxor ty k1 k2)))

;; (rule (simplify
;;        (select ty (iconst _ (u64_from_imm64 (u64_nonzero _))) x y))
;;       x)
;; (rule (simplify
;;        (select ty (iconst _ (u64_from_imm64 0)) x y))
;;       y)

;; TODO: fadd, fsub, fmul, fdiv, fneg, fabs
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) InstOutput)

(type MInst
  (enum
       (AluRRRShift
           (shiftop ShiftOpAndAmt))
))

;; ASSUMING 64 BIT MODE!!!
;; annotations will interpret this as an 10 bit field
;; the two msb encode the type of shift as follows:
;;   00: lsl
;;   01: lsr
;;   10: asr
;;   11: invalid
;; the rest will encode a 8-bit shift amount 
(type ShiftOpAndAmt (primitive ShiftOpAndAmt))

(type ALUOp
  (enum
    (Sub)
))

(decl alu_rrr_shift (ALUOp Type Reg Reg ShiftOpAndAmt) Reg)
(extern constructor alu_rrr_shift alu_rrr_shift)

;;@ (spec (sig (args ty, a, b, shift) (ret))
;;@   (assertions 
;;@     (switch (extract 9 8 (shift))
;;@             ((0i2:bv) (= (ret) (- (a) (shl (b) (zero_ext (widthof (b)) (& (- (int2bv 8 (ty)) (1i8:bv8)) (extract 7 0 (shift))))))))
;;@             ((1i2:bv) (= (ret) (- (a) (shr (b) (zero_ext (widthof (b)) (& (- (int2bv 8 (ty)) (1i8:bv8)) (extract 7 0 (shift))))))))
;;@             ((2i2:bv) (= (ret) (- (a) (ashr (b) (zero_ext (widthof (b)) (& (- (int2bv 8 (ty)) (1i8:bv8)) (extract 7 0 (shift))))))))),
;;@                 (|| (= (extract 9 8 (shift)) (0i2:bv)) 
;;@                     (|| (= (extract 9 8 (shift)) (1i2:bv)) 
;;@                         (= (extract 9 8 (shift)) (2i2:bv))))
;;@ ))
(decl sub_shift (Type Reg Reg ShiftOpAndAmt) Reg)
(rule (sub_shift ty x y z) (alu_rrr_shift (ALUOp.Sub) ty x y z))

;;@ (spec (sig (args ty, a) (ret))
;;@     (assertions (= (extract 63 8 (a)) (0i56:bv)),
;;@                 (= (ret) (zero_ext (10) (extract 7 0 (a))))))
(decl pure lshl_from_imm64 (Type Imm64) ShiftOpAndAmt)
(extern constructor lshl_from_imm64 lshl_from_imm64)

(rule -3 (lower (has_type (fits_in_64 ty)
                       (isub x (ishl y (iconst k)))))
      (if-let amt (lshl_from_imm64 ty k))
      (sub_shift ty x y amt))
;;@ (spec (sig (args arg) (ret))
;;@     (assertions (= (arg) (ret))))
(decl lower (Inst) ValueRegs)

;; Instruction formats.
(type MInst
  (enum
    ;; A no-op of zero size.
    (Nop0)

    ;; A no-op that is one instruction large.
    (Nop4)

    ;; An ALU operation with two register sources and a register destination.
    (AluRRR
      (alu_op ALUOp)
      (size OperandSize)
      (rd WritableReg)
      (rn Reg)
      (rm Reg))
))

;; An ALU operation. This can be paired with several instruction formats
;; below (see `Inst`) in any combination.
(type ALUOp
  (enum
    (Add)
    (Sub)
    (Orr)
    (OrrNot)
    (And)))

(type OperandSize extern
      (enum Size32
            Size64))

;; Helper for calculating the `OperandSize` corresponding to a type
(decl operand_size (Type) OperandSize)
(rule (operand_size (fits_in_32 _ty)) (OperandSize.Size32))
(rule (operand_size (fits_in_64 _ty)) (OperandSize.Size64))

;;@ (spec (sig (args x, y) (ret))
;;@       (assertions (= (- (x) (y)) (ret))))
(decl sub (Type Reg Reg) Reg)
(rule (sub ty x y) (alu_rrr (ALUOp.Sub) ty x y))

;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrr (ALUOp Type Reg Reg) Reg)
(rule (alu_rrr op ty src1 src2)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRR op (operand_size ty) dst src1 src2))))
        dst))

;; Helper for creating the zero register.
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

(decl small_rotr (Type Reg Reg) Reg)
(rule (small_rotr ty val amt)
      (let ((masked_amt Reg (and_imm $I32 amt (rotr_mask ty)))
            (tmp_sub Reg (sub_imm $I32 masked_amt (u8_into_imm12 (ty_bits ty))))
            (neg_amt Reg (sub $I32 (zero_reg) tmp_sub))
            (val_rshift Reg (lsr $I32 val masked_amt))
            (val_lshift Reg (lsl $I32 val neg_amt)))
        (orr $I32 val_lshift val_rshift)))

;;;; Rules for `rotl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; General 8/16-bit case.
(rule (lower (has_type (fits_in_16 ty) (rotl x y)))
      (let ((neg_shift Reg (sub $I32 (zero_reg) y)))
        (small_rotr ty (put_in_reg_zext32 x) neg_shift)))

;; ;; Specialization for the 8/16-bit case when the rotation amount is an immediate.
;; (rule (lower (has_type (fits_in_16 ty) (rotl x (iconst k))))
;;       (if-let n (imm_shift_from_imm64 ty k))
;;       (small_rotr_imm ty (put_in_reg_zext32 x) (negate_imm_shift ty n)))

;; ;; aarch64 doesn't have a left-rotate instruction, but a left rotation of K
;; ;; places is effectively a right rotation of N - K places, if N is the integer's
;; ;; bit size. We implement left rotations with this trick.
;; ;;
;; ;; Note that when negating the shift amount here the upper bits are ignored
;; ;; by the rotr instruction, meaning that we'll still left-shift by the desired
;; ;; amount.

;; ;; General 32-bit case.
;; (rule (lower (has_type $I32 (rotl x y)))
;;       (let ((neg_shift Reg (sub $I32 (zero_reg) y)))
;;         (a64_rotr $I32 x neg_shift)))

;; ;; General 64-bit case.
;; (rule (lower (has_type $I64 (rotl x y)))
;;       (let ((neg_shift Reg (sub $I64 (zero_reg) y)))
;;         (a64_rotr $I64 x neg_shift)))

;; ;; Specialization for the 32-bit case when the rotation amount is an immediate.
;; (rule (lower (has_type $I32 (rotl x (iconst k))))
;;       (if-let n (imm_shift_from_imm64 $I32 k))
;;       (a64_rotr_imm $I32 x (negate_imm_shift $I32 n)))

;; ;; Specialization for the 64-bit case when the rotation amount is an immediate.
;; (rule (lower (has_type $I64 (rotl x (iconst k))))
;;       (if-let n (imm_shift_from_imm64 $I64 k))
;;       (a64_rotr_imm $I64 x (negate_imm_shift $I64 n)))

;; (decl negate_imm_shift (Type ImmShift) ImmShift)
;; (extern constructor negate_imm_shift negate_imm_shift)

;; ;; General 128-bit case.
;; ;;
;; ;; TODO: much better codegen is possible with a constant amount.
;; (rule (lower (has_type $I128 (rotl x y)))
;;       (let ((val ValueRegs x)
;;             (amt Reg (value_regs_get y 0))
;;             (neg_amt Reg (sub $I64 (imm $I64 128) amt))
;;             (lshift ValueRegs (lower_shl128 val amt))
;;             (rshift ValueRegs (lower_ushr128 val neg_amt)))
;;         (value_regs
;;           (orr $I64 (value_regs_get lshift 0) (value_regs_get rshift 0))
;;           (orr $I64 (value_regs_get lshift 1) (value_regs_get rshift 1)))))
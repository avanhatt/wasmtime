(type ImmLogic (primitive ImmLogic))
(type Imm12 (primitive Imm12))

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  (= (- (a) (b)) (r))))
(decl sub (Type Reg Reg) Reg)
(extern constructor sub sub)

;;@ (spec (sig (args) (r))
;;@     (assume  (= (zero_ext (regwidth) (0i1:bv)) (r))))
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;;@ (spec (sig (args a, b, c, d) (ret))
;;@     (assume  (if (b)
;;@                     (= (ret) (sign_ext (bv2int (d)) (conv_to (bv2int (c)) (a))))
;;@                     (= (ret) (zero_ext (bv2int (d)) (conv_to (bv2int (c)) (a))))
;;@                 )
;;@     ))
(decl extend (Reg bool u8 u8) Reg)
(extern constructor extend extend)

;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assume  (|| (<= (bv2int (y)) (4094i0:int))
;;@                     (&& (<= (bv2int (y)) (16773119i0:int))
;;@                         (= (extract 2 0 (y)) (0i3:bv))
;;@                 )),
;;@       (= (ret) 
;;@          (switch (ty) 
;;@            ((32i8: int) (conv_to (regwidth) (& (extract 31 0 (x)) (extract 31 0 (y)))))
;;@            ((64i8: int) (& (x) (zero_ext (regwidth) (y))))
;;@          )
;;@       )
;;@ ))
(decl and_imm (Type Reg ImmLogic) Reg)
(extern constructor and_imm and_imm)

;; Place a `Value` into a register, zero extending it to 32-bits
;;@ (spec (sig (args arg) (ret))
;;@     (assume  (
;;@          if (<= (32i0:int) (widthof (arg))) 
;;@             (= (ret) (conv_to (regwidth) (arg)))             
;;@             (= (ret) (conv_to (regwidth) (zero_ext (32) (arg))))
;;@          )
;;@ ))
(decl put_in_reg_zext32 (Value) Reg)
(extern constructor put_in_reg_zext32 put_in_reg_zext32)

;; Corresponding rust:
;; fn rotr_mask(&mut self, ty: Type) -> ImmLogic {
;;     ImmLogic::maybe_from_u64((ty.bits() - 1) as u64, I32).unwrap()
;; }
;;
;;@ (spec (sig (args x) (ret))
;;@   (assume  (= (- (int2bv 64 (x)) (1i64:bv64)) (ret))))
(decl rotr_mask (Type) ImmLogic)
(extern constructor rotr_mask rotr_mask)

;; Note that 4094 = 0xffe and 16773119 = 0xffefff
;;@ (spec (sig (args ty, x, y) (ret))
;;@     (assume  (|| (<= (bv2int (y)) (4094i0:int))
;;@                     (&& (<= (bv2int (y)) (16773119i0:int))
;;@                         (= (extract 2 0 (y)) (0i3:bv))
;;@                 )),
;;@       (= (ret) 
;;@          (switch (ty) 
;;@            ((32i8: int) (conv_to (regwidth) (- (extract 31 0 (x)) (zero_ext (32) (y)))))
;;@            ((64i8: int) (- (x) (zero_ext (regwidth) (y))))
;;@          )
;;@       )
;;@ ))
(decl sub_imm (Type Reg Imm12) Reg)
(extern constructor sub_imm sub_imm)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (ret) (zero_ext (24) (arg)))))
(decl u8_into_imm12 (u8) Imm12)
(extern constructor u8_into_imm12 u8_into_imm12)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: int) (conv_to (regwidth) (shr (extract 31 0 (a)) (extract 31 0 (b)))))
;;@            ((64i8: int) (shr (a) (b)))
;;@          )
;;@       )
;;@ ))
(decl lsr (Type Reg Reg) Reg)
(extern constructor lsr lsr)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: int) (conv_to (regwidth) (shl (extract 31 0 (a)) (extract 31 0 (b)))))
;;@            ((64i8: int) (shl (a) (b)))
;;@          )
;;@       )
;;@ ))
(decl lsl (Type Reg Reg) Reg)
(extern constructor lsl lsl)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: int) (conv_to (regwidth) (| (extract 31 0 (a)) (extract 31 0 (b)))))
;;@            ((64i8: int) (| (a) (b)))
;;@          )
;;@       )
;;@ ))
(decl orr (Type Reg Reg) Reg)
(extern constructor orr orr)

;; Instruction formats.
(type MInst
  (enum
))


;;@ (spec (sig (args t, x, y) (ret))
;;@       (assume  
;;@          (= (ret) 
;;@             (switch (t)
;;@               ((8i8: int) (conv_to (regwidth) (rotr (extract 7 0 (x)) (extract 7 0 (y)))))
;;@               ((16i8: int) (conv_to (regwidth) (rotr (extract 15 0 (x)) (extract 15 0 (y)))))
;;@             )),
;;@          (|| (= (t) (8i8: int)) 
;;@              (= (t) (16i8: int))),
;;@          (switch (t)
;;@            ((8i8: int) (= (extract 31 8 (x)) (0i32:bv24)))
;;@            ((16i8: int) (= (extract 31 16 (x)) (0i32:bv16)))
;;@          ),
;;@       )
;;@ )
(decl small_rotr (Type Reg Reg) Reg)

;;@ (spec (sig (args ty, a, b) (r))
;;@     (assume  
;;@       (= (r) 
;;@          (switch (ty) 
;;@            ((32i8: int) (conv_to (regwidth) (& (extract 31 0 (a)) (extract 31 0 (b)))))
;;@            ((64i8: int) (& (a) (b)))
;;@          )
;;@       )
;;@ ))
(decl and_reg (Type Reg Reg) Reg)
(extern constructor and_reg and_reg)

;; BROKEN: uses AND instead of OR

;; For a < 32-bit rotate-right, we synthesize this as: 
;;
;;    rotr rd, val, amt
;;
;;       =>
;;
;;    and masked_amt, amt, <bitwidth - 1>
;;    sub tmp_sub, masked_amt, <bitwidth>
;;    sub neg_amt, zero, tmp_sub  ; neg
;;    lsr val_rshift, val, masked_amt
;;    lsl val_lshift, val, neg_amt
;;    orr rd, val_lshift val_rshift
(rule (small_rotr ty val amt)
      (let ((masked_amt Reg (and_imm $I32 amt (rotr_mask ty)))
            (tmp_sub Reg (sub_imm $I32 masked_amt (u8_into_imm12 (ty_bits ty))))
            (neg_amt Reg (sub $I32 (zero_reg) tmp_sub))
            (val_rshift Reg (lsr $I32 val masked_amt))
            (val_lshift Reg (lsl $I32 val neg_amt)))
        (and_reg $I32 val_lshift val_rshift)))


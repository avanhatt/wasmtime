;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (arg) (ret))))
(decl lower (Inst) InstOutput)

;; Instruction formats.
(type MInst
  (enum
))

;;@ (spec (sig (args) (ret))
;;@       (assume  (= (0i64:bv) (ret))))
;;decl ALUOp.Lsl

;;@ (spec (sig (args) (ret))
;;@       (assume  (= (1i64:bv) (ret))))
;;decl ALUOp.Lsr

;;@ (spec (sig (args) (ret))
;;@       (assume  (= (2i64:bv) (ret))))
;;decl ALUOp.Asr

;; An ALU operation. This can be paired with several instruction formats
;; below (see `Inst`) in any combination.
(type ALUOp
  (enum
    (Add)
    (Sub)
    (Orr)
    (OrrNot)
    (And)
    (AndS)
    (AndNot)
    ;; XOR (AArch64 calls this "EOR")
    (Eor)
    ;; XNOR (AArch64 calls this "EOR-NOT")
    (EorNot)
    ;; Add, setting flags
    (AddS)
    ;; Sub, setting flags
    (SubS)
    ;; Signed multiply, high-word result
    (SMulH)
    ;; Unsigned multiply, high-word result
    (UMulH)
    (SDiv)
    (UDiv)
    (RotR)
    (Lsr)
    (Asr)
    (Lsl)
    ;; Add with carry
    (Adc)
    ;; Add with carry, settings flags
    (AdcS)
    ;; Subtract with carry
    (Sbc)
    ;; Subtract with carry, settings flags
    (SbcS)
))

;;@ (spec (sig (args op, t, a, b) (ret))
;;@   (assume  
;;@     (= (ret) 
;;@          (switch (op) 
;;@            ((0i64:bv) (conv_to (regwidth) 
;;@                         (shl (conv_to (t) (a)) 
;;@                           (conv_to (t) (zero_ext (regwidth) 
;;@                             (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv64))) (b)))))))
;;@                  ((1i64:bv) (conv_to (regwidth) 
;;@                         (shr (conv_to (t) (a)) 
;;@                           (conv_to (t) (zero_ext (regwidth) 
;;@                             (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv))) (b)))))))
;;@                  ((2i64:bv) (conv_to (regwidth) 
;;@                         (ashr (conv_to (t) (a)) 
;;@                           (conv_to (t) (zero_ext (regwidth) 
;;@                             (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv))) (b)))))))
;;@           ))
;;@   )
;;@   (assert
;;@           (|| (= (op) (0i64:bv)) (|| (= (op) (1i64:bv)) (= (op) (2i64:bv)))),
;;@           (= (t) (widthof (b))),
;;@           (|| (= (t) (8i8: int))
;;@           (|| (= (t) (16i8: int))
;;@           (|| (= (t) (32i8: int))
;;@               (= (t) (64i8: int))))),
;;@           (switch (op) 
;;@                  ((0i64:bv) (true))
;;@                  ((1i64:bv) (switch (t) 
;;@                               ((8i32: int) (= (extract 31 0 (a)) (zero_ext (32) (extract 7 0 (a)))))
;;@                               ((16i32: int) (= (extract 31 0 (a)) (zero_ext (32) (extract 15 0 (a)))))
;;@                               ((32i32: int) (true))
;;@                               ((64i32: int) (true))))
;;@                  ((2i64:bv) (switch (t) 
;;@                               ((8i32: int) (= (extract 31 0 (a)) (sign_ext (32) (extract 7 0 (a)))))
;;@                               ((16i32: int) (= (extract 31 0 (a)) (sign_ext (32) (extract 15 0 (a)))))
;;@                               ((32i32: int) (true))
;;@                               ((64i32: int) (true))))
;;@           )
;;@     ))
(decl do_shift (ALUOp Type Reg Value) Reg)
(extern constructor do_shift do_shift)

;; Place a `Value` into a register, zero extending it to 32-bits
;;@ (spec (sig (args arg) (ret))
;;@     (assume  (
;;@          if (<= (32i0:int) (widthof (arg))) 
;;@             (= (ret) (conv_to (regwidth) (arg)))             
;;@             (= (ret) (conv_to (regwidth) (zero_ext (32) (arg))))
;;@          )
;;@ ))
(decl put_in_reg_zext32 (Value) Reg)
(extern constructor put_in_reg_zext32 put_in_reg_zext32)

;; BROKEN: wrong op
;; Shift for i8/i16/i32.
(rule -1 (lower (has_type (fits_in_32 ty) (ushr x y)))
      (do_shift (ALUOp.Lsl) ty (put_in_reg_zext32 x) y))
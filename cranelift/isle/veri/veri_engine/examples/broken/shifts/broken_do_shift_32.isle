;; Instruction formats.
(type MInst
  (enum
))

;;@ (spec (sig (args) (ret))
;;@       (provide  (= (16i8:bv) (ret))))
;;decl ALUOp.Lsr

;;@ (spec (sig (args) (ret))
;;@       (provide  (= (17i8:bv) (ret))))
;;decl ALUOp.Asr

;;@ (spec (sig (args) (ret))
;;@       (provide  (= (18i8:bv) (ret))))
;;decl ALUOp.Lsl

;; An ALU operation. This can be paired with several instruction formats
;; below (see `Inst`) in any combination.
(type ALUOp
  (enum
    (Add)
    (Sub)
    (Orr)
    (OrrNot)
    (And)
    (AndS)
    (AndNot)
    ;; XOR (AArch64 calls this "EOR")
    (Eor)
    ;; XNOR (AArch64 calls this "EOR-NOT")
    (EorNot)
    ;; Add, setting flags
    (AddS)
    ;; Sub, setting flags
    (SubS)
    ;; Signed multiply, high-word result
    (SMulH)
    ;; Unsigned multiply, high-word result
    (UMulH)
    (SDiv)
    (UDiv)
    (RotR)
    (Lsr)
    (Asr)
    (Lsl)
    ;; Add with carry
    (Adc)
    ;; Add with carry, settings flags
    (AdcS)
    ;; Subtract with carry
    (Sbc)
    ;; Subtract with carry, settings flags
    (SbcS)
))

;; BROKEN: no restriction on op in annotation
;;@ (spec (sig (args op, t, a, b) (ret))
;;@   (provide  
;;@     (= (ret) 
;;@        (switch (op) 
;;@          ((16i8:bv8) (conv_to (regwidth) 
;;@            (shr (conv_to (t) (a)) 
;;@                 (conv_to (t) (zero_ext (regwidth) 
;;@                   (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv))) (b)))))))
;;@          ((17i8:bv8) (conv_to (regwidth) 
;;@            (ashr (conv_to (t) (a)) 
;;@                  (conv_to (t) (zero_ext (regwidth) 
;;@                    (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv))) (b)))))))
;;@          ((18i8:bv8) (conv_to (regwidth) 
;;@            (shl (conv_to (t) (a)) 
;;@                 (conv_to (t) (zero_ext (regwidth) 
;;@                   (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv64))) (b)))))))
;;@           ))
;;@   )
;;@   (require
;;@     (= (t) (widthof (b))),
;;@     (|| (= (t) (8i8: Int))
;;@     (|| (= (t) (16i8: Int))
;;@     (|| (= (t) (32i8: Int))
;;@     (= (t) (64i8: Int))))),
;;@ ))
(decl do_shift (ALUOp Type Reg Value) Reg)

;;@ (spec (sig (args op, t, a, b) (ret))
;;@     (provide  
;;@       (= (ret) (switch (op)
;;@               ((16i8:bv8)
;;@                 (if (<= (t) (32i8: Int)) 
;;@                     (conv_to (64) (shr (extract 31 0 (a)) (& (- (int2bv 32 (32i32:Int)) (1i32:bv)) (extract 31 0 (b)))))
;;@                     (shr (a) (& (- (int2bv 64 (64i64:Int)) (1i64:bv)) (b))))
;;@               )
;;@               ((17i8:bv8) 
;;@                 (if (<= (t) (32i8: Int)) 
;;@                     (conv_to (64) (ashr (extract 31 0 (a)) (& (- (int2bv 32 (32i32:Int)) (1i32:bv)) (extract 31 0 (b)))))
;;@                     (ashr (a) (& (- (int2bv 64 (64i64:Int)) (1i64:bv)) (b))))
;;@               )
;;@               ((18i8:bv8)
;;@                 (if (<= (t) (32i8: Int)) 
;;@                     (conv_to (64) (shl (extract 31 0 (a)) (& (- (int2bv 32 (32i32:Int)) (1i32:bv)) (extract 31 0 (b)))))
;;@                     (shl (a) (& (- (int2bv 64 (64i64:Int)) (1i64:bv)) (b))))
;;@               )
;;@       )))
;;@    (require
;;@       (|| (= (op) (16i8:bv8)) (|| (= (op) (17i8:bv8)) (= (op) (18i8:bv8)))),
;;@       (|| (= (t) (8i8: Int))
;;@       (|| (= (t) (16i8: Int))
;;@       (|| (= (t) (32i8: Int))
;;@           (= (t) (64i8: Int)))))
;;@     ))
(decl alu_rrr (ALUOp Type Reg Reg) Reg)
(extern constructor alu_rrr alu_rrr)

(rule (do_shift op $I32 x y) (alu_rrr op $I32 x (value_regs_get y 0)))

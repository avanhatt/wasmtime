(type Reg (primitive Reg))
(type Value (primitive Value))
(type Type (primitive Type))
(type Inst (primitive Inst))
(type Unit (primitive Unit))
(type MemFlags (primitive MemFlags))
(type Gpr (primitive Gpr))
(type GprMemImm extern (enum))
(type Imm64 (primitive Imm64))
(type u32 (primitive u32))
(type u8 (primitive u8))

(extern const $I64 Type)

(type ExtendKind (enum Sign Zero))

;; (extern extractor put_in_gpr put_in_gpr)
;; (extern constructor put_in_gpr put_in_gpr)
;; (convert Value Gpr put_in_gpr)

;;@ (spec (sig (args arg) (ret))
 ;;@     (assume  (= (zero_ext (widthof (arg)) (ret)) (arg))))
(decl iconst (Imm64) Inst)
(extern extractor iconst iconst)

;; fn uimm8(&mut self, x: Imm64) -> Option<u8> {
;;     let x64: i64 = x.into();
;;     let x8: u8 = x64.try_into().ok()?;
;;     Some(x8)
;; }

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (< (ret) (256i64:bv)),
;;@                 (= (ret) (zero_ext (regwidth) (arg)))
;;@ ))
(decl uimm8 (u8) Imm64)
(extern extractor uimm8 uimm8)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  
;;@       (= (ret) (zero_ext (widthof (ret)) (arg))),
;;@       (= (widthof (arg)) (8i8:isleType)),
;;@       (= (widthof (ret)) (32i8:isleType)),
;;@ ))
(decl pure u8_as_u32 (u8) u32)
(extern constructor u8_as_u32 u8_as_u32)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (arg) (ret))))
(decl def_inst (Inst) Value)
(extern extractor def_inst def_inst)
(convert Inst Value def_inst)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (conv_to (regwidth) (arg)) (ret))))
(decl put_in_reg (Value) Reg)
(extern constructor put_in_reg put_in_reg)
(convert Value Reg put_in_reg)


;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (arg) (ret))))
(decl gpr_to_reg (Gpr) Reg)
(extern constructor gpr_to_reg gpr_to_reg)
(convert Gpr Reg gpr_to_reg)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (arg) (ret))))
(decl gpr_new (Reg) Gpr)
(extern constructor gpr_new gpr_new)
(convert Reg Gpr gpr_new)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (conv_to (regwidth) (arg)) (ret))))
(decl put_in_gpr (Value) Gpr)
(rule (put_in_gpr val)
      (gpr_new (put_in_reg val)))
(convert Value Gpr put_in_gpr)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (zero_ext (regwidth) (arg)) (ret))))
(decl put_in_gpr_mem_imm (Value) GprMemImm)
(convert Value GprMemImm put_in_gpr_mem_imm)
(extern extractor put_in_gpr_mem_imm put_in_gpr_mem_imm)
(extern constructor put_in_gpr_mem_imm put_in_gpr_mem_imm)

(decl reg_to_gpr_mem_imm (Reg) GprMemImm)
(convert Reg GprMemImm reg_to_gpr_mem_imm)
(extern extractor reg_to_gpr_mem_imm reg_to_gpr_mem_imm)
(extern constructor reg_to_gpr_mem_imm reg_to_gpr_mem_imm)

;;@ (spec (sig (args a, b) (ret))
;;@     (assume  (<= (bv2int (b)) (widthof (a))),
;;@                 (= (ret) (shl (a) (b)))))
(decl ishl (Value Value) Inst)
(extern extractor ishl ishl)

;; movl (%base, %local0, 8), %dst which calculates %base + %local0 << 3

;; Sign-extend-32-to-64(simm32) + base + (index << shift)
;;@ (spec (sig (args simm, base, index, shift, flags) (ret))
;;@       (assume  (= (widthof (simm)) (32i8:isleType)) ,
;;@                   (= (widthof (base)) (64i8:isleType)) ,
;;@                   (= (ret) (+ (+ (base) (sign_ext (64i8:isleType) (simm)))
;;@                               (shl (index) (zero_ext (regwidth) (shift))))) , 
;;@                   (= (flags) (flags)) ))
;;decl Amode.ImmRegRegShift

;; An `Amode` represents a possible addressing mode that can be used
;; in instructions. These denote a 64-bit value only.
(type Amode (enum
             ;; Immediate sign-extended and a register
             (ImmReg (simm32 u32)
                     (base Reg)
                     (flags MemFlags))
                     
             ;; Sign-extend-32-to-64(simm32) + base + (index << shift)
             (ImmRegRegShift (simm32 u32)
                             (base Gpr)
                             (index Gpr)
                             (shift u8)
                             (flags MemFlags))
            )
)

;;@ (spec (sig (args x, y) (ret))
;;@       (assume  (= (+ (x) (zero_ext (regwidth) (y))) (ret))))
(decl amode_add (Amode Value) Amode)
(extern extractor amode_add amode_add)

;;@ (spec (sig (args arg) (ret))
;;@     (assume  (= (arg) (ret))
;;@ ))
(decl valid_reg (Reg) Reg)
(extern extractor valid_reg valid_reg)

;;@ (spec (sig (args a, b) (ret))
;;@     (assume  (<= (a) (b)),
;;@                 (= (widthof (a)) (32i8:isleType)),  
;;@                 (= (widthof (b)) (32i8:isleType)),  
;;@ ))
(decl pure u32_lteq (u32 u32) Unit)
(extern constructor u32_lteq u32_lteq)

;;@ (spec (sig (args) (ret))
;;@       (assume  (= (0i64:bv) (ret))))
;;decl ExtendKind.Zero

;;@ (spec (sig (args) (ret))
;;@       (assume  (= (1i64:bv) (ret))))
;;decl ExtendKind.Sign

;;@ (spec (sig (args v, ty, ext) (ret))
;;@     (assume  (= (ret) (if (= (ext) (0i64:bv))
;;@                          { (zero_ext (ty) (v)) } 
;;@                          else { (sign_ext (ty) (v)) }))))
(decl extend_to_gpr (Value Type ExtendKind) Gpr)
(extern constructor extend_to_gpr extend_to_gpr)

;;@ (spec (sig (args ty, x, y) (ret))
;;@       (assume  (= (+ (x) (y)) (ret))))
(decl x64_add (Type Gpr GprMemImm) Gpr)
(extern constructor x64_add x64_add)


;; -- Case 5 (fallback to add a new value to an imm+reg+scale*reg).
;;
;; An Amode.ImmRegRegShift can absorb any other value by creating a
;; new add instruction and replacing the base with
;; (base+value).
(rule (amode_add (Amode.ImmRegRegShift off base index shift flags) value)
      (let ((sum Gpr (x64_add $I64 base value)))
        (Amode.ImmRegRegShift off sum index shift flags)))
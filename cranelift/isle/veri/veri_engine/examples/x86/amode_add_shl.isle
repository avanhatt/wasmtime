(type Reg (primitive Reg))
(type Value (primitive Value))
(type Type (primitive Type))
(type Inst (primitive Inst))
(type Unit (primitive Unit))
(type MemFlags (primitive MemFlags))
(type Gpr (primitive Gpr))
(type Imm64 (primitive Imm64))
(type u32 (primitive u32))
(type u8 (primitive u8))

(type MInst
  (enum
))

(extern const $I64 Type)

(type ExtendKind (enum Sign Zero))

;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (arg) (zero_ext (64) (ret)))))
(decl iconst (Imm64) Inst)
(extern extractor iconst iconst)

;; fn uimm8(&mut self, x: Imm64) -> Option<u8> {
;;     let x64: i64 = x.into();
;;     let x8: u8 = x64.try_into().ok()?;
;;     Some(x8)
;; }

;;@ (spec (sig (args arg) (ret))
;;@     (provide (< (ret) (256i64:bv)),
;;@                 (= (ret) (zero_ext (64i64:Int) (arg))),
;;@                 (= (widthof (arg)) (8i64:Int))
;;@ ))
(decl uimm8 (u8) Imm64)
(extern extractor uimm8 uimm8)

;;@ (spec (sig (args arg) (ret))
;;@     (provide 
;;@       (= (ret) (zero_ext (widthof (ret)) (arg))),
;;@       (= (widthof (arg)) (8i8:Int)),
;;@       (= (widthof (ret)) (32i8:Int)),
;;@ ))
(decl pure u8_as_u32 (u8) u32)
(extern constructor u8_as_u32 u8_as_u32)

;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (arg) (ret))))
(decl def_inst (Inst) Value)
(extern extractor def_inst def_inst)
(convert Inst Value def_inst)

;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (conv_to (regwidth) (arg)) (ret))))
(decl put_in_reg (Value) Reg)
(extern constructor put_in_reg put_in_reg)
(convert Value Reg put_in_reg)

;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (arg) (ret))))
(decl gpr_to_reg (Gpr) Reg)
(extern constructor gpr_to_reg gpr_to_reg)
(convert Gpr Reg gpr_to_reg)

;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (arg) (ret))))
(decl gpr_new (Reg) Gpr)
(extern constructor gpr_new gpr_new)
(convert Reg Gpr gpr_new)

;; To make this case study specific to Wasm, contrain to 32 or 64
;;@ (spec (sig (args arg) (ret))
;;@   (provide (= (ret) (zero_ext (widthof (ret)) (arg))))
;;@   (require 
;;@     (|| (= (widthof (ret)) (32i8:Int))
;;@     (= (widthof (ret)) (64i8:Int))),
;;@     (|| (= (widthof (arg)) (32i8:Int))
;;@     (= (widthof (arg)) (64i8:Int))),
;;@     (<= (widthof (arg)) (widthof (ret))) )
;;@ )
(decl uextend (Value) Inst)
(extern extractor uextend uextend)

;;@ (spec (sig (args a, b) (ret))
;;@     (provide (= (ret) (shl (a) (& (conv_to (widthof (b)) (- (int2bv 64 (widthof (b))) (1i64:bv))) (b))))))
(decl ishl (Value Value) Inst)
(extern extractor ishl ishl)

;; NOTE: partial spec: ignoring the `flags` argument for now
;; NOTE: to get an easier counterexample, set base to 0
;; Immediate sign-extended and a register
;;@ (spec (sig (args simm, base, flags) (ret))
;;@       (provide 
;;@         (= (widthof (simm)) (32i8:Int)) ,
;;@         (= (widthof (base)) (64i8:Int)) ,
;;@         (= (base) (0i64:bv)) ,
;;@         (= (widthof (flags)) (4i64:Int)) ,
;;@         (= (ret) (+ (base) (sign_ext (64i8:Int) (simm)))) , 
;;@ ))
;;decl Amode.ImmReg

;; NOTE: partial spec: ignoring the `flags` argument for now
;; Sign-extend-32-to-64(simm32) + base + (index << shift)
;;@ (spec (sig (args simm, base, index, shift, flags) (ret))
;;@       (provide (= (widthof (simm)) (32i8:Int)) ,
;;@                   (= (widthof (base)) (64i8:Int)) ,
;;@                   (= (ret) (+ (+ (base) (sign_ext (64i8:Int) (simm)))
;;@                               (shl (index) (zero_ext (regwidth) (shift))))) , 
;;@                   (= (flags) (flags)) ))
;;decl Amode.ImmRegRegShift

;; An `Amode` represents a possible addressing mode that can be used
;; in instructions. These denote a 64-bit value only.
(type Amode (enum
             ;; Immediate sign-extended and a register
             (ImmReg (simm32 u32)
                     (base Reg)
                     (flags MemFlags))
                     
             ;; Sign-extend-32-to-64(simm32) + base + (index << shift)
             (ImmRegRegShift (simm32 u32)
                             (base Gpr)
                             (index Gpr)
                             (shift u8)
                             (flags MemFlags))
            )
)

;;@ (spec (sig (args x, y) (ret))
;;@       (provide (= (+ (x) (zero_ext (64i8:Int) (y))) (ret))))
(decl amode_add (Amode Value) Amode)
(extern extractor amode_add amode_add)

;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (arg) (ret))
;;@ ))
(decl valid_reg (Reg) Reg)
(extern extractor valid_reg valid_reg)


;;@ (spec (sig (args a, b) (ret))
;;@     (provide (<= (a) (b)), 
;;@              (= (widthof (ret)) (1i8:Int)))
;;@     (require (= (widthof (a)) (32i8:Int)),
;;@              (= (widthof (b)) (32i8:Int)) 
;;@ ))
(decl pure u32_lteq (u32 u32) Unit)
(extern constructor u32_lteq u32_lteq)

;;@ (spec (sig (args) (ret))
;;@       (provide (= (0i64:bv) (ret))))
;;decl ExtendKind.Zero

;;@ (spec (sig (args) (ret))
;;@       (provide (= (1i64:bv) (ret))))
;;decl ExtendKind.Sign

;;@ (spec (sig (args v, ty, ext) (ret))
;;@     (provide (= (ret) (if (= (ext) (0i64:bv))
;;@                          (zero_ext (ty) (v))
;;@                          (sign_ext (ty) (v))))))
(decl extend_to_gpr (Value Type ExtendKind) Gpr)
(extern constructor extend_to_gpr extend_to_gpr)

(convert Value Gpr put_in_gpr)
;;@ (spec (sig (args arg) (ret))
;;@     (provide (= (conv_to (regwidth) (arg)) (ret))))
(decl put_in_gpr (Value) Gpr)
(extern constructor put_in_gpr put_in_gpr)

(rule 2 (amode_add (Amode.ImmReg off (valid_reg base) flags) (ishl index (iconst (uimm8 shift))))
       (if (u32_lteq (u8_as_u32 shift) 3))
       (Amode.ImmRegRegShift off base index shift flags))
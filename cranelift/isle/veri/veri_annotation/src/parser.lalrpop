use std::str::FromStr;

use veri_ir as ast;
use ast::*;

// DO NOT FORGET TO CHANGE THE EXTENSION!!!

grammar;

UNum: usize = <s:r"[0-9]+">  => usize::from_str(s).unwrap();
Num: i128 = <s:r"-?[0-9]+i">  => i128::from_str(&s[..s.len() - 1]).unwrap();

// Exclude "bv" to avoid confusion with type bv
Ident: String = {
    <s:r"[A-Za-z]"> => s.to_string(),
    <s:r"[A-Zac-z]\w+"> => s.to_string(),
    <s:r"b[\w&&[^v]]\w*"> => s.to_string(),
};

pub VIRType: VIRType = {
    // TODO: support bvX instead of only numbers
    "bv" <n:UNum> => VIRType::BitVector(n),
    "bvlist" "(" <length:UNum> "," <width:UNum> ")" => 
        VIRType::BitVectorList(length, width), 
    "func" "(" <t1:TypeList> ")" <t2:VIRType> =>
        VIRType::Function(t1, Box::new(t2)),
    "bool" => VIRType::Bool,
    "IsleType" => VIRType::IsleType,
};

pub BoundVar: BoundVar = {
    <i:Ident> ":" <t:VIRType> => BoundVar{name: i, ty: t},
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ArgList = Comma<BoundVar>;
Args: Vec<BoundVar> = {
    "(args" <a:ArgList> ")" => a,
};

TypeList = Comma<VIRType>;

pub FunctionAnnotation: FunctionAnnotation = {
    "(sig" <a:Args> "(" <r:BoundVar> ")" ")" => 
        FunctionAnnotation {args: a, ret: r},
};

pub Function: Function = {
    "(func" <n:Ident> "(" <a:ArgList> ")" "(" <t:VIRType> ")" ")" =>
        Function{name: n, ty: t, args: a},
};

pub VIRExpr: Box<VIRExpr> = {
    "(" <b:BoundVar> ")" => Box::new(VIRExpr::Var(b)), 
    <n:Num> <m:UNum> => 
        Box::new(VIRExpr::Const(VIRType::BitVector(m), n)),
    "(" "True" ")" => Box::new(VIRExpr::True),
    "(" "False" ")" => Box::new(VIRExpr::False),

    "(" "!" <u:VIRExpr> ")" => Box::new(VIRExpr::Not(u)),
    "(" "&&" <u:VIRExpr> <v:VIRExpr> ")" => Box::new(VIRExpr::And(u, v)),
    "(" "||" <u:VIRExpr> <v:VIRExpr> ")" => Box::new(VIRExpr::Or(u, v)),
    "(" "=>" <u:VIRExpr> <v:VIRExpr> ")" => Box::new(VIRExpr::Imp(u, v)),
    "(" "=" <u:VIRExpr> <v:VIRExpr> ")" => Box::new(VIRExpr::Eq(u, v)),
    "(" "<=" <u:VIRExpr> <v:VIRExpr> ")" => Box::new(VIRExpr::Lte(u, v)),

    //TODO: bv exprs
};

// TODO: Do we need to enforce that these types must be bvX?
//pub BVExpr: Box<BVExpr> = {
//     "(" <n:Num> ":" <t:VIRType> ")" => Box::new(BVExpr::Const(t, n)),
//     "(" "~" <b:BVExpr> ")" => Box::new(BVExpr::BVNeg(
//};

// TODO: assertion, assertion list
// TODO: watch out for precedence issues

//pub VIRAnnotation: VIRAnnotation = {
//    "(spec" <f:FunctionAnnotation> <a:AssertionList> ")" =>
//        VIRAnnotation {func: f, assertions: a},
//};

inline term: lower
expansions = 741
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 97
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_high, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		12: bool	const_prim(true)
		15: Option(InstOutput)	some(27)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecExtend, [11, 21, 8, 12, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 92
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_high, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		12: bool	const_prim(true)
		15: Option(InstOutput)	some(27)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecExtend, [11, 21, 8, 12, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 87
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Uimm8))	extractor(extract_vector, 0)
		4: (Value, Uimm8)	match_some(3)
		5: Uimm8	match_tuple(4, 1)
		6: Value	match_tuple(4, 0)
		7: Reg	constructor(put_in_reg, [6], 1)
		8: ValueRegs	constructor(value_reg, [7], 2)
		9: InstOutput	constructor(output, [8], 3)
		10: Option(InstOutput)	some(9)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 81
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(DynamicStackSlot)	extractor(dynamic_stack_addr, 0)
		4: Type	const_prim(I64)
		5: WritableReg	constructor(temp_writable_reg, [4], 1)
		6: DynamicStackSlot	match_some(3)
		7: MInst	constructor(abi_dynamic_stackslot_addr, [5, 6], 2)
		8: Unit	constructor(emit, [7], 3)
		9: Reg	constructor(writable_reg_to_reg, [5], 0)
		10: ValueRegs	constructor(value_reg, [9], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 75
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/isa/aarch64/inst.isle line 2569
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		31: ValueRegs	constructor(value_reg, [49], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRNarrowLow, [23, 37, 11, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecRRNarrowHigh, [28, 46, 40, 16, 17])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 71
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2565
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(39)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecMovElement, [29, 11, 13, 14, 15, 16])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		35: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::VecRRNarrowLow, [35, 44, 32, 19])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 67
		../../codegen/src/isa/aarch64/inst.isle line 2565
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		24: ValueRegs	constructor(value_reg, [33], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRNarrowLow, [21, 30, 13, 15])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 61
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/isa/aarch64/inst.isle line 2561
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		31: ValueRegs	constructor(value_reg, [49], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRNarrowLow, [23, 37, 11, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecRRNarrowHigh, [28, 46, 40, 16, 17])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 57
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2557
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(39)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecMovElement, [29, 11, 13, 14, 15, 16])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		35: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::VecRRNarrowLow, [35, 44, 32, 19])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 53
		../../codegen/src/isa/aarch64/inst.isle line 2557
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		24: ValueRegs	constructor(value_reg, [33], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRNarrowLow, [21, 30, 13, 15])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/isa/aarch64/inst.isle line 2553
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		31: ValueRegs	constructor(value_reg, [49], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRNarrowLow, [23, 37, 11, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecRRNarrowHigh, [28, 46, 40, 16, 17])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 43
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2549
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(39)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecMovElement, [29, 11, 13, 14, 15, 16])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		35: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::VecRRNarrowLow, [35, 44, 32, 19])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 39
		../../codegen/src/isa/aarch64/inst.isle line 2549
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		24: ValueRegs	constructor(value_reg, [33], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRNarrowLow, [21, 30, 13, 15])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 35
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmax, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmax, [])
		17: ValueRegs	constructor(value_reg, [28], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 31
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmin, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmin, [])
		17: ValueRegs	constructor(value_reg, [28], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 27
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fdiv, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		17: ValueRegs	constructor(value_reg, [28], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 23
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmul, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmul, [])
		17: ValueRegs	constructor(value_reg, [28], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 19
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fsub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fsub, [])
		17: ValueRegs	constructor(value_reg, [28], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 15
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fadd, [])
		17: ValueRegs	constructor(value_reg, [28], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 11
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option((u32, u32))	extractor(dynamic_lane, 9)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [9], 3)
		17: VecALUOp	make_variant(VecALUOp::Mul, [])
		19: ValueRegs	constructor(value_reg, [30], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecRRR, [17, 27, 13, 15, 16])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 7
		../../codegen/src/isa/aarch64/inst.isle line 2457
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [32], 5)
		17: InstOutput	constructor(output, [16], 6)
		18: Option(InstOutput)	some(17)
		22: VecALUOp	make_variant(VecALUOp::Sub, [])
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [22, 29, 11, 13, 14])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 3
		../../codegen/src/isa/aarch64/inst.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [32], 5)
		17: InstOutput	constructor(output, [16], 6)
		18: Option(InstOutput)	some(17)
		22: VecALUOp	make_variant(VecALUOp::Add, [])
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [22, 29, 11, 13, 14])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2882
		../../codegen/src/isa/aarch64/inst.isle line 2216
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvpromote_low, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: VecRRLongOp	make_variant(VecRRLongOp::Fcvtl32, [])
		7: bool	const_prim(false)
		10: Option(InstOutput)	some(21)
		14: Type	const_prim(I8X16)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: MInst	make_variant(MInst::VecRRLong, [6, 15, 5, 7])
		17: Unit	constructor(emit, [16], 2)
		18: Reg	constructor(writable_reg_to_reg, [15], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2877
		../../codegen/src/isa/aarch64/inst.isle line 3815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		15: Option(InstOutput)	some(24)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::MachOTlsGetAddr, [12, 18])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::Macho)
		8:	some
		10:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2874
		../../codegen/src/isa/aarch64/inst.isle line 3808
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		15: Option(InstOutput)	some(26)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: WritableReg	constructor(temp_writable_reg, [17], 2)
		20: BoxExternalName	constructor(box_external_name, [12], 3)
		21: MInst	make_variant(MInst::ElfTlsGetAddr, [20, 18, 19])
		22: Unit	constructor(emit, [21], 4)
		23: Reg	constructor(writable_reg_to_reg, [18], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::ElfGd)
		8:	some
		10:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2861
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2517
		../../codegen/src/isa/aarch64/inst.isle line 2020
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I64)
		16: Reg	constructor(put_in_reg, [9], 5)
		17: Reg	constructor(put_in_reg, [11], 6)
		19: OperandSize	make_variant(OperandSize::Size64, [])
		20: u64	const_int(63, u64)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [72], 11)
		26: ValueRegs	constructor(value_reg, [61], 12)
		27: InstOutput	constructor(output_pair, [25, 26], 13)
		28: Option(InstOutput)	some(27)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::SMulH, [])
		44: Type	const_prim(I64)
		45: Option(ShiftOpAndAmt)	constructor(ashr_from_u64, [44, 20], 0)
		46: WritableReg	constructor(writable_zero_reg, [], 1)
		47: ALUOp	make_variant(ALUOp::SubS, [])
		48: ShiftOpAndAmt	match_some(45)
		49: MInst	make_variant(MInst::AluRRRShift, [47, 19, 46, 82, 72, 48])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: MInst	make_variant(MInst::CSet, [53, 22])
		55: Reg	constructor(writable_reg_to_reg, [53], 0)
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 55])
		59: ValueRegs	constructor(with_flags, [50, 56], 1)
		60: usize	const_int(0, usize)
		61: Reg	constructor(value_regs_get, [59, 60], 2)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: OperandSize	constructor(operand_size, [14], 2)
		70: MInst	make_variant(MInst::AluRRRR, [33, 69, 68, 10, 12, 13])
		71: Unit	constructor(emit, [70], 3)
		72: Reg	constructor(writable_reg_to_reg, [68], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [14], 2)
		80: MInst	make_variant(MInst::AluRRR, [38, 79, 78, 16, 17])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		45:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2847
		../../codegen/src/isa/aarch64/inst.isle line 2493
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: ExtendOp	make_variant(ExtendOp::SXTW, [])
		18: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(value_reg, [60], 8)
		22: ValueRegs	constructor(value_reg, [49], 9)
		23: InstOutput	constructor(output_pair, [21, 22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp3	make_variant(ALUOp3::SMAddL, [])
		29: Type	const_prim(I32)
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: ALUOp	make_variant(ALUOp::SubS, [])
		37: MInst	make_variant(MInst::AluRRRExtend, [36, 15, 35, 60, 60, 16])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::CSet, [41, 18])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 43])
		47: ValueRegs	constructor(with_flags, [38, 44], 1)
		48: usize	const_int(0, usize)
		49: Reg	constructor(value_regs_get, [47, 48], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [29], 2)
		58: MInst	make_variant(MInst::AluRRRR, [28, 57, 56, 10, 12, 13])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I64)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I32)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [15], 1)
		35: bool	const_prim(true)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 34, 35, 37, 38])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 30, 73, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		33:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I64)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I32)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [15], 1)
		35: bool	const_prim(true)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 34, 35, 37, 38])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 30, 73, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		33:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [13], 1)
		32: bool	const_prim(true)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 15)
		39: Reg	constructor(put_in_reg, [15], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 31, 32, 34, 35])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 73, 39, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I64)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [13], 1)
		32: bool	const_prim(true)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 15)
		39: Reg	constructor(put_in_reg, [15], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 31, 32, 34, 35])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 73, 39, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I32)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [99], 9)
		25: ValueRegs	constructor(value_reg, [70], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [13], 1)
		32: bool	const_prim(true)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 15)
		39: Option(Type)	extractor(fits_in_32, 38)
		40: Reg	constructor(put_in_reg, [15], 1)
		41: bool	const_prim(true)
		42: Type	match_some(39)
		43: u8	constructor(ty_bits, [42], 0)
		44: u8	const_int(32, u8)
		50: ALUOp3	make_variant(ALUOp3::MAdd, [])
		56: WritableReg	constructor(writable_zero_reg, [], 1)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: MInst	make_variant(MInst::AluRRRExtend, [57, 19, 56, 99, 99, 11])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::CSet, [62, 21])
		64: Reg	constructor(writable_reg_to_reg, [62], 0)
		65: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [63, 64])
		68: ValueRegs	constructor(with_flags, [59, 65], 1)
		69: usize	const_int(0, usize)
		70: Reg	constructor(value_regs_get, [68, 69], 2)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::Extend, [76, 31, 32, 34, 35])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::Extend, [85, 40, 41, 43, 44])
		87: Unit	constructor(emit, [86], 2)
		88: Reg	constructor(writable_reg_to_reg, [85], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: OperandSize	constructor(operand_size, [9], 2)
		97: MInst	make_variant(MInst::AluRRRR, [50, 96, 95, 79, 88, 17])
		98: Unit	constructor(emit, [97], 3)
		99: Reg	constructor(writable_reg_to_reg, [95], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		39:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2813
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2513
		../../codegen/src/isa/aarch64/inst.isle line 2123
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2117
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I64)
		16: Reg	constructor(put_in_reg, [9], 5)
		17: Reg	constructor(put_in_reg, [11], 6)
		19: u8	const_int(0, u8)
		20: Imm12	constructor(u8_into_imm12, [19], 8)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [65], 12)
		26: ValueRegs	constructor(value_reg, [54], 13)
		27: InstOutput	constructor(output_pair, [25, 26], 14)
		28: Option(InstOutput)	some(27)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::UMulH, [])
		42: OperandSize	make_variant(OperandSize::Size64, [])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 22])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [82, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [14], 2)
		63: MInst	make_variant(MInst::AluRRRR, [33, 62, 61, 10, 12, 13])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: OperandSize	constructor(operand_size, [14], 2)
		73: MInst	make_variant(MInst::AluRRR, [38, 72, 71, 16, 17])
		74: Unit	constructor(emit, [73], 3)
		75: Reg	constructor(writable_reg_to_reg, [71], 0)
		79: WritableReg	constructor(writable_zero_reg, [], 1)
		80: ALUOp	make_variant(ALUOp::SubS, [])
		81: MInst	make_variant(MInst::AluRRImm12, [80, 42, 79, 75, 20])
		82: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [81])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2799
		../../codegen/src/isa/aarch64/inst.isle line 2489
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: ExtendOp	make_variant(ExtendOp::UXTW, [])
		18: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(value_reg, [60], 8)
		22: ValueRegs	constructor(value_reg, [49], 9)
		23: InstOutput	constructor(output_pair, [21, 22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp3	make_variant(ALUOp3::UMAddL, [])
		29: Type	const_prim(I32)
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: ALUOp	make_variant(ALUOp::SubS, [])
		37: MInst	make_variant(MInst::AluRRRExtend, [36, 15, 35, 60, 60, 16])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::CSet, [41, 18])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 43])
		47: ValueRegs	constructor(with_flags, [38, 44], 1)
		48: usize	const_int(0, usize)
		49: Reg	constructor(value_regs_get, [47, 48], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [29], 2)
		58: MInst	make_variant(MInst::AluRRRR, [28, 57, 56, 10, 12, 13])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I64)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I32)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [15], 1)
		35: bool	const_prim(false)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 34, 35, 37, 38])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 30, 73, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		33:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I64)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [69], 9)
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Reg	constructor(put_in_reg, [15], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRRExtend, [45, 19, 44, 69, 69, 11])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 21])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [9], 2)
		67: MInst	make_variant(MInst::AluRRRR, [38, 66, 65, 30, 33, 17])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I32)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Reg	constructor(put_in_reg, [13], 1)
		32: Type	extractor(value_type, 15)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [15], 1)
		35: bool	const_prim(false)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 34, 35, 37, 38])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 30, 73, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		33:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [13], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 15)
		39: Reg	constructor(put_in_reg, [15], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 31, 32, 34, 35])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 73, 39, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I64)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [84], 9)
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [13], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 15)
		39: Reg	constructor(put_in_reg, [15], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 19, 50, 84, 84, 11])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 21])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: MInst	make_variant(MInst::Extend, [70, 31, 32, 34, 35])
		72: Unit	constructor(emit, [71], 2)
		73: Reg	constructor(writable_reg_to_reg, [70], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: OperandSize	constructor(operand_size, [9], 2)
		82: MInst	make_variant(MInst::AluRRRR, [44, 81, 80, 73, 39, 17])
		83: Unit	constructor(emit, [82], 3)
		84: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I32)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		15: Value	match_tuple(12, 1)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [99], 9)
		25: ValueRegs	constructor(value_reg, [70], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 13)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [13], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 15)
		39: Option(Type)	extractor(fits_in_32, 38)
		40: Reg	constructor(put_in_reg, [15], 1)
		41: bool	const_prim(false)
		42: Type	match_some(39)
		43: u8	constructor(ty_bits, [42], 0)
		44: u8	const_int(32, u8)
		50: ALUOp3	make_variant(ALUOp3::MAdd, [])
		56: WritableReg	constructor(writable_zero_reg, [], 1)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: MInst	make_variant(MInst::AluRRRExtend, [57, 19, 56, 99, 99, 11])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::CSet, [62, 21])
		64: Reg	constructor(writable_reg_to_reg, [62], 0)
		65: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [63, 64])
		68: ValueRegs	constructor(with_flags, [59, 65], 1)
		69: usize	const_int(0, usize)
		70: Reg	constructor(value_regs_get, [68, 69], 2)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::Extend, [76, 31, 32, 34, 35])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::Extend, [85, 40, 41, 43, 44])
		87: Unit	constructor(emit, [86], 2)
		88: Reg	constructor(writable_reg_to_reg, [85], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: OperandSize	constructor(operand_size, [9], 2)
		97: MInst	make_variant(MInst::AluRRRR, [50, 96, 95, 79, 88, 17])
		98: Unit	constructor(emit, [97], 3)
		99: Reg	constructor(writable_reg_to_reg, [95], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		39:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2773
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [10], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		29: Type	const_prim(I64)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [29], 2)
		42: MInst	make_variant(MInst::AluRRR, [11, 41, 40, 23, 27])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [29], 2)
		52: MInst	make_variant(MInst::AluRRR, [12, 51, 50, 25, 28])
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2767
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [9], 2)
		41: MInst	make_variant(MInst::AluRRR, [13, 40, 39, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2762
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2632
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2965
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		68:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2762
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2632
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2964
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		68:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2762
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2632
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 84, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Option(Type)	extractor(fits_in_32, 68)
		70: Reg	constructor(put_in_reg, [11], 1)
		71: bool	const_prim(true)
		72: Type	match_some(69)
		73: u8	constructor(ty_bits, [72], 0)
		74: u8	const_int(32, u8)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: MInst	make_variant(MInst::Extend, [81, 70, 71, 73, 74])
		83: Unit	constructor(emit, [82], 2)
		84: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		69:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2753
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		15: Option(InstOutput)	some(67)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [10], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		29: Type	const_prim(I64)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [29], 2)
		42: MInst	make_variant(MInst::AluRRR, [11, 41, 40, 23, 27])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [29], 2)
		52: MInst	make_variant(MInst::AluRRR, [12, 51, 50, 25, 28])
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2747
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Lo, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [9], 2)
		41: MInst	make_variant(MInst::AluRRR, [13, 40, 39, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2742
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2634
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2974
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		68:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2742
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2634
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2973
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		68:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2742
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2634
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 84, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Option(Type)	extractor(fits_in_32, 68)
		70: Reg	constructor(put_in_reg, [11], 1)
		71: bool	const_prim(false)
		72: Type	match_some(69)
		73: u8	constructor(ty_bits, [72], 0)
		74: u8	const_int(32, u8)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: MInst	make_variant(MInst::Extend, [81, 70, 71, 73, 74])
		83: Unit	constructor(emit, [82], 2)
		84: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		69:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2733
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [10], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		29: Type	const_prim(I64)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [29], 2)
		42: MInst	make_variant(MInst::AluRRR, [11, 41, 40, 23, 27])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [29], 2)
		52: MInst	make_variant(MInst::AluRRR, [12, 51, 50, 25, 28])
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2727
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [9], 2)
		41: MInst	make_variant(MInst::AluRRR, [13, 40, 39, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2722
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2632
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2965
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		68:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2722
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2632
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2964
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		68:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2722
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2632
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 84, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Option(Type)	extractor(fits_in_32, 68)
		70: Reg	constructor(put_in_reg, [11], 1)
		71: bool	const_prim(true)
		72: Type	match_some(69)
		73: u8	constructor(ty_bits, [72], 0)
		74: u8	const_int(32, u8)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: MInst	make_variant(MInst::Extend, [81, 70, 71, 73, 74])
		83: Unit	constructor(emit, [82], 2)
		84: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		69:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2713
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		15: Option(InstOutput)	some(67)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [10], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		29: Type	const_prim(I64)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [29], 2)
		42: MInst	make_variant(MInst::AluRRR, [11, 41, 40, 23, 27])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [29], 2)
		52: MInst	make_variant(MInst::AluRRR, [12, 51, 50, 25, 28])
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2709
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uadd_overflow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Hs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [9], 2)
		41: MInst	make_variant(MInst::AluRRR, [13, 40, 39, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2634
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2974
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		68:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2634
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2973
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 69, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		68:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/lower.isle line 2634
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		22: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg, [12], 3)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [47], 8)
		32: ValueRegs	constructor(value_reg, [66], 9)
		33: InstOutput	constructor(output_pair, [31, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [9], 2)
		45: MInst	make_variant(MInst::AluRRRExtend, [14, 44, 43, 84, 24, 22])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: WritableReg	constructor(writable_zero_reg, [], 1)
		53: ALUOp	make_variant(ALUOp::SubS, [])
		54: MInst	make_variant(MInst::AluRRRExtend, [53, 26, 52, 47, 47, 22])
		55: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 28])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [59, 60])
		64: ValueRegs	constructor(with_flags, [55, 61], 1)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [64, 65], 2)
		68: Type	extractor(value_type, 11)
		69: Option(Type)	extractor(fits_in_32, 68)
		70: Reg	constructor(put_in_reg, [11], 1)
		71: bool	const_prim(false)
		72: Type	match_some(69)
		73: u8	constructor(ty_bits, [72], 0)
		74: u8	const_int(32, u8)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: MInst	make_variant(MInst::Extend, [81, 70, 71, 73, 74])
		83: Unit	constructor(emit, [82], 2)
		84: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		69:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2625
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 3026
		output_reg
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, TrapCode))	extractor(uadd_overflow_trap, 7)
		9: (Value, Value, TrapCode)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		16: TrapCode	match_tuple(9, 2)
		19: Option(InstOutput)	some(39)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: OperandSize	constructor(operand_size, [14], 2)
		26: ALUOp	make_variant(ALUOp::AddS, [])
		27: MInst	make_variant(MInst::AluRRR, [26, 25, 24, 11, 13])
		28: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [27, 28])
		32: Cond	make_variant(Cond::Hs, [])
		33: CondBrKind	constructor(cond_br_cond, [32], 1)
		34: MInst	make_variant(MInst::TrapIf, [33, 16])
		35: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect, [34])
		38: ValueRegs	constructor(value_reg, [44], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: ValueRegs	constructor(with_flags, [29, 35], 1)
		43: usize	const_int(0, usize)
		44: Reg	constructor(value_regs_get, [42, 43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2611
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2437
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(1, u8)
		8: ScalarSize	make_variant(ScalarSize::Size64, [])
		10: Reg	constructor(put_in_reg, [4], 3)
		11: u8	const_int(0, u8)
		13: u8	const_int(63, u8)
		14: ImmShift	constructor(imm_shift_from_u8, [13], 5)
		15: Type	const_prim(I64)
		17: ImmShift	constructor(imm_shift_from_u8, [13], 7)
		19: u64	const_int(1, u64)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_u64, [15, 19], 0)
		21: ShiftOpAndAmt	match_some(20)
		24: Option(InstOutput)	some(59)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::MovFromVec, [29, 6, 7, 8])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::MovFromVec, [37, 10, 11, 8])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		44: ALUOp	make_variant(ALUOp::Lsr, [])
		49: ALUOp	make_variant(ALUOp::Lsr, [])
		55: ALUOp	make_variant(ALUOp::Add, [])
		58: ValueRegs	constructor(value_reg, [90], 1)
		59: InstOutput	constructor(output, [58], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [15], 2)
		67: MInst	make_variant(MInst::AluRRImmShift, [44, 66, 65, 32, 14])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: OperandSize	constructor(operand_size, [15], 2)
		77: MInst	make_variant(MInst::AluRRImmShift, [49, 76, 75, 40, 17])
		78: Unit	constructor(emit, [77], 3)
		79: Reg	constructor(writable_reg_to_reg, [75], 0)
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: OperandSize	constructor(operand_size, [15], 2)
		88: MInst	make_variant(MInst::AluRRRShift, [55, 87, 86, 79, 69, 21])
		89: Unit	constructor(emit, [88], 3)
		90: Reg	constructor(writable_reg_to_reg, [86], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2598
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(31, u8)
		8: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u128	const_int(633825300187901677051779743745, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size32, [])
		18: Option(InstOutput)	some(43)
		22: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		27: VecALUOp	make_variant(VecALUOp::And, [])
		31: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::MovFromVec, [37, 69, 14, 15])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I8X16)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::VecShiftImm, [22, 49, 6, 8, 7])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
		57: Type	const_prim(I8X16)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::VecRRR, [27, 58, 52, 11, 8])
		60: Unit	constructor(emit, [59], 2)
		61: Reg	constructor(writable_reg_to_reg, [58], 0)
		65: Type	const_prim(I8X16)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::VecLanes, [31, 66, 61, 8])
		68: Unit	constructor(emit, [67], 2)
		69: Reg	constructor(writable_reg_to_reg, [66], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2585
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(15, u8)
		8: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u128	const_int(664619068533544770747334646890102785, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size16, [])
		18: Option(InstOutput)	some(43)
		22: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		27: VecALUOp	make_variant(VecALUOp::And, [])
		31: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::MovFromVec, [37, 69, 14, 15])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I8X16)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::VecShiftImm, [22, 49, 6, 8, 7])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
		57: Type	const_prim(I8X16)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::VecRRR, [27, 58, 52, 11, 8])
		60: Unit	constructor(emit, [59], 2)
		61: Reg	constructor(writable_reg_to_reg, [58], 0)
		65: Type	const_prim(I8X16)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::VecLanes, [31, 66, 61, 8])
		68: Unit	constructor(emit, [67], 2)
		69: Reg	constructor(writable_reg_to_reg, [66], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2561
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/isa/aarch64/inst.isle line 2592
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(7, u8)
		8: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u128	const_int(-169808226154284360427508033573982305791, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		13: u8	const_int(8, u8)
		16: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: u8	const_int(0, u8)
		19: ScalarSize	make_variant(ScalarSize::Size16, [])
		22: Option(InstOutput)	some(60)
		26: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		31: VecALUOp	make_variant(VecALUOp::And, [])
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecExtract, [37, 78, 78, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		44: VecALUOp	make_variant(VecALUOp::Zip1, [])
		48: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::MovFromVec, [54, 95, 18, 19])
		56: Unit	constructor(emit, [55], 2)
		57: Reg	constructor(writable_reg_to_reg, [54], 0)
		59: ValueRegs	constructor(value_reg, [57], 1)
		60: InstOutput	constructor(output, [59], 2)
		65: Type	const_prim(I8X16)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::VecShiftImm, [26, 66, 6, 8, 7])
		68: Unit	constructor(emit, [67], 2)
		69: Reg	constructor(writable_reg_to_reg, [66], 0)
		74: Type	const_prim(I8X16)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: MInst	make_variant(MInst::VecRRR, [31, 75, 69, 11, 8])
		77: Unit	constructor(emit, [76], 2)
		78: Reg	constructor(writable_reg_to_reg, [75], 0)
		83: Type	const_prim(I8X16)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: MInst	make_variant(MInst::VecRRR, [44, 84, 78, 40, 8])
		86: Unit	constructor(emit, [85], 2)
		87: Reg	constructor(writable_reg_to_reg, [84], 0)
		91: Type	const_prim(I8X16)
		92: WritableReg	constructor(temp_writable_reg, [91], 1)
		93: MInst	make_variant(MInst::VecLanes, [48, 92, 87, 16])
		94: Unit	constructor(emit, [93], 2)
		95: Reg	constructor(writable_reg_to_reg, [92], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2547
		../../codegen/src/isa/aarch64/inst.isle line 3702
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((StackSlot, Offset32))	extractor(stack_addr, 0)
		4: (StackSlot, Offset32)	match_some(3)
		5: StackSlot	match_tuple(4, 0)
		6: Offset32	match_tuple(4, 1)
		9: Option(InstOutput)	some(19)
		12: Type	const_prim(I64)
		13: WritableReg	constructor(temp_writable_reg, [12], 1)
		14: MInst	constructor(abi_stackslot_addr, [13, 5, 6], 2)
		15: Unit	constructor(emit, [14], 3)
		16: Reg	constructor(writable_reg_to_reg, [13], 0)
		18: ValueRegs	constructor(value_reg, [16], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2540
		../../codegen/src/isa/aarch64/inst.isle line 2285
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Type	extractor(value_type, 8)
		12: VectorSize	constructor(vector_size, [11], 3)
		13: Uimm8	match_tuple(4, 2)
		14: u8	extractor(u8_from_uimm8, 13)
		15: u8	const_int(0, u8)
		18: Option(InstOutput)	some(31)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMovElement, [25, 9, 10, 14, 15, 12])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2535
		../../codegen/src/isa/aarch64/inst.isle line 2278
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_int, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Type	extractor(value_type, 8)
		12: VectorSize	constructor(vector_size, [11], 3)
		13: Uimm8	match_tuple(4, 2)
		14: u8	extractor(u8_from_uimm8, 13)
		17: Option(InstOutput)	some(29)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovToVec, [23, 9, 10, 14, 12])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2528
		../../codegen/src/isa/aarch64/inst.isle line 2305
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	extractor(value_type, 10)
		13: VectorSize	constructor(vector_size, [12], 2)
		14: Uimm8	match_tuple(9, 1)
		15: u8	extractor(u8_from_uimm8, 14)
		18: Option(InstOutput)	some(29)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::FpuMoveFromVec, [23, 11, 15, 13])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2523
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		14: Uimm8	match_tuple(9, 1)
		15: u8	extractor(u8_from_uimm8, 14)
		18: Option(InstOutput)	some(29)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovFromVec, [23, 11, 15, 13])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2520
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Uimm8	match_tuple(9, 1)
		11: u8	extractor(u8_from_uimm8, 10)
		12: Value	match_tuple(9, 0)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(put_in_regs, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_int(0)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2514
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value))	extractor(bitcast, 6)
		8: (MemFlags, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Type	extractor(value_type, 9)
		12: Option(InstOutput)	some(15)
		14: ValueRegs	constructor(put_in_regs, [9], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	const_prim(I128)
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2510
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(put_in_regs, [10], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 350
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 349
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 350
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 349
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3470
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size64, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude.isle line 348
		../../codegen/src/prelude.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 3464
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(33)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		28: MInst	make_variant(MInst::Mov, [27, 26, 15])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2489
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(fits_in_64, 11)
		13: Type	match_some(12)
		14: Option(Type)	extractor(ty_float_or_vec, 13)
		15: Reg	constructor(put_in_reg, [10], 1)
		16: ScalarSize	constructor(scalar_size, [5], 2)
		17: u8	const_int(0, u8)
		20: Option(InstOutput)	some(31)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::MovFromVec, [25, 15, 17, 16])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
		14:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2484
		../../codegen/src/isa/aarch64/inst.isle line 2264
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		13: Reg	constructor(put_in_reg, [10], 1)
		14: ScalarSize	constructor(scalar_size, [11], 2)
		17: Option(InstOutput)	some(27)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::MovToFpu, [21, 13, 14])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_float_or_vec, 11)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(put_in_regs, [10], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/isa/aarch64/inst.isle line 3696
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3486
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(set_pinned_reg, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		8: Option(InstOutput)	some(14)
		10: PReg	constructor(preg_pinned, [], 1)
		14: InstOutput	constructor(output_none, [], 2)
		17: MInst	make_variant(MInst::MovToPReg, [10, 5])
		18: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [17])
		20: MInst	match_variant(18, SideEffectNoResult::Inst, inst)
		21: Unit	constructor(emit, [20], 1)
	]
	constraints = [
		3:	some
		18:	variant(SideEffectNoResult::Inst)
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2471
		../../codegen/src/isa/aarch64/inst.isle line 3480
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_pinned_reg, 0)
		4: PReg	constructor(preg_pinned, [], 1)
		7: Option(InstOutput)	some(16)
		9: Type	const_prim(I64)
		10: WritableReg	constructor(temp_writable_reg, [9], 1)
		11: MInst	make_variant(MInst::MovFromPReg, [10, 4])
		12: Unit	constructor(emit, [11], 2)
		13: Reg	constructor(writable_reg_to_reg, [10], 0)
		15: ValueRegs	constructor(value_reg, [13], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2464
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2464
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2464
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore128, [13, 21, 14])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		29: InstOutput	constructor(output_none, [], 2)
		31: MInst	match_variant(26, SideEffectNoResult::Inst, inst)
		32: Unit	constructor(emit, [31], 1)
	]
	constraints = [
		3:	some
		7:	some
		26:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore64, [13, 21, 14])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		29: InstOutput	constructor(output_none, [], 2)
		31: MInst	match_variant(26, SideEffectNoResult::Inst, inst)
		32: Unit	constructor(emit, [31], 1)
	]
	constraints = [
		3:	some
		7:	some
		26:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2456
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2456
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2456
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore128, [13, 21, 14])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		29: InstOutput	constructor(output_none, [], 2)
		31: MInst	match_variant(26, SideEffectNoResult::Inst, inst)
		32: Unit	constructor(emit, [31], 1)
	]
	constraints = [
		3:	some
		7:	some
		26:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [13, 35, 14])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		43: InstOutput	constructor(output_none, [], 2)
		45: MInst	match_variant(40, SideEffectNoResult::Inst, inst)
		46: Unit	constructor(emit, [45], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
		40:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore64, [13, 21, 14])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		29: InstOutput	constructor(output_none, [], 2)
		31: MInst	match_variant(26, SideEffectNoResult::Inst, inst)
		32: Unit	constructor(emit, [31], 1)
	]
	constraints = [
		3:	some
		7:	some
		26:	variant(SideEffectNoResult::Inst)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 3205
		../../codegen/src/isa/aarch64/inst.isle line 2895
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: ValueRegs	constructor(put_in_regs, [5], 2)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 3)
		14: ValueRegs	constructor(put_in_regs, [5], 4)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		17: MemFlags	match_tuple(4, 0)
		20: Option(InstOutput)	some(37)
		23: i64	constructor(i32_as_i64, [9], 0)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		27: SImm7Scaled	match_some(25)
		28: PairAMode	make_variant(PairAMode::SignedOffset, [26, 27])
		33: MInst	make_variant(MInst::StoreP64, [13, 16, 28, 17])
		34: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [33])
		37: InstOutput	constructor(output_none, [], 2)
		39: MInst	match_variant(34, SideEffectNoResult::Inst, inst)
		40: Unit	constructor(emit, [39], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		25:	some
		34:	variant(SideEffectNoResult::Inst)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 3200
		../../codegen/src/isa/aarch64/inst.isle line 2895
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3193
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: ValueRegs	constructor(put_in_regs, [5], 2)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 3)
		14: ValueRegs	constructor(put_in_regs, [5], 4)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		17: MemFlags	match_tuple(4, 0)
		20: Option(InstOutput)	some(38)
		23: i64	const_int(0, i64)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		28: SImm7Scaled	match_some(25)
		29: PairAMode	make_variant(PairAMode::SignedOffset, [26, 28])
		34: MInst	make_variant(MInst::StoreP64, [13, 16, 29, 17])
		35: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [34])
		38: InstOutput	constructor(output_none, [], 2)
		42: MInst	match_variant(35, SideEffectNoResult::Inst, inst)
		43: Unit	constructor(emit, [42], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		9:	const_int(0)
		25:	some
		35:	variant(SideEffectNoResult::Inst)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 3200
		../../codegen/src/isa/aarch64/inst.isle line 2895
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3190
		../../codegen/src/prelude_lower.isle line 367
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: ValueRegs	constructor(put_in_regs, [5], 2)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 3)
		14: ValueRegs	constructor(put_in_regs, [5], 4)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		17: MemFlags	match_tuple(4, 0)
		20: Option(InstOutput)	some(38)
		23: i64	const_int(0, i64)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		28: SImm7Scaled	match_some(25)
		29: PairAMode	make_variant(PairAMode::SignedOffset, [64, 28])
		34: MInst	make_variant(MInst::StoreP64, [13, 16, 29, 17])
		35: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [34])
		38: InstOutput	constructor(output_none, [], 2)
		41: i64	constructor(i32_as_i64, [9], 0)
		42: u64	constructor(i64_as_u64, [41], 0)
		43: Option(Imm12)	extractor(imm12_from_u64, 42)
		44: Type	const_prim(I64)
		45: Imm12	match_some(43)
		48: MInst	match_variant(35, SideEffectNoResult::Inst, inst)
		49: Unit	constructor(emit, [48], 1)
		53: ALUOp	make_variant(ALUOp::Add, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: OperandSize	constructor(operand_size, [44], 2)
		62: MInst	make_variant(MInst::AluRRImm12, [53, 61, 60, 26, 45])
		63: Unit	constructor(emit, [62], 3)
		64: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		25:	some
		35:	variant(SideEffectNoResult::Inst)
		43:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 3200
		../../codegen/src/isa/aarch64/inst.isle line 2895
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3188
		../../codegen/src/prelude_lower.isle line 367
		add_to_alu_rrr
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: ValueRegs	constructor(put_in_regs, [5], 2)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 3)
		14: ValueRegs	constructor(put_in_regs, [5], 4)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		17: MemFlags	match_tuple(4, 0)
		20: Option(InstOutput)	some(38)
		23: i64	const_int(0, i64)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		28: SImm7Scaled	match_some(25)
		29: PairAMode	make_variant(PairAMode::SignedOffset, [64, 28])
		34: MInst	make_variant(MInst::StoreP64, [13, 16, 29, 17])
		35: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [34])
		38: InstOutput	constructor(output_none, [], 2)
		41: Type	const_prim(I64)
		42: ImmExtend	make_variant(ImmExtend::Zero, [])
		43: i64	constructor(i32_as_i64, [9], 0)
		44: u64	constructor(i64_as_u64, [43], 0)
		45: Reg	constructor(imm, [41, 42, 44], 1)
		48: MInst	match_variant(35, SideEffectNoResult::Inst, inst)
		49: Unit	constructor(emit, [48], 1)
		53: ALUOp	make_variant(ALUOp::Add, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: OperandSize	constructor(operand_size, [41], 2)
		62: MInst	make_variant(MInst::AluRRR, [53, 61, 60, 26, 45])
		63: Unit	constructor(emit, [62], 3)
		64: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		25:	some
		35:	variant(SideEffectNoResult::Inst)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::FpuStore64, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2436
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2886
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore32, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2436
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2886
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore32, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2436
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2886
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::FpuStore32, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2431
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(41)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store32, [11, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		41: InstOutput	constructor(output_none, [], 2)
		43: MInst	match_variant(38, SideEffectNoResult::Inst, inst)
		44: Unit	constructor(emit, [43], 1)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
		38:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2431
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(41)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store32, [11, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		41: InstOutput	constructor(output_none, [], 2)
		43: MInst	match_variant(38, SideEffectNoResult::Inst, inst)
		44: Unit	constructor(emit, [43], 1)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
		38:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2431
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(27)
		19: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		23: MInst	make_variant(MInst::Store32, [11, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		27: InstOutput	constructor(output_none, [], 2)
		29: MInst	match_variant(24, SideEffectNoResult::Inst, inst)
		30: Unit	constructor(emit, [29], 1)
	]
	constraints = [
		3:	some
		24:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2427
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(41)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store16, [11, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		41: InstOutput	constructor(output_none, [], 2)
		43: MInst	match_variant(38, SideEffectNoResult::Inst, inst)
		44: Unit	constructor(emit, [43], 1)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
		38:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2427
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(41)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store16, [11, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		41: InstOutput	constructor(output_none, [], 2)
		43: MInst	match_variant(38, SideEffectNoResult::Inst, inst)
		44: Unit	constructor(emit, [43], 1)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
		38:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2427
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(27)
		19: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		23: MInst	make_variant(MInst::Store16, [11, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		27: InstOutput	constructor(output_none, [], 2)
		29: MInst	match_variant(24, SideEffectNoResult::Inst, inst)
		30: Unit	constructor(emit, [29], 1)
	]
	constraints = [
		3:	some
		24:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(41)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store8, [11, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		41: InstOutput	constructor(output_none, [], 2)
		43: MInst	match_variant(38, SideEffectNoResult::Inst, inst)
		44: Unit	constructor(emit, [43], 1)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
		38:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(41)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store8, [11, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		41: InstOutput	constructor(output_none, [], 2)
		43: MInst	match_variant(38, SideEffectNoResult::Inst, inst)
		44: Unit	constructor(emit, [43], 1)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
		38:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(27)
		19: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		23: MInst	make_variant(MInst::Store8, [11, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		27: InstOutput	constructor(output_none, [], 2)
		29: MInst	match_variant(24, SideEffectNoResult::Inst, inst)
		30: Unit	constructor(emit, [29], 1)
	]
	constraints = [
		3:	some
		24:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store64, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store64, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2410
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store32, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2410
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store32, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2410
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store32, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2406
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store16, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2406
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store16, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2406
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store16, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2402
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store8, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2402
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(42)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store8, [12, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		42: InstOutput	constructor(output_none, [], 2)
		44: MInst	match_variant(39, SideEffectNoResult::Inst, inst)
		45: Unit	constructor(emit, [44], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
		39:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2402
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(28)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store8, [12, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		28: InstOutput	constructor(output_none, [], 2)
		30: MInst	match_variant(25, SideEffectNoResult::Inst, inst)
		31: Unit	constructor(emit, [30], 1)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		25:	variant(SideEffectNoResult::Inst)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2393
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2393
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2393
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(40)
		21: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [12, 34, 28, 13, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2387
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2387
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2387
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(40)
		21: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [12, 34, 28, 13, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2381
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2381
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2381
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(40)
		21: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [12, 34, 28, 13, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2375
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2375
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2375
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(40)
		21: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [12, 34, 28, 13, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(40)
		21: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [12, 34, 28, 13, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2363
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2363
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(54)
		21: Option(Inst)	extractor(def_inst, 6)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 8], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [4, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecExtend, [12, 48, 42, 13, 14])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ValueRegs	constructor(value_reg, [51], 1)
		54: InstOutput	constructor(output, [53], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2363
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(40)
		21: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [12, 34, 28, 13, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2840
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::SLoad32, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2840
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::SLoad32, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2840
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(27)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::SLoad32, [21, 17, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2356
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2835
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::ULoad32, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2356
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2835
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::ULoad32, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2356
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2835
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(27)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::ULoad32, [21, 17, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2830
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::SLoad16, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2830
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::SLoad16, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2830
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(27)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::SLoad16, [21, 17, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2350
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2825
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::ULoad16, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2350
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2825
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::ULoad16, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2350
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2825
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(27)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::ULoad16, [21, 17, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2820
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::SLoad8, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2820
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::SLoad8, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2820
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(27)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::SLoad8, [21, 17, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2344
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::ULoad8, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2344
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(41)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::ULoad8, [35, 31, 10])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2344
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(27)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::ULoad8, [21, 17, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2339
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2860
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad128, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2339
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2860
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad128, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2339
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2860
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(32)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64X2)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuLoad128, [26, 22, 15])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2335
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad64, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2335
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad64, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2335
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(32)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuLoad64, [26, 22, 15])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2860
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad128, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2860
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad128, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2860
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(32)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64X2)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuLoad128, [26, 22, 15])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2327
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad64, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2327
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(46)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuLoad64, [40, 36, 15])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2327
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(32)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuLoad64, [26, 22, 15])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2324
		../../codegen/src/isa/aarch64/inst.isle line 3205
		../../codegen/src/isa/aarch64/inst.isle line 2865
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [34], 3)
		16: Option(InstOutput)	some(15)
		19: i64	constructor(i32_as_i64, [11], 0)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		23: SImm7Scaled	match_some(21)
		24: PairAMode	make_variant(PairAMode::SignedOffset, [22, 23])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: MInst	make_variant(MInst::LoadP64, [28, 29, 24, 13])
		31: Unit	constructor(emit, [30], 3)
		32: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: ValueRegs	constructor(value_regs, [32, 33], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		21:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2324
		../../codegen/src/isa/aarch64/inst.isle line 3200
		../../codegen/src/isa/aarch64/inst.isle line 2865
		../../codegen/src/isa/aarch64/inst.isle line 3193
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [35], 3)
		16: Option(InstOutput)	some(15)
		19: i64	const_int(0, i64)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		24: SImm7Scaled	match_some(21)
		25: PairAMode	make_variant(PairAMode::SignedOffset, [22, 24])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: WritableReg	constructor(temp_writable_reg, [28], 2)
		31: MInst	make_variant(MInst::LoadP64, [29, 30, 25, 13])
		32: Unit	constructor(emit, [31], 3)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
		35: ValueRegs	constructor(value_regs, [33, 34], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		11:	const_int(0)
		21:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2324
		../../codegen/src/isa/aarch64/inst.isle line 3200
		../../codegen/src/isa/aarch64/inst.isle line 2865
		../../codegen/src/isa/aarch64/inst.isle line 3190
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [35], 3)
		16: Option(InstOutput)	some(15)
		19: i64	const_int(0, i64)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		24: SImm7Scaled	match_some(21)
		25: PairAMode	make_variant(PairAMode::SignedOffset, [58, 24])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: WritableReg	constructor(temp_writable_reg, [28], 2)
		31: MInst	make_variant(MInst::LoadP64, [29, 30, 25, 13])
		32: Unit	constructor(emit, [31], 3)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
		35: ValueRegs	constructor(value_regs, [33, 34], 4)
		38: i64	constructor(i32_as_i64, [11], 0)
		39: u64	constructor(i64_as_u64, [38], 0)
		40: Option(Imm12)	extractor(imm12_from_u64, 39)
		41: Type	const_prim(I64)
		42: Imm12	match_some(40)
		47: ALUOp	make_variant(ALUOp::Add, [])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: OperandSize	constructor(operand_size, [41], 2)
		56: MInst	make_variant(MInst::AluRRImm12, [47, 55, 54, 22, 42])
		57: Unit	constructor(emit, [56], 3)
		58: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		21:	some
		40:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2324
		../../codegen/src/isa/aarch64/inst.isle line 3200
		../../codegen/src/isa/aarch64/inst.isle line 2865
		../../codegen/src/isa/aarch64/inst.isle line 3188
		add_to_alu_rrr
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [35], 3)
		16: Option(InstOutput)	some(15)
		19: i64	const_int(0, i64)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		24: SImm7Scaled	match_some(21)
		25: PairAMode	make_variant(PairAMode::SignedOffset, [58, 24])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: WritableReg	constructor(temp_writable_reg, [28], 2)
		31: MInst	make_variant(MInst::LoadP64, [29, 30, 25, 13])
		32: Unit	constructor(emit, [31], 3)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
		35: ValueRegs	constructor(value_regs, [33, 34], 4)
		38: Type	const_prim(I64)
		39: ImmExtend	make_variant(ImmExtend::Zero, [])
		40: i64	constructor(i32_as_i64, [11], 0)
		41: u64	constructor(i64_as_u64, [40], 0)
		42: Reg	constructor(imm, [38, 39, 41], 1)
		47: ALUOp	make_variant(ALUOp::Add, [])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: OperandSize	constructor(operand_size, [38], 2)
		56: MInst	make_variant(MInst::AluRRR, [47, 55, 54, 22, 42])
		57: Unit	constructor(emit, [56], 3)
		58: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		21:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2321
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2321
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad64, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2321
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2855
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad64, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2318
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2850
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad32, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2318
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2850
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::FpuLoad32, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2318
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2850
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuLoad32, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2315
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2845
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad64, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2315
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2845
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad64, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2315
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2845
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::ULoad64, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2845
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad64, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2845
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad64, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2845
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::ULoad64, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2835
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad32, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2835
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad32, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2835
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::ULoad32, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2825
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad16, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2825
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad16, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2825
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::ULoad16, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2303
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/inst.isle line 2815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad8, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2303
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/inst.isle line 2815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(45)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::ULoad8, [39, 35, 14])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2303
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/inst.isle line 2815
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(31)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::ULoad8, [25, 21, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2298
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(return_call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_return_call_indirect, [5, 6, 7], 1)
		9: Option(InstOutput)	some(8)
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2295
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(return_call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_return_call, [7, 8, 9, 10], 1)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/prelude_lower.isle line 1044
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(ValueSlice)	extractor(return, 0)
		4: ValueSlice	match_some(3)
		6: Option(InstOutput)	some(9)
		8: Unit	constructor(gen_return, [4], 1)
		9: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_call_indirect, [5, 6, 7], 1)
		9: Option(InstOutput)	some(8)
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_call, [7, 8, 9, 10], 1)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2276
		../../codegen/src/isa/aarch64/inst.isle line 3526
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3480
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		6: Option(InstOutput)	some(20)
		7: Option(Unit)	constructor(preserve_frame_pointers, [], 0)
		8: WritableReg	constructor(writable_link_reg, [], 1)
		9: i64	const_int(8, i64)
		10: AMode	make_variant(AMode::FPOffset, [9])
		11: MemFlags	constructor(mem_flags_trusted, [], 0)
		12: MInst	make_variant(MInst::ULoad64, [8, 10, 11])
		13: Unit	constructor(emit, [12], 2)
		14: MInst	make_variant(MInst::Xpaclri, [])
		15: Unit	constructor(emit, [14], 3)
		16: PReg	constructor(preg_link, [], 4)
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovFromPReg, [23, 16])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2276
		../../codegen/src/isa/aarch64/inst.isle line 3510
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		6: Option(InstOutput)	some(19)
		7: Option(Unit)	constructor(preserve_frame_pointers, [], 0)
		8: Option(Unit)	constructor(sign_return_address_disabled, [], 0)
		9: Type	const_prim(I64)
		10: WritableReg	constructor(temp_writable_reg, [9], 1)
		11: i64	const_int(8, i64)
		12: AMode	make_variant(AMode::FPOffset, [11])
		13: MemFlags	constructor(mem_flags_trusted, [], 0)
		14: MInst	make_variant(MInst::ULoad64, [10, 12, 13])
		15: Unit	constructor(emit, [14], 2)
		16: Reg	constructor(writable_reg_to_reg, [10], 0)
		18: ValueRegs	constructor(value_reg, [16], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		7:	some
		8:	some
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2273
		../../codegen/src/isa/aarch64/inst.isle line 3502
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3480
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_stack_pointer, 0)
		6: Option(InstOutput)	some(11)
		7: PReg	constructor(preg_sp, [], 1)
		10: ValueRegs	constructor(value_reg, [17], 1)
		11: InstOutput	constructor(output, [10], 2)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: MInst	make_variant(MInst::MovFromPReg, [14, 7])
		16: Unit	constructor(emit, [15], 2)
		17: Reg	constructor(writable_reg_to_reg, [14], 0)
	]
	constraints = [
		3:	some
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2270
		../../codegen/src/isa/aarch64/inst.isle line 3506
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3480
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_frame_pointer, 0)
		6: Option(InstOutput)	some(11)
		7: PReg	constructor(preg_fp, [], 1)
		10: ValueRegs	constructor(value_reg, [17], 1)
		11: InstOutput	constructor(output, [10], 2)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: MInst	make_variant(MInst::MovFromPReg, [14, 7])
		16: Unit	constructor(emit, [15], 2)
		17: Reg	constructor(writable_reg_to_reg, [14], 0)
	]
	constraints = [
		3:	some
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2265
		../../codegen/src/isa/aarch64/inst.isle line 3101
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(GlobalValue)	extractor(symbol_value, 0)
		4: GlobalValue	match_some(3)
		5: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 4)
		6: (ExternalName, RelocDistance, i64)	match_some(5)
		7: ExternalName	match_tuple(6, 0)
		8: BoxExternalName	constructor(box_external_name, [7], 1)
		9: i64	match_tuple(6, 2)
		12: Option(InstOutput)	some(22)
		15: Type	const_prim(I64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: MInst	make_variant(MInst::LoadExtName, [16, 8, 9])
		18: Unit	constructor(emit, [17], 2)
		19: Reg	constructor(writable_reg_to_reg, [16], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2260
		../../codegen/src/isa/aarch64/inst.isle line 3101
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(FuncRef)	extractor(func_addr, 0)
		4: FuncRef	match_some(3)
		5: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 4)
		6: ExternalName	match_tuple(5, 1)
		7: BoxExternalName	constructor(box_external_name, [6], 1)
		8: i64	const_int(0, i64)
		11: Option(InstOutput)	some(21)
		14: Type	const_prim(I64)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: MInst	make_variant(MInst::LoadExtName, [15, 7, 8])
		17: Unit	constructor(emit, [16], 2)
		18: Reg	constructor(writable_reg_to_reg, [15], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2255
		../../codegen/src/isa/aarch64/inst.isle line 2583
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(debugtrap, 0)
		6: Option(InstOutput)	some(11)
		7: MInst	make_variant(MInst::Brk, [])
		8: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [7])
		11: InstOutput	constructor(output_none, [], 2)
		13: MInst	match_variant(8, SideEffectNoResult::Inst, inst)
		14: Unit	constructor(emit, [13], 1)
	]
	constraints = [
		3:	some
		8:	variant(SideEffectNoResult::Inst)
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2249
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_invalid, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: OperandSize	constructor(operand_size, [5], 1)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(1, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [22, 28], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		19: WritableReg	constructor(writable_zero_reg, [], 1)
		20: ALUOp	make_variant(ALUOp::AddS, [])
		21: MInst	make_variant(MInst::AluRRImm12, [20, 6, 19, 7, 9])
		22: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [21])
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::CSet, [25, 11])
		27: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [26, 27])
	]
	constraints = [
		3:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2243
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_null, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: OperandSize	constructor(operand_size, [5], 1)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(0, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [22, 28], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		19: WritableReg	constructor(writable_zero_reg, [], 1)
		20: ALUOp	make_variant(ALUOp::SubS, [])
		21: MInst	make_variant(MInst::AluRRImm12, [20, 6, 19, 7, 9])
		22: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [21])
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::CSet, [25, 11])
		27: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [26, 27])
	]
	constraints = [
		3:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2238
		../../codegen/src/isa/aarch64/inst.isle line 2573
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(fence, 0)
		6: Option(InstOutput)	some(11)
		7: MInst	make_variant(MInst::Fence, [])
		8: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [7])
		11: InstOutput	constructor(output_none, [], 2)
		13: MInst	match_variant(8, SideEffectNoResult::Inst, inst)
		14: Unit	constructor(emit, [13], 1)
	]
	constraints = [
		3:	some
		8:	variant(SideEffectNoResult::Inst)
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2231
		../../codegen/src/isa/aarch64/inst.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: u8	const_int(1, u8)
		12: VectorSize	make_variant(VectorSize::Size32x2, [])
		14: ScalarSize	constructor(lane_size, [5], 3)
		15: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		16: bool	const_prim(false)
		19: Option(InstOutput)	some(39)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::FpuMoveFromVec, [24, 10, 11, 12])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecExtend, [15, 33, 27, 16, 14])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2228
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		14: bool	const_prim(true)
		17: Option(InstOutput)	some(29)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::VecExtend, [13, 23, 10, 14, 12])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2223
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_low, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		12: bool	const_prim(false)
		15: Option(InstOutput)	some(27)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecExtend, [11, 21, 8, 12, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2216
		../../codegen/src/isa/aarch64/inst.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: u8	const_int(1, u8)
		12: VectorSize	make_variant(VectorSize::Size32x2, [])
		14: ScalarSize	constructor(lane_size, [5], 3)
		15: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		16: bool	const_prim(false)
		19: Option(InstOutput)	some(39)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::FpuMoveFromVec, [24, 10, 11, 12])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecExtend, [15, 33, 27, 16, 14])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2213
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		14: bool	const_prim(true)
		17: Option(InstOutput)	some(29)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::VecExtend, [13, 23, 10, 14, 12])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2326
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_low, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		12: bool	const_prim(false)
		15: Option(InstOutput)	some(27)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecExtend, [11, 21, 8, 12, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/isa/aarch64/inst.isle line 2569
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		31: ValueRegs	constructor(value_reg, [49], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRNarrowLow, [23, 37, 11, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecRRNarrowHigh, [28, 46, 40, 16, 17])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2197
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2565
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(39)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecMovElement, [29, 11, 13, 14, 15, 16])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		35: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::VecRRNarrowLow, [35, 44, 32, 19])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2193
		../../codegen/src/isa/aarch64/inst.isle line 2565
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		24: ValueRegs	constructor(value_reg, [33], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRNarrowLow, [21, 30, 13, 15])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2185
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/isa/aarch64/inst.isle line 2561
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		31: ValueRegs	constructor(value_reg, [49], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRNarrowLow, [23, 37, 11, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecRRNarrowHigh, [28, 46, 40, 16, 17])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2181
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2557
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(39)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecMovElement, [29, 11, 13, 14, 15, 16])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		35: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::VecRRNarrowLow, [35, 44, 32, 19])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2177
		../../codegen/src/isa/aarch64/inst.isle line 2557
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		24: ValueRegs	constructor(value_reg, [33], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRNarrowLow, [21, 30, 13, 15])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2170
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/isa/aarch64/inst.isle line 2553
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		31: ValueRegs	constructor(value_reg, [49], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRNarrowLow, [23, 37, 11, 13])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecRRNarrowHigh, [28, 46, 40, 16, 17])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2166
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2549
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(39)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecMovElement, [29, 11, 13, 14, 15, 16])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		35: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::VecRRNarrowLow, [35, 44, 32, 19])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2162
		../../codegen/src/isa/aarch64/inst.isle line 2549
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		24: ValueRegs	constructor(value_reg, [33], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRNarrowLow, [21, 30, 13, 15])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2157
		../../codegen/src/isa/aarch64/inst.isle line 2545
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvdemote, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: ScalarSize	make_variant(ScalarSize::Size32, [])
		9: Option(InstOutput)	some(16)
		12: VecRRNarrowOp	make_variant(VecRRNarrowOp::Fcvtn, [])
		15: ValueRegs	constructor(value_reg, [24], 1)
		16: InstOutput	constructor(output, [15], 2)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecRRNarrowLow, [12, 21, 5, 6])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2152
		../../codegen/src/isa/aarch64/inst.isle line 3451
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 7)
		9: (MemFlags, Value, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(34)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: MInst	make_variant(MInst::AtomicCASLoop, [16, 17, 11, 13, 15, 27, 28])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [27], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2147
		../../codegen/src/isa/aarch64/inst.isle line 3423
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 8)
		10: (MemFlags, Value, Value, Value)	match_some(9)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 2)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 3)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Type	match_some(6)
		18: MemFlags	match_tuple(10, 0)
		21: Option(InstOutput)	some(33)
		27: WritableReg	constructor(temp_writable_reg, [17], 1)
		28: MInst	make_variant(MInst::AtomicCAS, [27, 14, 16, 12, 17, 18])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Xchg, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xchg)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2139
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umax, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umax)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2136
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umin, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umin)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2133
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smax, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smax)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smin, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smin)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Eor, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xor)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Orr, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Or)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2121
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Nand, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Nand)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::And, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::And)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2115
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Sub, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Sub)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2112
		../../codegen/src/isa/aarch64/inst.isle line 3437
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Add, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: WritableReg	constructor(temp_writable_reg, [26], 2)
		29: WritableReg	constructor(temp_writable_reg, [26], 3)
		30: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 27, 28, 29])
		31: Unit	constructor(emit, [30], 4)
		32: Reg	constructor(writable_reg_to_reg, [27], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Add)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2106
		../../codegen/src/isa/aarch64/inst.isle line 2793
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Reg	constructor(zero_reg, [], 2)
		15: Type	match_some(6)
		17: AtomicRMWOp	make_variant(AtomicRMWOp::Clr, [])
		18: Value	match_tuple(10, 2)
		19: MemFlags	match_tuple(10, 0)
		22: Option(InstOutput)	some(40)
		26: ALUOp	make_variant(ALUOp::EorNot, [])
		33: Reg	constructor(put_in_reg, [18], 1)
		34: WritableReg	constructor(temp_writable_reg, [15], 2)
		35: MInst	make_variant(MInst::AtomicRMW, [17, 50, 34, 33, 15, 19])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [15], 2)
		48: MInst	make_variant(MInst::AluRRR, [26, 47, 46, 13, 14])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::And)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2102
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Reg	constructor(zero_reg, [], 1)
		13: Value	match_tuple(10, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		17: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		18: Value	match_tuple(10, 2)
		19: MemFlags	match_tuple(10, 0)
		22: Option(InstOutput)	some(40)
		26: ALUOp	make_variant(ALUOp::Sub, [])
		33: Reg	constructor(put_in_reg, [18], 1)
		34: WritableReg	constructor(temp_writable_reg, [15], 2)
		35: MInst	make_variant(MInst::AtomicRMW, [17, 50, 34, 33, 15, 19])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [15], 2)
		48: MInst	make_variant(MInst::AluRRR, [26, 47, 46, 12, 14])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Sub)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2098
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Umin, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umin)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2094
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Umax, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umax)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2090
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Smin, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smin)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2086
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Smax, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smax)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2082
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Set, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Or)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2078
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Eor, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Xor)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2074
		../../codegen/src/isa/aarch64/inst.isle line 3413
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(33)
		26: Reg	constructor(put_in_reg, [15], 1)
		27: WritableReg	constructor(temp_writable_reg, [16], 2)
		28: MInst	make_variant(MInst::AtomicRMW, [14, 13, 27, 26, 16, 17])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Add)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2067
		../../codegen/src/isa/aarch64/inst.isle line 2347
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value))	extractor(atomic_store, 0)
		4: (MemFlags, Value, Value)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Reg	constructor(put_in_reg, [5], 1)
		9: Value	match_tuple(4, 2)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: Type	match_some(7)
		12: MemFlags	match_tuple(4, 0)
		15: Option(InstOutput)	some(24)
		20: MInst	make_variant(MInst::StoreRelease, [11, 8, 10, 12])
		21: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [20])
		24: InstOutput	constructor(output_none, [], 2)
		26: MInst	match_variant(21, SideEffectNoResult::Inst, inst)
		27: Unit	constructor(emit, [26], 1)
	]
	constraints = [
		3:	some
		7:	some
		21:	variant(SideEffectNoResult::Inst)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2062
		../../codegen/src/isa/aarch64/inst.isle line 2340
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(atomic_load, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: MemFlags	match_tuple(9, 0)
		16: Option(InstOutput)	some(27)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::LoadAcquire, [12, 21, 11, 13])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3094
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3227
		add_to_alu_rrr
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(44)
		24: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		25: Unit	constructor(sink_inst, [14], 1)
		26: (MemFlags, Value, Offset32)	match_some(24)
		27: Value	match_tuple(26, 1)
		28: Reg	constructor(put_in_reg, [27], 2)
		29: Offset32	match_tuple(26, 2)
		30: i32	extractor(offset32, 29)
		31: i64	constructor(i32_as_i64, [30], 0)
		32: u64	constructor(i64_as_u64, [31], 0)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecLoadReplicate, [38, 65, 16, 18])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
		47: Type	const_prim(I64)
		48: ImmExtend	make_variant(ImmExtend::Zero, [])
		49: Reg	constructor(imm, [47, 48, 32], 1)
		54: ALUOp	make_variant(ALUOp::Add, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [47], 2)
		63: MInst	make_variant(MInst::AluRRR, [54, 62, 61, 28, 49])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		24:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3094
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3226
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(44)
		24: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		25: Unit	constructor(sink_inst, [14], 1)
		26: (MemFlags, Value, Offset32)	match_some(24)
		27: Value	match_tuple(26, 1)
		28: Reg	constructor(put_in_reg, [27], 2)
		29: Offset32	match_tuple(26, 2)
		30: i32	extractor(offset32, 29)
		31: i64	constructor(i32_as_i64, [30], 0)
		32: u64	constructor(i64_as_u64, [31], 0)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecLoadReplicate, [38, 65, 16, 18])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
		47: Option(Imm12)	extractor(imm12_from_u64, 32)
		48: Type	const_prim(I64)
		49: Imm12	match_some(47)
		54: ALUOp	make_variant(ALUOp::Add, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [48], 2)
		63: MInst	make_variant(MInst::AluRRImm12, [54, 62, 61, 28, 49])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		24:	some
		47:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3094
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3225
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(44)
		24: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		25: Unit	constructor(sink_inst, [14], 1)
		26: (MemFlags, Value, Offset32)	match_some(24)
		27: Value	match_tuple(26, 1)
		28: Reg	constructor(put_in_reg, [27], 2)
		29: Offset32	match_tuple(26, 2)
		30: i32	extractor(offset32, 29)
		31: i64	constructor(i32_as_i64, [30], 0)
		32: u64	constructor(i64_as_u64, [31], 0)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecLoadReplicate, [38, 28, 16, 18])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		24:	some
		32:	const_int(0)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2053
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Value)	extractor(ireduce, 9)
		11: Value	match_some(10)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: Option(Imm64)	extractor(iconst, 13)
		15: Type	match_tuple(4, 0)
		16: VectorSize	constructor(vector_size, [15], 1)
		17: Imm64	match_some(14)
		18: u64	extractor(u64_from_imm64, 17)
		19: Reg	constructor(splat_const, [18, 16], 2)
		21: Option(InstOutput)	some(24)
		23: ValueRegs	constructor(value_reg, [19], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		14:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2050
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Imm64)	extractor(iconst, 9)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 1)
		13: Imm64	match_some(10)
		14: u64	extractor(u64_from_imm64, 13)
		15: Reg	constructor(splat_const, [14, 12], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2047
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee64)	extractor(f64const, 9)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 1)
		13: Ieee64	match_some(10)
		14: u64	extractor(u64_from_ieee64, 13)
		15: Reg	constructor(splat_const, [14, 12], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2044
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee32)	extractor(f32const, 9)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 1)
		13: Ieee32	match_some(10)
		14: u32	extractor(u32_from_ieee32, 13)
		15: u64	constructor(u32_as_u64, [14], 0)
		16: Reg	constructor(splat_const, [15, 12], 2)
		18: Option(InstOutput)	some(21)
		20: ValueRegs	constructor(value_reg, [16], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2041
		../../codegen/src/isa/aarch64/inst.isle line 1982
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_scalar_float, 8)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: u8	const_int(0, u8)
		16: Option(InstOutput)	some(27)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecDupFromFpu, [21, 10, 12, 13])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2037
		../../codegen/src/isa/aarch64/inst.isle line 1975
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	constructor(ty_int_ref_scalar_64, [8], 0)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(25)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecDup, [19, 10, 12])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2031
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Constant)	extractor(vconst, 5)
		7: Constant	match_some(6)
		8: Option(u64)	extractor(u64_from_constant, 7)
		9: Type	match_tuple(4, 0)
		10: Option(Type)	constructor(ty_vec64, [9], 0)
		11: u64	match_some(8)
		12: Reg	constructor(constant_f64, [11], 1)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(value_reg, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2028
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Constant)	extractor(vconst, 7)
		9: Constant	match_some(8)
		10: Option(u128)	extractor(u128_from_constant, 9)
		11: u128	match_some(10)
		12: Reg	constructor(constant_f128, [11], 1)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(value_reg, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2017
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2111
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Type	const_prim(I64)
		17: Reg	constructor(zero_reg, [], 5)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [38, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		26: Option(InstOutput)	some(25)
		30: ALUOp	make_variant(ALUOp::Orr, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: ALUOp	make_variant(ALUOp::SubS, [])
		37: MInst	make_variant(MInst::AluRRR, [36, 18, 35, 48, 17])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [15], 2)
		46: MInst	make_variant(MInst::AluRRR, [30, 45, 44, 12, 14])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2011
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size64, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: ALUOp	make_variant(ALUOp::SubS, [])
		30: MInst	make_variant(MInst::AluRRR, [29, 13, 28, 24, 12])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2011
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size64, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [37, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [8], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(64, u8)
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: MInst	make_variant(MInst::AluRRR, [35, 13, 34, 46, 12])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 25, 26, 28, 29])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		24:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1997
		../../codegen/src/isa/aarch64/inst.isle line 3835
		../../codegen/src/isa/aarch64/inst.isle line 3839
		../../codegen/src/isa/aarch64/inst.isle line 2578
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [34], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [32, 22, 23, 24, 25], 5)
		29: InstOutput	constructor(output, [26], 8)
		30: Option(InstOutput)	some(29)
		32: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		34: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
		35: MInst	make_variant(MInst::Csdb, [])
		36: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [35])
		39: InstOutput	constructor(output_none, [], 2)
		41: MInst	match_variant(36, SideEffectNoResult::Inst, inst)
		42: Unit	constructor(emit, [41], 1)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
		36:	variant(SideEffectNoResult::Inst)
	]
	result = 30
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1986
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2111
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Type	const_prim(I64)
		17: Reg	constructor(zero_reg, [], 5)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [38, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		26: Option(InstOutput)	some(25)
		30: ALUOp	make_variant(ALUOp::Orr, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: ALUOp	make_variant(ALUOp::SubS, [])
		37: MInst	make_variant(MInst::AluRRR, [36, 18, 35, 48, 17])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [15], 2)
		46: MInst	make_variant(MInst::AluRRR, [30, 45, 44, 12, 14])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1980
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size64, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: ALUOp	make_variant(ALUOp::SubS, [])
		30: MInst	make_variant(MInst::AluRRR, [29, 13, 28, 24, 12])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1980
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size64, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [37, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [8], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(64, u8)
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: MInst	make_variant(MInst::AluRRR, [35, 13, 34, 46, 12])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 25, 26, 28, 29])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		24:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1974
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size32, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: ALUOp	make_variant(ALUOp::SubS, [])
		30: MInst	make_variant(MInst::AluRRR, [29, 13, 28, 24, 12])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1974
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size32, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: ALUOp	make_variant(ALUOp::SubS, [])
		30: MInst	make_variant(MInst::AluRRR, [29, 13, 28, 24, 12])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I32)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1974
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size32, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [37, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [8], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(32, u8)
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: MInst	make_variant(MInst::AluRRR, [35, 13, 34, 46, 12])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 25, 26, 28, 29])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		24:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 2355
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: Type	const_prim(I32)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [11, 12], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [29, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: OperandSize	constructor(operand_size, [11], 1)
		26: WritableReg	constructor(writable_zero_reg, [], 2)
		27: ALUOp	make_variant(ALUOp::AndS, [])
		28: MInst	make_variant(MInst::AluRRImmLogic, [27, 25, 26, 10, 13])
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [28])
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I8)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1959
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((FloatCC, Value, Value))	extractor(fcmp, 12)
		14: (FloatCC, Value, Value)	match_some(13)
		15: FloatCC	match_tuple(14, 0)
		16: Cond	constructor(fp_cond_code, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Type	extractor(value_type, 17)
		19: ScalarSize	constructor(scalar_size, [18], 2)
		20: Reg	constructor(put_in_reg, [17], 3)
		21: Value	match_tuple(14, 2)
		22: Reg	constructor(put_in_reg, [21], 4)
		24: Type	match_tuple(4, 0)
		25: Value	match_tuple(7, 1)
		26: Value	match_tuple(7, 2)
		27: ValueRegs	constructor(lower_select, [34, 16, 24, 25, 26], 6)
		28: InstOutput	constructor(output, [27], 7)
		29: Option(InstOutput)	some(28)
		33: MInst	make_variant(MInst::FpuCmp, [19, 20, 22])
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [33])
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
		../../codegen/src/isa/aarch64/inst.isle line 3835
		../../codegen/src/isa/aarch64/inst.isle line 3839
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [32], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [30, 22, 23, 24, 25], 5)
		27: InstOutput	constructor(output, [26], 6)
		28: Option(InstOutput)	some(27)
		30: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		32: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1941
		../../codegen/src/isa/aarch64/inst.isle line 2809
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(resumable_trap, 0)
		4: TrapCode	match_some(3)
		7: Option(InstOutput)	some(13)
		9: MInst	make_variant(MInst::Udf, [4])
		10: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [9])
		13: InstOutput	constructor(output_none, [], 2)
		15: MInst	match_variant(10, SideEffectNoResult::Inst, inst)
		16: Unit	constructor(emit, [15], 1)
	]
	constraints = [
		3:	some
		10:	variant(SideEffectNoResult::Inst)
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1936
		../../codegen/src/isa/aarch64/inst.isle line 2809
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/prelude_lower.isle line 367
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(trap, 0)
		4: TrapCode	match_some(3)
		7: Option(InstOutput)	some(13)
		9: MInst	make_variant(MInst::Udf, [4])
		10: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [9])
		13: InstOutput	constructor(output_none, [], 2)
		15: MInst	match_variant(10, SideEffectNoResult::Inst, inst)
		16: Unit	constructor(emit, [15], 1)
	]
	constraints = [
		3:	some
		10:	variant(SideEffectNoResult::Inst)
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1931
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((IntCC, Value, Value))	extractor(icmp, 0)
		4: (IntCC, Value, Value)	match_some(3)
		5: IntCC	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: Value	match_tuple(4, 2)
		8: Type	extractor(value_type, 6)
		9: Type	const_prim(I8)
		10: ValueRegs	constructor(lower_icmp_into_reg, [5, 6, 7, 8, 9], 1)
		11: InstOutput	constructor(output, [10], 2)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1925
		../../codegen/src/isa/aarch64/inst.isle line 3403
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: IntCC	match_some(11)
		19: ValueRegs	constructor(value_reg, [34], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op_swap, [17], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecMisc, [25, 31, 15, 16])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1919
		../../codegen/src/isa/aarch64/inst.isle line 3408
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [45], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecMisc, [24, 34, 15, 16])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::VecMisc, [28, 42, 37, 16])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1913
		../../codegen/src/isa/aarch64/inst.isle line 3398
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: IntCC	match_tuple(9, 0)
		13: Option(IntCC)	extractor(icmp_zero_cond, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: IntCC	match_some(13)
		19: ValueRegs	constructor(value_reg, [34], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op, [17], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecMisc, [25, 31, 15, 16])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1907
		../../codegen/src/isa/aarch64/inst.isle line 3408
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [45], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecMisc, [24, 34, 15, 16])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::VecMisc, [28, 42, 37, 16])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1901
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	constructor(ty_vector_float, [9], 0)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Value	match_tuple(7, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: FloatCC	match_tuple(7, 0)
		15: Cond	constructor(fp_cond_code, [14], 3)
		16: Reg	constructor(vec_cmp, [11, 13, 9, 15], 4)
		18: Option(InstOutput)	some(21)
		20: ValueRegs	constructor(value_reg, [16], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1896
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(ty_scalar_float, 9)
		11: Type	match_some(10)
		12: ScalarSize	constructor(scalar_size, [11], 1)
		13: Reg	constructor(put_in_reg, [8], 2)
		14: Value	match_tuple(7, 2)
		15: Reg	constructor(put_in_reg, [14], 3)
		17: FloatCC	match_tuple(7, 0)
		18: Cond	constructor(fp_cond_code, [17], 5)
		20: ValueRegs	constructor(with_flags, [27, 33], 7)
		21: InstOutput	constructor(output, [20], 8)
		22: Option(InstOutput)	some(21)
		26: MInst	make_variant(MInst::FpuCmp, [12, 13, 15])
		27: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [26])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::CSet, [30, 18])
		32: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [31, 32])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1890
		../../codegen/src/isa/aarch64/inst.isle line 3373
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: FloatCC	match_some(11)
		19: ValueRegs	constructor(value_reg, [34], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op_swap, [17], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecMisc, [25, 31, 15, 16])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1884
		../../codegen/src/isa/aarch64/inst.isle line 3378
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [45], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecMisc, [24, 34, 15, 16])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::VecMisc, [28, 42, 37, 16])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 3368
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: FloatCC	match_tuple(9, 0)
		13: Option(FloatCC)	extractor(fcmp_zero_cond, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: FloatCC	match_some(13)
		19: ValueRegs	constructor(value_reg, [34], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op, [17], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecMisc, [25, 31, 15, 16])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1872
		../../codegen/src/isa/aarch64/inst.isle line 3378
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [45], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecMisc, [24, 34, 15, 16])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::VecMisc, [28, 42, 37, 16])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1866
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ireduce, 7)
		9: Value	match_some(8)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(value_reg, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1858
		../../codegen/src/isa/aarch64/inst.isle line 2803
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(bitselect, 7)
		9: (Value, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_some(6)
		19: Option(InstOutput)	some(29)
		24: VectorSize	constructor(vector_size, [16], 1)
		25: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		28: ValueRegs	constructor(value_reg, [39], 1)
		29: InstOutput	constructor(output, [28], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::VecRRRMod, [25, 36, 11, 13, 15, 24])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1852
		../../codegen/src/isa/aarch64/inst.isle line 2713
		../../codegen/src/isa/aarch64/inst.isle line 2731
		../../codegen/src/isa/aarch64/inst.isle line 2699
		output_reg
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(bitselect, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: (Value, Value, Value)	match_some(6)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: Reg	constructor(put_in_reg, [12], 5)
		21: Option(InstOutput)	some(39)
		25: ALUOp	make_variant(ALUOp::And, [])
		30: ALUOp	make_variant(ALUOp::AndNot, [])
		35: ALUOp	make_variant(ALUOp::Orr, [])
		38: ValueRegs	constructor(value_reg, [69], 1)
		39: InstOutput	constructor(output, [38], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [7], 2)
		47: MInst	make_variant(MInst::AluRRR, [25, 46, 45, 11, 13])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: OperandSize	constructor(operand_size, [7], 2)
		57: MInst	make_variant(MInst::AluRRR, [30, 56, 55, 16, 17])
		58: Unit	constructor(emit, [57], 3)
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [7], 2)
		67: MInst	make_variant(MInst::AluRRR, [35, 66, 65, 49, 59])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1847
		../../codegen/src/isa/aarch64/inst.isle line 2798
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Cnt, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1839
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2278
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		16: u8	const_int(1, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		19: VectorSize	make_variant(VectorSize::Size8x16, [])
		22: u8	const_int(0, u8)
		23: ScalarSize	make_variant(ScalarSize::Size8, [])
		25: Type	const_prim(I64)
		26: ImmExtend	make_variant(ImmExtend::Zero, [])
		27: u64	const_int(0, u64)
		28: Reg	constructor(imm, [25, 26, 27], 9)
		29: ValueRegs	constructor(value_regs, [63, 28], 10)
		30: InstOutput	constructor(output, [29], 11)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::MovToFpu, [35, 11, 12])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::MovToVec, [44, 38, 15, 16, 17])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: VecMisc2	make_variant(VecMisc2::Cnt, [])
		54: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::MovFromVec, [60, 79, 22, 23])
		62: Unit	constructor(emit, [61], 2)
		63: Reg	constructor(writable_reg_to_reg, [60], 0)
		67: Type	const_prim(I8X16)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: MInst	make_variant(MInst::VecMisc, [50, 68, 47, 19])
		70: Unit	constructor(emit, [69], 2)
		71: Reg	constructor(writable_reg_to_reg, [68], 0)
		75: Type	const_prim(I8X16)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::VecLanes, [54, 76, 71, 19])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 31
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1833
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(45)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovToFpu, [23, 9, 10])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		29: VecMisc2	make_variant(VecMisc2::Cnt, [])
		33: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::MovFromVec, [39, 61, 15, 16])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
		49: Type	const_prim(I8X16)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::VecMisc, [29, 50, 26, 12])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		57: Type	const_prim(I8X16)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::VecLanes, [33, 58, 53, 12])
		60: Unit	constructor(emit, [59], 2)
		61: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1827
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(45)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovToFpu, [23, 9, 10])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		29: VecMisc2	make_variant(VecMisc2::Cnt, [])
		33: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::MovFromVec, [39, 61, 15, 16])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
		49: Type	const_prim(I8X16)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::VecMisc, [29, 50, 26, 12])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		57: Type	const_prim(I8X16)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::VecLanes, [33, 58, 53, 12])
		60: Unit	constructor(emit, [59], 2)
		61: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1821
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(46)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovToFpu, [23, 9, 10])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		29: VecMisc2	make_variant(VecMisc2::Cnt, [])
		34: VecALUOp	make_variant(VecALUOp::Addp, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::MovFromVec, [40, 63, 15, 16])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
		50: Type	const_prim(I8X16)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::VecMisc, [29, 51, 26, 12])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		59: Type	const_prim(I8X16)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::VecRRR, [34, 60, 54, 54, 12])
		62: Unit	constructor(emit, [61], 2)
		63: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1815
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size8, [])
		18: Option(InstOutput)	some(40)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::MovToFpu, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		28: VecMisc2	make_variant(VecMisc2::Cnt, [])
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::MovFromVec, [34, 48, 14, 15])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecMisc, [28, 45, 25, 12])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1793
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bmask, 5)
		7: Value	match_some(6)
		8: ValueRegs	constructor(put_in_regs, [7], 1)
		9: Type	match_tuple(4, 0)
		10: Type	extractor(value_type, 7)
		11: ValueRegs	constructor(lower_bmask, [9, 10, 8], 2)
		12: InstOutput	constructor(output, [11], 3)
		13: Option(InstOutput)	some(12)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1785
		../../codegen/src/isa/aarch64/inst.isle line 2788
		../../codegen/src/isa/aarch64/inst.isle line 2788
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(1, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: Type	const_prim(I64)
		14: ValueRegs	constructor(put_in_regs, [8], 4)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		18: ValueRegs	constructor(value_regs, [37, 46], 7)
		19: InstOutput	constructor(output, [18], 8)
		20: Option(InstOutput)	some(19)
		23: BitOp	make_variant(BitOp::Rev64, [])
		27: BitOp	make_variant(BitOp::Rev64, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [12], 2)
		35: MInst	make_variant(MInst::BitRR, [23, 34, 33, 11])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: OperandSize	constructor(operand_size, [12], 2)
		44: MInst	make_variant(MInst::BitRR, [27, 43, 42, 16])
		45: Unit	constructor(emit, [44], 3)
		46: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1782
		../../codegen/src/isa/aarch64/inst.isle line 2788
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I64)
		13: Option(InstOutput)	some(20)
		16: BitOp	make_variant(BitOp::Rev64, [])
		19: ValueRegs	constructor(value_reg, [29], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [10], 2)
		27: MInst	make_variant(MInst::BitRR, [16, 26, 25, 9])
		28: Unit	constructor(emit, [27], 3)
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1779
		../../codegen/src/isa/aarch64/inst.isle line 2785
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		13: Option(InstOutput)	some(20)
		16: BitOp	make_variant(BitOp::Rev32, [])
		19: ValueRegs	constructor(value_reg, [29], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [10], 2)
		27: MInst	make_variant(MInst::BitRR, [16, 26, 25, 9])
		28: Unit	constructor(emit, [27], 3)
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1776
		../../codegen/src/isa/aarch64/inst.isle line 2782
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I16)
		13: Option(InstOutput)	some(20)
		16: BitOp	make_variant(BitOp::Rev16, [])
		19: ValueRegs	constructor(value_reg, [29], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [10], 2)
		27: MInst	make_variant(MInst::BitRR, [16, 26, 25, 9])
		28: Unit	constructor(emit, [27], 3)
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1771
		../../codegen/src/isa/aarch64/inst.isle line 2777
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(cls, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		12: Option(InstOutput)	some(19)
		15: BitOp	make_variant(BitOp::Cls, [])
		18: ValueRegs	constructor(value_reg, [28], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: OperandSize	constructor(operand_size, [9], 2)
		26: MInst	make_variant(MInst::BitRR, [15, 25, 24, 8])
		27: Unit	constructor(emit, [26], 3)
		28: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1757
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2793
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2123
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
		add_to_alu_rrr
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2117
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: usize	const_int(1, usize)
		13: Reg	constructor(value_regs_get, [9, 12], 3)
		14: Type	const_prim(I64)
		18: u8	const_int(63, u8)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 7)
		22: Imm12	constructor(u8_into_imm12, [18], 10)
		24: Reg	constructor(zero_reg, [], 12)
		25: Cond	make_variant(Cond::Eq, [])
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	const_int(0, u64)
		31: Reg	constructor(imm, [14, 29, 30], 16)
		32: ValueRegs	constructor(value_regs, [146, 31], 17)
		33: InstOutput	constructor(output, [32], 18)
		34: Option(InstOutput)	some(33)
		37: BitOp	make_variant(BitOp::Cls, [])
		41: BitOp	make_variant(BitOp::Cls, [])
		46: ALUOp	make_variant(ALUOp::EorNot, [])
		51: ALUOp	make_variant(ALUOp::Lsr, [])
		57: ALUOp3	make_variant(ALUOp3::MAdd, [])
		61: OperandSize	make_variant(OperandSize::Size64, [])
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::CSel, [67, 25, 129, 24])
		69: Reg	constructor(writable_reg_to_reg, [67], 0)
		70: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [68, 69])
		73: ValueRegs	constructor(with_flags, [136, 70], 1)
		74: usize	const_int(0, usize)
		75: Reg	constructor(value_regs_get, [73, 74], 2)
		79: ALUOp	make_variant(ALUOp::Add, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: OperandSize	constructor(operand_size, [14], 2)
		87: MInst	make_variant(MInst::BitRR, [37, 86, 85, 11])
		88: Unit	constructor(emit, [87], 3)
		89: Reg	constructor(writable_reg_to_reg, [85], 0)
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: OperandSize	constructor(operand_size, [14], 2)
		96: MInst	make_variant(MInst::BitRR, [41, 95, 94, 13])
		97: Unit	constructor(emit, [96], 3)
		98: Reg	constructor(writable_reg_to_reg, [94], 0)
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: OperandSize	constructor(operand_size, [14], 2)
		106: MInst	make_variant(MInst::AluRRR, [46, 105, 104, 13, 11])
		107: Unit	constructor(emit, [106], 3)
		108: Reg	constructor(writable_reg_to_reg, [104], 0)
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: OperandSize	constructor(operand_size, [14], 2)
		116: MInst	make_variant(MInst::AluRRImmShift, [51, 115, 114, 108, 19])
		117: Unit	constructor(emit, [116], 3)
		118: Reg	constructor(writable_reg_to_reg, [114], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: OperandSize	constructor(operand_size, [14], 2)
		127: MInst	make_variant(MInst::AluRRRR, [57, 126, 125, 89, 118, 118])
		128: Unit	constructor(emit, [127], 3)
		129: Reg	constructor(writable_reg_to_reg, [125], 0)
		133: WritableReg	constructor(writable_zero_reg, [], 1)
		134: ALUOp	make_variant(ALUOp::SubS, [])
		135: MInst	make_variant(MInst::AluRRImm12, [134, 61, 133, 98, 22])
		136: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [135])
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: OperandSize	constructor(operand_size, [14], 2)
		144: MInst	make_variant(MInst::AluRRR, [79, 143, 142, 75, 98])
		145: Unit	constructor(emit, [144], 3)
		146: Reg	constructor(writable_reg_to_reg, [142], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 34
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1745
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1745
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1745
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Cls, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [65], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 20, 21, 23, 24])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [10], 2)
		53: MInst	make_variant(MInst::BitRR, [28, 52, 51, 46])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [10], 2)
		63: MInst	make_variant(MInst::AluRRImm12, [33, 62, 61, 55, 13])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1742
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1742
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1742
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Cls, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [65], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 20, 21, 23, 24])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [10], 2)
		53: MInst	make_variant(MInst::BitRR, [28, 52, 51, 46])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [10], 2)
		63: MInst	make_variant(MInst::AluRRImm12, [33, 62, 61, 55, 13])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1737
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2772
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(ctz, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		13: Option(InstOutput)	some(24)
		16: BitOp	make_variant(BitOp::RBit, [])
		20: BitOp	make_variant(BitOp::Clz, [])
		23: ValueRegs	constructor(value_reg, [42], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: OperandSize	constructor(operand_size, [9], 2)
		31: MInst	make_variant(MInst::BitRR, [16, 30, 29, 8])
		32: Unit	constructor(emit, [31], 3)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: OperandSize	constructor(operand_size, [9], 2)
		40: MInst	make_variant(MInst::BitRR, [20, 39, 38, 33])
		41: Unit	constructor(emit, [40], 3)
		42: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1731
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/lower.isle line 1713
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: Type	const_prim(I64)
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		17: ValueRegs	constructor(value_regs, [62, 53], 6)
		19: InstOutput	constructor(output, [44], 8)
		20: Option(InstOutput)	some(19)
		23: BitOp	make_variant(BitOp::RBit, [])
		27: BitOp	make_variant(BitOp::RBit, [])
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [17, 30], 1)
		32: Type	const_prim(I64)
		34: usize	const_int(0, usize)
		35: Reg	constructor(value_regs_get, [17, 34], 3)
		37: u8	const_int(6, u8)
		38: ImmShift	constructor(imm_shift_from_u8, [37], 5)
		41: ImmExtend	make_variant(ImmExtend::Zero, [])
		42: u64	const_int(0, u64)
		43: Reg	constructor(imm, [32, 41, 42], 8)
		44: ValueRegs	constructor(value_regs, [120, 43], 9)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [12], 2)
		51: MInst	make_variant(MInst::BitRR, [23, 50, 49, 11])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [12], 2)
		60: MInst	make_variant(MInst::BitRR, [27, 59, 58, 15])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		65: BitOp	make_variant(BitOp::Clz, [])
		69: BitOp	make_variant(BitOp::Clz, [])
		74: ALUOp	make_variant(ALUOp::Lsr, [])
		80: ALUOp3	make_variant(ALUOp3::MAdd, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: OperandSize	constructor(operand_size, [32], 2)
		88: MInst	make_variant(MInst::BitRR, [65, 87, 86, 31])
		89: Unit	constructor(emit, [88], 3)
		90: Reg	constructor(writable_reg_to_reg, [86], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: OperandSize	constructor(operand_size, [32], 2)
		97: MInst	make_variant(MInst::BitRR, [69, 96, 95, 35])
		98: Unit	constructor(emit, [97], 3)
		99: Reg	constructor(writable_reg_to_reg, [95], 0)
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: OperandSize	constructor(operand_size, [32], 2)
		107: MInst	make_variant(MInst::AluRRImmShift, [74, 106, 105, 90, 38])
		108: Unit	constructor(emit, [107], 3)
		109: Reg	constructor(writable_reg_to_reg, [105], 0)
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: OperandSize	constructor(operand_size, [32], 2)
		118: MInst	make_variant(MInst::AluRRRR, [80, 117, 116, 99, 109, 90])
		119: Unit	constructor(emit, [118], 3)
		120: Reg	constructor(writable_reg_to_reg, [116], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1728
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 2772
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u64	const_int(32768, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 3)
		17: Option(InstOutput)	some(33)
		20: BitOp	make_variant(BitOp::RBit, [])
		25: ALUOp	make_variant(ALUOp::Orr, [])
		29: BitOp	make_variant(BitOp::Clz, [])
		32: ValueRegs	constructor(value_reg, [61], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: OperandSize	constructor(operand_size, [10], 2)
		40: MInst	make_variant(MInst::BitRR, [20, 39, 38, 9])
		41: Unit	constructor(emit, [40], 3)
		42: Reg	constructor(writable_reg_to_reg, [38], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: OperandSize	constructor(operand_size, [10], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [25, 49, 48, 42, 13])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [10], 2)
		59: MInst	make_variant(MInst::BitRR, [29, 58, 57, 52])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1725
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 2772
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u64	const_int(8388608, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 3)
		17: Option(InstOutput)	some(33)
		20: BitOp	make_variant(BitOp::RBit, [])
		25: ALUOp	make_variant(ALUOp::Orr, [])
		29: BitOp	make_variant(BitOp::Clz, [])
		32: ValueRegs	constructor(value_reg, [61], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: OperandSize	constructor(operand_size, [10], 2)
		40: MInst	make_variant(MInst::BitRR, [20, 39, 38, 9])
		41: Unit	constructor(emit, [40], 3)
		42: Reg	constructor(writable_reg_to_reg, [38], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: OperandSize	constructor(operand_size, [10], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [25, 49, 48, 42, 13])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [10], 2)
		59: MInst	make_variant(MInst::BitRR, [29, 58, 57, 52])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1704
		../../codegen/src/isa/aarch64/inst.isle line 2772
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(clz, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		12: Option(InstOutput)	some(19)
		15: BitOp	make_variant(BitOp::Clz, [])
		18: ValueRegs	constructor(value_reg, [28], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: OperandSize	constructor(operand_size, [9], 2)
		26: MInst	make_variant(MInst::BitRR, [15, 25, 24, 8])
		27: Unit	constructor(emit, [26], 3)
		28: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1701
		../../codegen/src/isa/aarch64/lower.isle line 1713
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		11: InstOutput	constructor(output, [28], 3)
		12: Option(InstOutput)	some(11)
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 1)
		16: Type	const_prim(I64)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [9, 18], 3)
		21: u8	const_int(6, u8)
		22: ImmShift	constructor(imm_shift_from_u8, [21], 5)
		25: ImmExtend	make_variant(ImmExtend::Zero, [])
		26: u64	const_int(0, u64)
		27: Reg	constructor(imm, [16, 25, 26], 8)
		28: ValueRegs	constructor(value_regs, [86, 27], 9)
		31: BitOp	make_variant(BitOp::Clz, [])
		35: BitOp	make_variant(BitOp::Clz, [])
		40: ALUOp	make_variant(ALUOp::Lsr, [])
		46: ALUOp3	make_variant(ALUOp3::MAdd, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: OperandSize	constructor(operand_size, [16], 2)
		54: MInst	make_variant(MInst::BitRR, [31, 53, 52, 15])
		55: Unit	constructor(emit, [54], 3)
		56: Reg	constructor(writable_reg_to_reg, [52], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [16], 2)
		63: MInst	make_variant(MInst::BitRR, [35, 62, 61, 19])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: OperandSize	constructor(operand_size, [16], 2)
		73: MInst	make_variant(MInst::AluRRImmShift, [40, 72, 71, 56, 22])
		74: Unit	constructor(emit, [73], 3)
		75: Reg	constructor(writable_reg_to_reg, [71], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: OperandSize	constructor(operand_size, [16], 2)
		84: MInst	make_variant(MInst::AluRRRR, [46, 83, 82, 65, 75, 56])
		85: Unit	constructor(emit, [84], 3)
		86: Reg	constructor(writable_reg_to_reg, [82], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1698
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1698
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1698
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Clz, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [65], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 20, 21, 23, 24])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [10], 2)
		53: MInst	make_variant(MInst::BitRR, [28, 52, 51, 46])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [10], 2)
		63: MInst	make_variant(MInst::AluRRImm12, [33, 62, 61, 55, 13])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1695
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1695
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [50], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [10], 2)
		38: MInst	make_variant(MInst::BitRR, [22, 37, 36, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [10], 2)
		48: MInst	make_variant(MInst::AluRRImm12, [27, 47, 46, 40, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1695
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Clz, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [65], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 20, 21, 23, 24])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [10], 2)
		53: MInst	make_variant(MInst::BitRR, [28, 52, 51, 46])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: OperandSize	constructor(operand_size, [10], 2)
		63: MInst	make_variant(MInst::AluRRImm12, [33, 62, 61, 55, 13])
		64: Unit	constructor(emit, [63], 3)
		65: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1689
		../../codegen/src/isa/aarch64/inst.isle line 2767
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bitrev, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		12: Option(InstOutput)	some(19)
		15: BitOp	make_variant(BitOp::RBit, [])
		18: ValueRegs	constructor(value_reg, [28], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: OperandSize	constructor(operand_size, [9], 2)
		26: MInst	make_variant(MInst::BitRR, [15, 25, 24, 8])
		27: Unit	constructor(emit, [26], 3)
		28: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1683
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: Type	const_prim(I64)
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		17: ValueRegs	constructor(value_regs, [45, 36], 6)
		18: InstOutput	constructor(output, [17], 7)
		19: Option(InstOutput)	some(18)
		22: BitOp	make_variant(BitOp::RBit, [])
		26: BitOp	make_variant(BitOp::RBit, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [12], 2)
		34: MInst	make_variant(MInst::BitRR, [22, 33, 32, 11])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [12], 2)
		43: MInst	make_variant(MInst::BitRR, [26, 42, 41, 15])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1680
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2667
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		16: Option(InstOutput)	some(28)
		19: BitOp	make_variant(BitOp::RBit, [])
		24: ALUOp	make_variant(ALUOp::Lsr, [])
		27: ValueRegs	constructor(value_reg, [47], 1)
		28: InstOutput	constructor(output, [27], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [10], 2)
		35: MInst	make_variant(MInst::BitRR, [19, 34, 33, 9])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [10], 2)
		45: MInst	make_variant(MInst::AluRRImmShift, [24, 44, 43, 37, 13])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1674
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2667
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		16: Option(InstOutput)	some(28)
		19: BitOp	make_variant(BitOp::RBit, [])
		24: ALUOp	make_variant(ALUOp::Lsr, [])
		27: ValueRegs	constructor(value_reg, [47], 1)
		28: InstOutput	constructor(output, [27], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [10], 2)
		35: MInst	make_variant(MInst::BitRR, [19, 34, 33, 9])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [10], 2)
		45: MInst	make_variant(MInst::AluRRImmShift, [24, 44, 43, 37, 13])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1659
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/lower.isle line 1449
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2699
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I64)
		16: ImmExtend	make_variant(ImmExtend::Zero, [])
		17: u64	const_int(128, u64)
		18: Reg	constructor(imm, [15, 16, 17], 4)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [62, 22], 8)
		24: Reg	constructor(value_regs_get, [88, 22], 9)
		26: Reg	constructor(value_regs_get, [62, 13], 11)
		27: Reg	constructor(value_regs_get, [88, 13], 12)
		29: ValueRegs	constructor(value_regs, [252, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		35: ALUOp	make_variant(ALUOp::Sub, [])
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [10, 39], 1)
		41: usize	const_int(1, usize)
		42: Reg	constructor(value_regs_get, [10, 41], 2)
		43: Type	const_prim(I64)
		46: Reg	constructor(zero_reg, [], 5)
		47: Type	const_prim(I32)
		49: u8	const_int(1, u8)
		50: ImmShift	constructor(imm_shift_from_u8, [49], 7)
		54: u64	const_int(64, u64)
		55: ImmLogic	constructor(u64_into_imm_logic, [43, 54], 11)
		57: Cond	make_variant(Cond::Ne, [])
		59: Reg	constructor(zero_reg, [], 14)
		62: ValueRegs	constructor(with_flags, [146, 170], 17)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [10, 65], 1)
		67: usize	const_int(1, usize)
		68: Reg	constructor(value_regs_get, [10, 67], 2)
		69: Type	const_prim(I64)
		72: Reg	constructor(zero_reg, [], 5)
		73: Type	const_prim(I32)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		80: u64	const_int(64, u64)
		81: ImmLogic	constructor(u64_into_imm_logic, [69, 80], 11)
		83: Reg	constructor(zero_reg, [], 13)
		84: Cond	make_variant(Cond::Ne, [])
		88: ValueRegs	constructor(with_flags, [208, 232], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: OperandSize	constructor(operand_size, [15], 2)
		106: MInst	make_variant(MInst::AluRRR, [35, 105, 104, 18, 14])
		107: Unit	constructor(emit, [106], 3)
		108: Reg	constructor(writable_reg_to_reg, [104], 0)
		112: ALUOp	make_variant(ALUOp::Lsr, [])
		117: ALUOp	make_variant(ALUOp::Lsr, [])
		122: ALUOp	make_variant(ALUOp::OrrNot, [])
		127: ALUOp	make_variant(ALUOp::Lsl, [])
		132: ALUOp	make_variant(ALUOp::Lsl, [])
		137: ALUOp	make_variant(ALUOp::Orr, [])
		142: OperandSize	constructor(operand_size, [43], 1)
		143: WritableReg	constructor(writable_zero_reg, [], 2)
		144: ALUOp	make_variant(ALUOp::AndS, [])
		145: MInst	make_variant(MInst::AluRRImmLogic, [144, 142, 143, 14, 55])
		146: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [145])
		150: Type	const_prim(I64)
		151: WritableReg	constructor(temp_writable_reg, [150], 1)
		152: MInst	make_variant(MInst::CSel, [151, 57, 272, 312])
		153: Reg	constructor(writable_reg_to_reg, [151], 0)
		154: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [152, 153])
		158: Type	const_prim(I64)
		159: WritableReg	constructor(temp_writable_reg, [158], 1)
		160: MInst	make_variant(MInst::CSel, [159, 57, 59, 272])
		161: Reg	constructor(writable_reg_to_reg, [159], 0)
		162: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [160, 161])
		165: Reg	match_variant(154, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		166: Reg	match_variant(162, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		167: ValueRegs	constructor(value_regs, [165, 166], 1)
		168: MInst	match_variant(154, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		169: MInst	match_variant(162, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		170: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [168, 169, 167])
		174: ALUOp	make_variant(ALUOp::Lsl, [])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: ALUOp	make_variant(ALUOp::OrrNot, [])
		189: ALUOp	make_variant(ALUOp::Lsr, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::Orr, [])
		204: OperandSize	constructor(operand_size, [69], 1)
		205: WritableReg	constructor(writable_zero_reg, [], 2)
		206: ALUOp	make_variant(ALUOp::AndS, [])
		207: MInst	make_variant(MInst::AluRRImmLogic, [206, 204, 205, 108, 81])
		208: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [207])
		212: Type	const_prim(I64)
		213: WritableReg	constructor(temp_writable_reg, [212], 1)
		214: MInst	make_variant(MInst::CSel, [213, 84, 83, 322])
		215: Reg	constructor(writable_reg_to_reg, [213], 0)
		216: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [214, 215])
		220: Type	const_prim(I64)
		221: WritableReg	constructor(temp_writable_reg, [220], 1)
		222: MInst	make_variant(MInst::CSel, [221, 84, 322, 372])
		223: Reg	constructor(writable_reg_to_reg, [221], 0)
		224: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [222, 223])
		227: Reg	match_variant(216, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: Reg	match_variant(224, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		229: ValueRegs	constructor(value_regs, [227, 228], 1)
		230: MInst	match_variant(216, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		231: MInst	match_variant(224, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		232: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [230, 231, 229])
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: OperandSize	constructor(operand_size, [15], 2)
		240: MInst	make_variant(MInst::AluRRR, [92, 239, 238, 23, 24])
		241: Unit	constructor(emit, [240], 3)
		242: Reg	constructor(writable_reg_to_reg, [238], 0)
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: OperandSize	constructor(operand_size, [15], 2)
		250: MInst	make_variant(MInst::AluRRR, [97, 249, 248, 26, 27])
		251: Unit	constructor(emit, [250], 3)
		252: Reg	constructor(writable_reg_to_reg, [248], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: OperandSize	constructor(operand_size, [43], 2)
		260: MInst	make_variant(MInst::AluRRR, [112, 259, 258, 40, 14])
		261: Unit	constructor(emit, [260], 3)
		262: Reg	constructor(writable_reg_to_reg, [258], 0)
		267: Type	const_prim(I64)
		268: WritableReg	constructor(temp_writable_reg, [267], 1)
		269: OperandSize	constructor(operand_size, [43], 2)
		270: MInst	make_variant(MInst::AluRRR, [117, 269, 268, 42, 14])
		271: Unit	constructor(emit, [270], 3)
		272: Reg	constructor(writable_reg_to_reg, [268], 0)
		277: Type	const_prim(I64)
		278: WritableReg	constructor(temp_writable_reg, [277], 1)
		279: OperandSize	constructor(operand_size, [47], 2)
		280: MInst	make_variant(MInst::AluRRR, [122, 279, 278, 46, 14])
		281: Unit	constructor(emit, [280], 3)
		282: Reg	constructor(writable_reg_to_reg, [278], 0)
		287: Type	const_prim(I64)
		288: WritableReg	constructor(temp_writable_reg, [287], 1)
		289: OperandSize	constructor(operand_size, [43], 2)
		290: MInst	make_variant(MInst::AluRRImmShift, [127, 289, 288, 42, 50])
		291: Unit	constructor(emit, [290], 3)
		292: Reg	constructor(writable_reg_to_reg, [288], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: OperandSize	constructor(operand_size, [43], 2)
		300: MInst	make_variant(MInst::AluRRR, [132, 299, 298, 292, 282])
		301: Unit	constructor(emit, [300], 3)
		302: Reg	constructor(writable_reg_to_reg, [298], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: OperandSize	constructor(operand_size, [43], 2)
		310: MInst	make_variant(MInst::AluRRR, [137, 309, 308, 262, 302])
		311: Unit	constructor(emit, [310], 3)
		312: Reg	constructor(writable_reg_to_reg, [308], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: OperandSize	constructor(operand_size, [69], 2)
		320: MInst	make_variant(MInst::AluRRR, [174, 319, 318, 66, 108])
		321: Unit	constructor(emit, [320], 3)
		322: Reg	constructor(writable_reg_to_reg, [318], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: OperandSize	constructor(operand_size, [69], 2)
		330: MInst	make_variant(MInst::AluRRR, [179, 329, 328, 68, 108])
		331: Unit	constructor(emit, [330], 3)
		332: Reg	constructor(writable_reg_to_reg, [328], 0)
		337: Type	const_prim(I64)
		338: WritableReg	constructor(temp_writable_reg, [337], 1)
		339: OperandSize	constructor(operand_size, [73], 2)
		340: MInst	make_variant(MInst::AluRRR, [184, 339, 338, 72, 108])
		341: Unit	constructor(emit, [340], 3)
		342: Reg	constructor(writable_reg_to_reg, [338], 0)
		347: Type	const_prim(I64)
		348: WritableReg	constructor(temp_writable_reg, [347], 1)
		349: OperandSize	constructor(operand_size, [69], 2)
		350: MInst	make_variant(MInst::AluRRImmShift, [189, 349, 348, 66, 76])
		351: Unit	constructor(emit, [350], 3)
		352: Reg	constructor(writable_reg_to_reg, [348], 0)
		357: Type	const_prim(I64)
		358: WritableReg	constructor(temp_writable_reg, [357], 1)
		359: OperandSize	constructor(operand_size, [69], 2)
		360: MInst	make_variant(MInst::AluRRR, [194, 359, 358, 352, 342])
		361: Unit	constructor(emit, [360], 3)
		362: Reg	constructor(writable_reg_to_reg, [358], 0)
		367: Type	const_prim(I64)
		368: WritableReg	constructor(temp_writable_reg, [367], 1)
		369: OperandSize	constructor(operand_size, [69], 2)
		370: MInst	make_variant(MInst::AluRRR, [199, 369, 368, 332, 362])
		371: Unit	constructor(emit, [370], 3)
		372: Reg	constructor(writable_reg_to_reg, [368], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		154:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		162:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		216:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		224:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
	]
	result = 31
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1610
		../../codegen/src/isa/aarch64/inst.isle line 2762
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		21: Option(InstOutput)	some(29)
		25: ALUOp	make_variant(ALUOp::RotR, [])
		28: ValueRegs	constructor(value_reg, [39], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: OperandSize	constructor(operand_size, [13], 2)
		37: MInst	make_variant(MInst::AluRRImmShift, [25, 36, 35, 17, 18])
		38: Unit	constructor(emit, [37], 3)
		39: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/isa/aarch64/inst.isle line 2762
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		21: Option(InstOutput)	some(29)
		25: ALUOp	make_variant(ALUOp::RotR, [])
		28: ValueRegs	constructor(value_reg, [39], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: OperandSize	constructor(operand_size, [13], 2)
		37: MInst	make_variant(MInst::AluRRImmShift, [25, 36, 35, 17, 18])
		38: Unit	constructor(emit, [37], 3)
		39: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1600
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/lower.isle line 1648
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(36)
		24: Type	extractor(value_type, 17)
		25: Reg	constructor(put_in_reg, [17], 1)
		29: Type	const_prim(I32)
		31: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		35: ValueRegs	constructor(value_reg, [81], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: ALUOp	make_variant(ALUOp::Lsr, [])
		45: ALUOp	make_variant(ALUOp::Lsl, [])
		50: ALUOp	make_variant(ALUOp::Orr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [29], 2)
		59: MInst	make_variant(MInst::AluRRImmShift, [40, 58, 57, 25, 19])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [29], 2)
		69: MInst	make_variant(MInst::AluRRImmShift, [45, 68, 67, 25, 31])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: OperandSize	constructor(operand_size, [29], 2)
		79: MInst	make_variant(MInst::AluRRR, [50, 78, 77, 71, 61])
		80: Unit	constructor(emit, [79], 3)
		81: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	const_prim(I64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1600
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/lower.isle line 1648
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(36)
		24: Type	extractor(value_type, 17)
		25: Reg	constructor(put_in_reg, [17], 1)
		29: Type	const_prim(I32)
		31: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		35: ValueRegs	constructor(value_reg, [81], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: ALUOp	make_variant(ALUOp::Lsr, [])
		45: ALUOp	make_variant(ALUOp::Lsl, [])
		50: ALUOp	make_variant(ALUOp::Orr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [29], 2)
		59: MInst	make_variant(MInst::AluRRImmShift, [40, 58, 57, 25, 19])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [29], 2)
		69: MInst	make_variant(MInst::AluRRImmShift, [45, 68, 67, 25, 31])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: OperandSize	constructor(operand_size, [29], 2)
		79: MInst	make_variant(MInst::AluRRR, [50, 78, 77, 71, 61])
		80: Unit	constructor(emit, [79], 3)
		81: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	const_prim(I32)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1600
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/lower.isle line 1648
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(42)
		24: Type	extractor(value_type, 17)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [17], 1)
		27: bool	const_prim(false)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(32, u8)
		35: Type	const_prim(I32)
		37: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		41: ValueRegs	constructor(value_reg, [96], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::Extend, [48, 26, 27, 29, 30])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		55: ALUOp	make_variant(ALUOp::Lsr, [])
		60: ALUOp	make_variant(ALUOp::Lsl, [])
		65: ALUOp	make_variant(ALUOp::Orr, [])
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: OperandSize	constructor(operand_size, [35], 2)
		74: MInst	make_variant(MInst::AluRRImmShift, [55, 73, 72, 51, 19])
		75: Unit	constructor(emit, [74], 3)
		76: Reg	constructor(writable_reg_to_reg, [72], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: OperandSize	constructor(operand_size, [35], 2)
		84: MInst	make_variant(MInst::AluRRImmShift, [60, 83, 82, 51, 37])
		85: Unit	constructor(emit, [84], 3)
		86: Reg	constructor(writable_reg_to_reg, [82], 0)
		91: Type	const_prim(I64)
		92: WritableReg	constructor(temp_writable_reg, [91], 1)
		93: OperandSize	constructor(operand_size, [35], 2)
		94: MInst	make_variant(MInst::AluRRR, [65, 93, 92, 86, 76])
		95: Unit	constructor(emit, [94], 3)
		96: Reg	constructor(writable_reg_to_reg, [92], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1596
		../../codegen/src/isa/aarch64/inst.isle line 2759
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I64)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::RotR, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [15], 2)
		34: MInst	make_variant(MInst::AluRRR, [22, 33, 32, 10, 14])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1592
		../../codegen/src/isa/aarch64/inst.isle line 2759
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I32)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::RotR, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [15], 2)
		34: MInst	make_variant(MInst::AluRRR, [22, 33, 32, 10, 14])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/lower.isle line 1627
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: Type	match_some(6)
		19: Option(InstOutput)	some(39)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		26: ImmLogic	constructor(rotr_mask, [16], 1)
		27: Type	const_prim(I32)
		29: u8	constructor(ty_bits, [16], 0)
		30: Imm12	constructor(u8_into_imm12, [29], 3)
		32: Reg	constructor(zero_reg, [], 5)
		38: ValueRegs	constructor(value_reg, [129], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: ALUOp	make_variant(ALUOp::And, [])
		48: ALUOp	make_variant(ALUOp::Sub, [])
		53: ALUOp	make_variant(ALUOp::Sub, [])
		58: ALUOp	make_variant(ALUOp::Lsr, [])
		63: ALUOp	make_variant(ALUOp::Lsl, [])
		68: ALUOp	make_variant(ALUOp::Orr, [])
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: OperandSize	constructor(operand_size, [27], 2)
		77: MInst	make_variant(MInst::AluRRImmLogic, [43, 76, 75, 15, 26])
		78: Unit	constructor(emit, [77], 3)
		79: Reg	constructor(writable_reg_to_reg, [75], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: OperandSize	constructor(operand_size, [27], 2)
		87: MInst	make_variant(MInst::AluRRImm12, [48, 86, 85, 79, 30])
		88: Unit	constructor(emit, [87], 3)
		89: Reg	constructor(writable_reg_to_reg, [85], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: OperandSize	constructor(operand_size, [27], 2)
		97: MInst	make_variant(MInst::AluRRR, [53, 96, 95, 32, 89])
		98: Unit	constructor(emit, [97], 3)
		99: Reg	constructor(writable_reg_to_reg, [95], 0)
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: OperandSize	constructor(operand_size, [27], 2)
		107: MInst	make_variant(MInst::AluRRR, [58, 106, 105, 22, 79])
		108: Unit	constructor(emit, [107], 3)
		109: Reg	constructor(writable_reg_to_reg, [105], 0)
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: OperandSize	constructor(operand_size, [27], 2)
		117: MInst	make_variant(MInst::AluRRR, [63, 116, 115, 22, 99])
		118: Unit	constructor(emit, [117], 3)
		119: Reg	constructor(writable_reg_to_reg, [115], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: OperandSize	constructor(operand_size, [27], 2)
		127: MInst	make_variant(MInst::AluRRR, [68, 126, 125, 119, 109])
		128: Unit	constructor(emit, [127], 3)
		129: Reg	constructor(writable_reg_to_reg, [125], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/lower.isle line 1627
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: Type	match_some(6)
		19: Option(InstOutput)	some(39)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		26: ImmLogic	constructor(rotr_mask, [16], 1)
		27: Type	const_prim(I32)
		29: u8	constructor(ty_bits, [16], 0)
		30: Imm12	constructor(u8_into_imm12, [29], 3)
		32: Reg	constructor(zero_reg, [], 5)
		38: ValueRegs	constructor(value_reg, [129], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: ALUOp	make_variant(ALUOp::And, [])
		48: ALUOp	make_variant(ALUOp::Sub, [])
		53: ALUOp	make_variant(ALUOp::Sub, [])
		58: ALUOp	make_variant(ALUOp::Lsr, [])
		63: ALUOp	make_variant(ALUOp::Lsl, [])
		68: ALUOp	make_variant(ALUOp::Orr, [])
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: OperandSize	constructor(operand_size, [27], 2)
		77: MInst	make_variant(MInst::AluRRImmLogic, [43, 76, 75, 15, 26])
		78: Unit	constructor(emit, [77], 3)
		79: Reg	constructor(writable_reg_to_reg, [75], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: OperandSize	constructor(operand_size, [27], 2)
		87: MInst	make_variant(MInst::AluRRImm12, [48, 86, 85, 79, 30])
		88: Unit	constructor(emit, [87], 3)
		89: Reg	constructor(writable_reg_to_reg, [85], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: OperandSize	constructor(operand_size, [27], 2)
		97: MInst	make_variant(MInst::AluRRR, [53, 96, 95, 32, 89])
		98: Unit	constructor(emit, [97], 3)
		99: Reg	constructor(writable_reg_to_reg, [95], 0)
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: OperandSize	constructor(operand_size, [27], 2)
		107: MInst	make_variant(MInst::AluRRR, [58, 106, 105, 22, 79])
		108: Unit	constructor(emit, [107], 3)
		109: Reg	constructor(writable_reg_to_reg, [105], 0)
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: OperandSize	constructor(operand_size, [27], 2)
		117: MInst	make_variant(MInst::AluRRR, [63, 116, 115, 22, 99])
		118: Unit	constructor(emit, [117], 3)
		119: Reg	constructor(writable_reg_to_reg, [115], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: OperandSize	constructor(operand_size, [27], 2)
		127: MInst	make_variant(MInst::AluRRR, [68, 126, 125, 119, 109])
		128: Unit	constructor(emit, [127], 3)
		129: Reg	constructor(writable_reg_to_reg, [125], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I32)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/lower.isle line 1627
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: Type	match_some(6)
		19: Option(InstOutput)	some(45)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(false)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(32, u8)
		32: ImmLogic	constructor(rotr_mask, [16], 1)
		33: Type	const_prim(I32)
		35: u8	constructor(ty_bits, [16], 0)
		36: Imm12	constructor(u8_into_imm12, [35], 3)
		38: Reg	constructor(zero_reg, [], 5)
		44: ValueRegs	constructor(value_reg, [144], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::Extend, [51, 23, 24, 26, 27])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: ALUOp	make_variant(ALUOp::And, [])
		63: ALUOp	make_variant(ALUOp::Sub, [])
		68: ALUOp	make_variant(ALUOp::Sub, [])
		73: ALUOp	make_variant(ALUOp::Lsr, [])
		78: ALUOp	make_variant(ALUOp::Lsl, [])
		83: ALUOp	make_variant(ALUOp::Orr, [])
		89: Type	const_prim(I64)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: OperandSize	constructor(operand_size, [33], 2)
		92: MInst	make_variant(MInst::AluRRImmLogic, [58, 91, 90, 15, 32])
		93: Unit	constructor(emit, [92], 3)
		94: Reg	constructor(writable_reg_to_reg, [90], 0)
		99: Type	const_prim(I64)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: OperandSize	constructor(operand_size, [33], 2)
		102: MInst	make_variant(MInst::AluRRImm12, [63, 101, 100, 94, 36])
		103: Unit	constructor(emit, [102], 3)
		104: Reg	constructor(writable_reg_to_reg, [100], 0)
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: OperandSize	constructor(operand_size, [33], 2)
		112: MInst	make_variant(MInst::AluRRR, [68, 111, 110, 38, 104])
		113: Unit	constructor(emit, [112], 3)
		114: Reg	constructor(writable_reg_to_reg, [110], 0)
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: OperandSize	constructor(operand_size, [33], 2)
		122: MInst	make_variant(MInst::AluRRR, [73, 121, 120, 54, 94])
		123: Unit	constructor(emit, [122], 3)
		124: Reg	constructor(writable_reg_to_reg, [120], 0)
		129: Type	const_prim(I64)
		130: WritableReg	constructor(temp_writable_reg, [129], 1)
		131: OperandSize	constructor(operand_size, [33], 2)
		132: MInst	make_variant(MInst::AluRRR, [78, 131, 130, 54, 114])
		133: Unit	constructor(emit, [132], 3)
		134: Reg	constructor(writable_reg_to_reg, [130], 0)
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: OperandSize	constructor(operand_size, [33], 2)
		142: MInst	make_variant(MInst::AluRRR, [83, 141, 140, 134, 124])
		143: Unit	constructor(emit, [142], 3)
		144: Reg	constructor(writable_reg_to_reg, [140], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1575
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/lower.isle line 1449
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2699
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I64)
		16: ImmExtend	make_variant(ImmExtend::Zero, [])
		17: u64	const_int(128, u64)
		18: Reg	constructor(imm, [15, 16, 17], 4)
		22: Reg	constructor(value_regs_get, [62, 13], 8)
		23: Reg	constructor(value_regs_get, [88, 13], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [62, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [242, 252], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		35: ALUOp	make_variant(ALUOp::Sub, [])
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [10, 39], 1)
		41: usize	const_int(1, usize)
		42: Reg	constructor(value_regs_get, [10, 41], 2)
		43: Type	const_prim(I64)
		46: Reg	constructor(zero_reg, [], 5)
		47: Type	const_prim(I32)
		49: u8	const_int(1, u8)
		50: ImmShift	constructor(imm_shift_from_u8, [49], 7)
		54: u64	const_int(64, u64)
		55: ImmLogic	constructor(u64_into_imm_logic, [43, 54], 11)
		57: Reg	constructor(zero_reg, [], 13)
		58: Cond	make_variant(Cond::Ne, [])
		62: ValueRegs	constructor(with_flags, [146, 170], 17)
		65: usize	const_int(0, usize)
		66: Reg	constructor(value_regs_get, [10, 65], 1)
		67: usize	const_int(1, usize)
		68: Reg	constructor(value_regs_get, [10, 67], 2)
		69: Type	const_prim(I64)
		72: Reg	constructor(zero_reg, [], 5)
		73: Type	const_prim(I32)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		80: u64	const_int(64, u64)
		81: ImmLogic	constructor(u64_into_imm_logic, [69, 80], 11)
		83: Cond	make_variant(Cond::Ne, [])
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [208, 232], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: OperandSize	constructor(operand_size, [15], 2)
		106: MInst	make_variant(MInst::AluRRR, [35, 105, 104, 18, 14])
		107: Unit	constructor(emit, [106], 3)
		108: Reg	constructor(writable_reg_to_reg, [104], 0)
		112: ALUOp	make_variant(ALUOp::Lsl, [])
		117: ALUOp	make_variant(ALUOp::Lsl, [])
		122: ALUOp	make_variant(ALUOp::OrrNot, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::Lsr, [])
		137: ALUOp	make_variant(ALUOp::Orr, [])
		142: OperandSize	constructor(operand_size, [43], 1)
		143: WritableReg	constructor(writable_zero_reg, [], 2)
		144: ALUOp	make_variant(ALUOp::AndS, [])
		145: MInst	make_variant(MInst::AluRRImmLogic, [144, 142, 143, 14, 55])
		146: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [145])
		150: Type	const_prim(I64)
		151: WritableReg	constructor(temp_writable_reg, [150], 1)
		152: MInst	make_variant(MInst::CSel, [151, 58, 57, 262])
		153: Reg	constructor(writable_reg_to_reg, [151], 0)
		154: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [152, 153])
		158: Type	const_prim(I64)
		159: WritableReg	constructor(temp_writable_reg, [158], 1)
		160: MInst	make_variant(MInst::CSel, [159, 58, 262, 312])
		161: Reg	constructor(writable_reg_to_reg, [159], 0)
		162: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [160, 161])
		165: Reg	match_variant(154, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		166: Reg	match_variant(162, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		167: ValueRegs	constructor(value_regs, [165, 166], 1)
		168: MInst	match_variant(154, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		169: MInst	match_variant(162, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		170: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [168, 169, 167])
		174: ALUOp	make_variant(ALUOp::Lsr, [])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::OrrNot, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsl, [])
		199: ALUOp	make_variant(ALUOp::Orr, [])
		204: OperandSize	constructor(operand_size, [69], 1)
		205: WritableReg	constructor(writable_zero_reg, [], 2)
		206: ALUOp	make_variant(ALUOp::AndS, [])
		207: MInst	make_variant(MInst::AluRRImmLogic, [206, 204, 205, 108, 81])
		208: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [207])
		212: Type	const_prim(I64)
		213: WritableReg	constructor(temp_writable_reg, [212], 1)
		214: MInst	make_variant(MInst::CSel, [213, 83, 332, 372])
		215: Reg	constructor(writable_reg_to_reg, [213], 0)
		216: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [214, 215])
		220: Type	const_prim(I64)
		221: WritableReg	constructor(temp_writable_reg, [220], 1)
		222: MInst	make_variant(MInst::CSel, [221, 83, 85, 332])
		223: Reg	constructor(writable_reg_to_reg, [221], 0)
		224: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [222, 223])
		227: Reg	match_variant(216, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: Reg	match_variant(224, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		229: ValueRegs	constructor(value_regs, [227, 228], 1)
		230: MInst	match_variant(216, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		231: MInst	match_variant(224, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		232: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [230, 231, 229])
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: OperandSize	constructor(operand_size, [15], 2)
		240: MInst	make_variant(MInst::AluRRR, [92, 239, 238, 22, 23])
		241: Unit	constructor(emit, [240], 3)
		242: Reg	constructor(writable_reg_to_reg, [238], 0)
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: OperandSize	constructor(operand_size, [15], 2)
		250: MInst	make_variant(MInst::AluRRR, [97, 249, 248, 26, 27])
		251: Unit	constructor(emit, [250], 3)
		252: Reg	constructor(writable_reg_to_reg, [248], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: OperandSize	constructor(operand_size, [43], 2)
		260: MInst	make_variant(MInst::AluRRR, [112, 259, 258, 40, 14])
		261: Unit	constructor(emit, [260], 3)
		262: Reg	constructor(writable_reg_to_reg, [258], 0)
		267: Type	const_prim(I64)
		268: WritableReg	constructor(temp_writable_reg, [267], 1)
		269: OperandSize	constructor(operand_size, [43], 2)
		270: MInst	make_variant(MInst::AluRRR, [117, 269, 268, 42, 14])
		271: Unit	constructor(emit, [270], 3)
		272: Reg	constructor(writable_reg_to_reg, [268], 0)
		277: Type	const_prim(I64)
		278: WritableReg	constructor(temp_writable_reg, [277], 1)
		279: OperandSize	constructor(operand_size, [47], 2)
		280: MInst	make_variant(MInst::AluRRR, [122, 279, 278, 46, 14])
		281: Unit	constructor(emit, [280], 3)
		282: Reg	constructor(writable_reg_to_reg, [278], 0)
		287: Type	const_prim(I64)
		288: WritableReg	constructor(temp_writable_reg, [287], 1)
		289: OperandSize	constructor(operand_size, [43], 2)
		290: MInst	make_variant(MInst::AluRRImmShift, [127, 289, 288, 40, 50])
		291: Unit	constructor(emit, [290], 3)
		292: Reg	constructor(writable_reg_to_reg, [288], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: OperandSize	constructor(operand_size, [43], 2)
		300: MInst	make_variant(MInst::AluRRR, [132, 299, 298, 292, 282])
		301: Unit	constructor(emit, [300], 3)
		302: Reg	constructor(writable_reg_to_reg, [298], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: OperandSize	constructor(operand_size, [43], 2)
		310: MInst	make_variant(MInst::AluRRR, [137, 309, 308, 272, 302])
		311: Unit	constructor(emit, [310], 3)
		312: Reg	constructor(writable_reg_to_reg, [308], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: OperandSize	constructor(operand_size, [69], 2)
		320: MInst	make_variant(MInst::AluRRR, [174, 319, 318, 66, 108])
		321: Unit	constructor(emit, [320], 3)
		322: Reg	constructor(writable_reg_to_reg, [318], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: OperandSize	constructor(operand_size, [69], 2)
		330: MInst	make_variant(MInst::AluRRR, [179, 329, 328, 68, 108])
		331: Unit	constructor(emit, [330], 3)
		332: Reg	constructor(writable_reg_to_reg, [328], 0)
		337: Type	const_prim(I64)
		338: WritableReg	constructor(temp_writable_reg, [337], 1)
		339: OperandSize	constructor(operand_size, [73], 2)
		340: MInst	make_variant(MInst::AluRRR, [184, 339, 338, 72, 108])
		341: Unit	constructor(emit, [340], 3)
		342: Reg	constructor(writable_reg_to_reg, [338], 0)
		347: Type	const_prim(I64)
		348: WritableReg	constructor(temp_writable_reg, [347], 1)
		349: OperandSize	constructor(operand_size, [69], 2)
		350: MInst	make_variant(MInst::AluRRImmShift, [189, 349, 348, 68, 76])
		351: Unit	constructor(emit, [350], 3)
		352: Reg	constructor(writable_reg_to_reg, [348], 0)
		357: Type	const_prim(I64)
		358: WritableReg	constructor(temp_writable_reg, [357], 1)
		359: OperandSize	constructor(operand_size, [69], 2)
		360: MInst	make_variant(MInst::AluRRR, [194, 359, 358, 352, 342])
		361: Unit	constructor(emit, [360], 3)
		362: Reg	constructor(writable_reg_to_reg, [358], 0)
		367: Type	const_prim(I64)
		368: WritableReg	constructor(temp_writable_reg, [367], 1)
		369: OperandSize	constructor(operand_size, [69], 2)
		370: MInst	make_variant(MInst::AluRRR, [199, 369, 368, 322, 362])
		371: Unit	constructor(emit, [370], 3)
		372: Reg	constructor(writable_reg_to_reg, [368], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		154:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		162:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		216:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		224:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
	]
	result = 31
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1565
		../../codegen/src/isa/aarch64/inst.isle line 2762
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		22: Option(InstOutput)	some(30)
		26: ALUOp	make_variant(ALUOp::RotR, [])
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [13], 2)
		38: MInst	make_variant(MInst::AluRRImmShift, [26, 37, 36, 17, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1560
		../../codegen/src/isa/aarch64/inst.isle line 2762
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		22: Option(InstOutput)	some(30)
		26: ALUOp	make_variant(ALUOp::RotR, [])
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [13], 2)
		38: MInst	make_variant(MInst::AluRRImmShift, [26, 37, 36, 17, 19])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1554
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2759
		output_reg
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I64)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 5)
		20: Option(InstOutput)	some(33)
		24: ALUOp	make_variant(ALUOp::Sub, [])
		29: ALUOp	make_variant(ALUOp::RotR, [])
		32: ValueRegs	constructor(value_reg, [53], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [14], 2)
		41: MInst	make_variant(MInst::AluRRR, [24, 40, 39, 13, 12])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [14], 2)
		51: MInst	make_variant(MInst::AluRRR, [29, 50, 49, 17, 43])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1548
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2759
		output_reg
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I32)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 5)
		20: Option(InstOutput)	some(33)
		24: ALUOp	make_variant(ALUOp::Sub, [])
		29: ALUOp	make_variant(ALUOp::RotR, [])
		32: ValueRegs	constructor(value_reg, [53], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [14], 2)
		41: MInst	make_variant(MInst::AluRRR, [24, 40, 39, 13, 12])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [14], 2)
		51: MInst	make_variant(MInst::AluRRR, [29, 50, 49, 17, 43])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1535
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/lower.isle line 1648
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(37)
		25: Type	extractor(value_type, 17)
		26: Reg	constructor(put_in_reg, [17], 1)
		30: Type	const_prim(I32)
		32: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		36: ValueRegs	constructor(value_reg, [82], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: ALUOp	make_variant(ALUOp::Lsr, [])
		46: ALUOp	make_variant(ALUOp::Lsl, [])
		51: ALUOp	make_variant(ALUOp::Orr, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [30], 2)
		60: MInst	make_variant(MInst::AluRRImmShift, [41, 59, 58, 26, 20])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: OperandSize	constructor(operand_size, [30], 2)
		70: MInst	make_variant(MInst::AluRRImmShift, [46, 69, 68, 26, 32])
		71: Unit	constructor(emit, [70], 3)
		72: Reg	constructor(writable_reg_to_reg, [68], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [30], 2)
		80: MInst	make_variant(MInst::AluRRR, [51, 79, 78, 72, 62])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	const_prim(I64)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1535
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/lower.isle line 1648
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(37)
		25: Type	extractor(value_type, 17)
		26: Reg	constructor(put_in_reg, [17], 1)
		30: Type	const_prim(I32)
		32: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		36: ValueRegs	constructor(value_reg, [82], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: ALUOp	make_variant(ALUOp::Lsr, [])
		46: ALUOp	make_variant(ALUOp::Lsl, [])
		51: ALUOp	make_variant(ALUOp::Orr, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [30], 2)
		60: MInst	make_variant(MInst::AluRRImmShift, [41, 59, 58, 26, 20])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: OperandSize	constructor(operand_size, [30], 2)
		70: MInst	make_variant(MInst::AluRRImmShift, [46, 69, 68, 26, 32])
		71: Unit	constructor(emit, [70], 3)
		72: Reg	constructor(writable_reg_to_reg, [68], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [30], 2)
		80: MInst	make_variant(MInst::AluRRR, [51, 79, 78, 72, 62])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	const_prim(I32)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1535
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/lower.isle line 1648
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(43)
		25: Type	extractor(value_type, 17)
		26: Option(Type)	extractor(fits_in_32, 25)
		27: Reg	constructor(put_in_reg, [17], 1)
		28: bool	const_prim(false)
		29: Type	match_some(26)
		30: u8	constructor(ty_bits, [29], 0)
		31: u8	const_int(32, u8)
		36: Type	const_prim(I32)
		38: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		42: ValueRegs	constructor(value_reg, [97], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::Extend, [49, 27, 28, 30, 31])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
		56: ALUOp	make_variant(ALUOp::Lsr, [])
		61: ALUOp	make_variant(ALUOp::Lsl, [])
		66: ALUOp	make_variant(ALUOp::Orr, [])
		72: Type	const_prim(I64)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: OperandSize	constructor(operand_size, [36], 2)
		75: MInst	make_variant(MInst::AluRRImmShift, [56, 74, 73, 52, 20])
		76: Unit	constructor(emit, [75], 3)
		77: Reg	constructor(writable_reg_to_reg, [73], 0)
		82: Type	const_prim(I64)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: OperandSize	constructor(operand_size, [36], 2)
		85: MInst	make_variant(MInst::AluRRImmShift, [61, 84, 83, 52, 38])
		86: Unit	constructor(emit, [85], 3)
		87: Reg	constructor(writable_reg_to_reg, [83], 0)
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: OperandSize	constructor(operand_size, [36], 2)
		95: MInst	make_variant(MInst::AluRRR, [66, 94, 93, 87, 77])
		96: Unit	constructor(emit, [95], 3)
		97: Reg	constructor(writable_reg_to_reg, [93], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		26:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1529
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/lower.isle line 1627
		output_reg
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I32)
		17: Value	match_tuple(9, 0)
		19: Type	match_some(6)
		22: Option(InstOutput)	some(47)
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: Type	extractor(value_type, 17)
		30: Reg	constructor(put_in_reg, [17], 1)
		34: ImmLogic	constructor(rotr_mask, [19], 1)
		35: Type	const_prim(I32)
		37: u8	constructor(ty_bits, [19], 0)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		40: Reg	constructor(zero_reg, [], 5)
		46: ValueRegs	constructor(value_reg, [147], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: OperandSize	constructor(operand_size, [15], 2)
		55: MInst	make_variant(MInst::AluRRR, [26, 54, 53, 14, 13])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		61: ALUOp	make_variant(ALUOp::And, [])
		66: ALUOp	make_variant(ALUOp::Sub, [])
		71: ALUOp	make_variant(ALUOp::Sub, [])
		76: ALUOp	make_variant(ALUOp::Lsr, [])
		81: ALUOp	make_variant(ALUOp::Lsl, [])
		86: ALUOp	make_variant(ALUOp::Orr, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: OperandSize	constructor(operand_size, [35], 2)
		95: MInst	make_variant(MInst::AluRRImmLogic, [61, 94, 93, 57, 34])
		96: Unit	constructor(emit, [95], 3)
		97: Reg	constructor(writable_reg_to_reg, [93], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: OperandSize	constructor(operand_size, [35], 2)
		105: MInst	make_variant(MInst::AluRRImm12, [66, 104, 103, 97, 38])
		106: Unit	constructor(emit, [105], 3)
		107: Reg	constructor(writable_reg_to_reg, [103], 0)
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: OperandSize	constructor(operand_size, [35], 2)
		115: MInst	make_variant(MInst::AluRRR, [71, 114, 113, 40, 107])
		116: Unit	constructor(emit, [115], 3)
		117: Reg	constructor(writable_reg_to_reg, [113], 0)
		122: Type	const_prim(I64)
		123: WritableReg	constructor(temp_writable_reg, [122], 1)
		124: OperandSize	constructor(operand_size, [35], 2)
		125: MInst	make_variant(MInst::AluRRR, [76, 124, 123, 30, 97])
		126: Unit	constructor(emit, [125], 3)
		127: Reg	constructor(writable_reg_to_reg, [123], 0)
		132: Type	const_prim(I64)
		133: WritableReg	constructor(temp_writable_reg, [132], 1)
		134: OperandSize	constructor(operand_size, [35], 2)
		135: MInst	make_variant(MInst::AluRRR, [81, 134, 133, 30, 117])
		136: Unit	constructor(emit, [135], 3)
		137: Reg	constructor(writable_reg_to_reg, [133], 0)
		142: Type	const_prim(I64)
		143: WritableReg	constructor(temp_writable_reg, [142], 1)
		144: OperandSize	constructor(operand_size, [35], 2)
		145: MInst	make_variant(MInst::AluRRR, [86, 144, 143, 137, 127])
		146: Unit	constructor(emit, [145], 3)
		147: Reg	constructor(writable_reg_to_reg, [143], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1529
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/lower.isle line 1627
		output_reg
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I32)
		17: Value	match_tuple(9, 0)
		19: Type	match_some(6)
		22: Option(InstOutput)	some(47)
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: Type	extractor(value_type, 17)
		30: Reg	constructor(put_in_reg, [17], 1)
		34: ImmLogic	constructor(rotr_mask, [19], 1)
		35: Type	const_prim(I32)
		37: u8	constructor(ty_bits, [19], 0)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		40: Reg	constructor(zero_reg, [], 5)
		46: ValueRegs	constructor(value_reg, [147], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: OperandSize	constructor(operand_size, [15], 2)
		55: MInst	make_variant(MInst::AluRRR, [26, 54, 53, 14, 13])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		61: ALUOp	make_variant(ALUOp::And, [])
		66: ALUOp	make_variant(ALUOp::Sub, [])
		71: ALUOp	make_variant(ALUOp::Sub, [])
		76: ALUOp	make_variant(ALUOp::Lsr, [])
		81: ALUOp	make_variant(ALUOp::Lsl, [])
		86: ALUOp	make_variant(ALUOp::Orr, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: OperandSize	constructor(operand_size, [35], 2)
		95: MInst	make_variant(MInst::AluRRImmLogic, [61, 94, 93, 57, 34])
		96: Unit	constructor(emit, [95], 3)
		97: Reg	constructor(writable_reg_to_reg, [93], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: OperandSize	constructor(operand_size, [35], 2)
		105: MInst	make_variant(MInst::AluRRImm12, [66, 104, 103, 97, 38])
		106: Unit	constructor(emit, [105], 3)
		107: Reg	constructor(writable_reg_to_reg, [103], 0)
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: OperandSize	constructor(operand_size, [35], 2)
		115: MInst	make_variant(MInst::AluRRR, [71, 114, 113, 40, 107])
		116: Unit	constructor(emit, [115], 3)
		117: Reg	constructor(writable_reg_to_reg, [113], 0)
		122: Type	const_prim(I64)
		123: WritableReg	constructor(temp_writable_reg, [122], 1)
		124: OperandSize	constructor(operand_size, [35], 2)
		125: MInst	make_variant(MInst::AluRRR, [76, 124, 123, 30, 97])
		126: Unit	constructor(emit, [125], 3)
		127: Reg	constructor(writable_reg_to_reg, [123], 0)
		132: Type	const_prim(I64)
		133: WritableReg	constructor(temp_writable_reg, [132], 1)
		134: OperandSize	constructor(operand_size, [35], 2)
		135: MInst	make_variant(MInst::AluRRR, [81, 134, 133, 30, 117])
		136: Unit	constructor(emit, [135], 3)
		137: Reg	constructor(writable_reg_to_reg, [133], 0)
		142: Type	const_prim(I64)
		143: WritableReg	constructor(temp_writable_reg, [142], 1)
		144: OperandSize	constructor(operand_size, [35], 2)
		145: MInst	make_variant(MInst::AluRRR, [86, 144, 143, 137, 127])
		146: Unit	constructor(emit, [145], 3)
		147: Reg	constructor(writable_reg_to_reg, [143], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1529
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/lower.isle line 1627
		output_reg
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I32)
		17: Value	match_tuple(9, 0)
		19: Type	match_some(6)
		22: Option(InstOutput)	some(53)
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: Type	extractor(value_type, 17)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [17], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		40: ImmLogic	constructor(rotr_mask, [19], 1)
		41: Type	const_prim(I32)
		43: u8	constructor(ty_bits, [19], 0)
		44: Imm12	constructor(u8_into_imm12, [43], 3)
		46: Reg	constructor(zero_reg, [], 5)
		52: ValueRegs	constructor(value_reg, [162], 1)
		53: InstOutput	constructor(output, [52], 2)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: OperandSize	constructor(operand_size, [15], 2)
		61: MInst	make_variant(MInst::AluRRR, [26, 60, 59, 14, 13])
		62: Unit	constructor(emit, [61], 3)
		63: Reg	constructor(writable_reg_to_reg, [59], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: MInst	make_variant(MInst::Extend, [69, 31, 32, 34, 35])
		71: Unit	constructor(emit, [70], 2)
		72: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: ALUOp	make_variant(ALUOp::And, [])
		81: ALUOp	make_variant(ALUOp::Sub, [])
		86: ALUOp	make_variant(ALUOp::Sub, [])
		91: ALUOp	make_variant(ALUOp::Lsr, [])
		96: ALUOp	make_variant(ALUOp::Lsl, [])
		101: ALUOp	make_variant(ALUOp::Orr, [])
		107: Type	const_prim(I64)
		108: WritableReg	constructor(temp_writable_reg, [107], 1)
		109: OperandSize	constructor(operand_size, [41], 2)
		110: MInst	make_variant(MInst::AluRRImmLogic, [76, 109, 108, 63, 40])
		111: Unit	constructor(emit, [110], 3)
		112: Reg	constructor(writable_reg_to_reg, [108], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: OperandSize	constructor(operand_size, [41], 2)
		120: MInst	make_variant(MInst::AluRRImm12, [81, 119, 118, 112, 44])
		121: Unit	constructor(emit, [120], 3)
		122: Reg	constructor(writable_reg_to_reg, [118], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: OperandSize	constructor(operand_size, [41], 2)
		130: MInst	make_variant(MInst::AluRRR, [86, 129, 128, 46, 122])
		131: Unit	constructor(emit, [130], 3)
		132: Reg	constructor(writable_reg_to_reg, [128], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: OperandSize	constructor(operand_size, [41], 2)
		140: MInst	make_variant(MInst::AluRRR, [91, 139, 138, 72, 112])
		141: Unit	constructor(emit, [140], 3)
		142: Reg	constructor(writable_reg_to_reg, [138], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: OperandSize	constructor(operand_size, [41], 2)
		150: MInst	make_variant(MInst::AluRRR, [96, 149, 148, 72, 132])
		151: Unit	constructor(emit, [150], 3)
		152: Reg	constructor(writable_reg_to_reg, [148], 0)
		157: Type	const_prim(I64)
		158: WritableReg	constructor(temp_writable_reg, [157], 1)
		159: OperandSize	constructor(operand_size, [41], 2)
		160: MInst	make_variant(MInst::AluRRR, [101, 159, 158, 152, 142])
		161: Unit	constructor(emit, [160], 3)
		162: Reg	constructor(writable_reg_to_reg, [158], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1493
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		20: Option(InstOutput)	some(23)
		22: ValueRegs	constructor(put_in_regs, [18], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1491
		../../codegen/src/isa/aarch64/inst.isle line 2754
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Imm64	match_some(13)
		19: u64	extractor(u64_from_imm64, 18)
		20: u8	constructor(shift_masked_imm, [16, 19], 0)
		23: Option(InstOutput)	some(31)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		30: ValueRegs	constructor(value_reg, [40], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecShiftImm, [27, 37, 15, 17, 20])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 2738
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: Type	match_some(6)
		10: VectorSize	constructor(vector_size, [9], 1)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ImmLogic	constructor(shift_mask, [9], 3)
		15: Type	const_prim(I32)
		17: Reg	constructor(zero_reg, [], 5)
		18: Type	const_prim(I64)
		21: Value	match_tuple(11, 0)
		22: Reg	constructor(put_in_reg, [21], 8)
		25: Option(InstOutput)	some(50)
		29: ALUOp	make_variant(ALUOp::And, [])
		34: ALUOp	make_variant(ALUOp::Sub, [])
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::VecDup, [39, 70, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		46: VecALUOp	make_variant(VecALUOp::Sshl, [])
		49: ValueRegs	constructor(value_reg, [79], 1)
		50: InstOutput	constructor(output, [49], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [15], 2)
		58: MInst	make_variant(MInst::AluRRImmLogic, [29, 57, 56, 13, 14])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [18], 2)
		68: MInst	make_variant(MInst::AluRRR, [34, 67, 66, 17, 60])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		75: Type	const_prim(I8X16)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::VecRRR, [46, 76, 22, 42, 10])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1477
		../../codegen/src/isa/aarch64/lower.isle line 1508
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2657
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [45], 5)
		17: Option(InstOutput)	some(16)
		20: usize	const_int(0, usize)
		21: Reg	constructor(value_regs_get, [10, 20], 1)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Type	const_prim(I64)
		27: Reg	constructor(zero_reg, [], 5)
		28: Type	const_prim(I32)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		34: u8	const_int(63, u8)
		35: ImmShift	constructor(imm_shift_from_u8, [34], 10)
		38: u64	const_int(64, u64)
		39: ImmLogic	constructor(u64_into_imm_logic, [24, 38], 13)
		41: Cond	make_variant(Cond::Ne, [])
		45: ValueRegs	constructor(with_flags, [88, 112], 18)
		49: ALUOp	make_variant(ALUOp::Lsr, [])
		54: ALUOp	make_variant(ALUOp::Asr, [])
		59: ALUOp	make_variant(ALUOp::OrrNot, [])
		64: ALUOp	make_variant(ALUOp::Lsl, [])
		69: ALUOp	make_variant(ALUOp::Lsl, [])
		74: ALUOp	make_variant(ALUOp::Asr, [])
		79: ALUOp	make_variant(ALUOp::Orr, [])
		84: OperandSize	constructor(operand_size, [24], 1)
		85: WritableReg	constructor(writable_zero_reg, [], 2)
		86: ALUOp	make_variant(ALUOp::AndS, [])
		87: MInst	make_variant(MInst::AluRRImmLogic, [86, 84, 85, 14, 39])
		88: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [87])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 41, 132, 182])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: MInst	make_variant(MInst::CSel, [101, 41, 172, 132])
		103: Reg	constructor(writable_reg_to_reg, [101], 0)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [102, 103])
		107: Reg	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		108: Reg	match_variant(104, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		109: ValueRegs	constructor(value_regs, [107, 108], 1)
		110: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		111: MInst	match_variant(104, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		112: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [110, 111, 109])
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: OperandSize	constructor(operand_size, [24], 2)
		120: MInst	make_variant(MInst::AluRRR, [49, 119, 118, 21, 14])
		121: Unit	constructor(emit, [120], 3)
		122: Reg	constructor(writable_reg_to_reg, [118], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: OperandSize	constructor(operand_size, [24], 2)
		130: MInst	make_variant(MInst::AluRRR, [54, 129, 128, 23, 14])
		131: Unit	constructor(emit, [130], 3)
		132: Reg	constructor(writable_reg_to_reg, [128], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: OperandSize	constructor(operand_size, [28], 2)
		140: MInst	make_variant(MInst::AluRRR, [59, 139, 138, 27, 14])
		141: Unit	constructor(emit, [140], 3)
		142: Reg	constructor(writable_reg_to_reg, [138], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: OperandSize	constructor(operand_size, [24], 2)
		150: MInst	make_variant(MInst::AluRRImmShift, [64, 149, 148, 23, 31])
		151: Unit	constructor(emit, [150], 3)
		152: Reg	constructor(writable_reg_to_reg, [148], 0)
		157: Type	const_prim(I64)
		158: WritableReg	constructor(temp_writable_reg, [157], 1)
		159: OperandSize	constructor(operand_size, [24], 2)
		160: MInst	make_variant(MInst::AluRRR, [69, 159, 158, 152, 142])
		161: Unit	constructor(emit, [160], 3)
		162: Reg	constructor(writable_reg_to_reg, [158], 0)
		167: Type	const_prim(I64)
		168: WritableReg	constructor(temp_writable_reg, [167], 1)
		169: OperandSize	constructor(operand_size, [24], 2)
		170: MInst	make_variant(MInst::AluRRImmShift, [74, 169, 168, 23, 35])
		171: Unit	constructor(emit, [170], 3)
		172: Reg	constructor(writable_reg_to_reg, [168], 0)
		177: Type	const_prim(I64)
		178: WritableReg	constructor(temp_writable_reg, [177], 1)
		179: OperandSize	constructor(operand_size, [24], 2)
		180: MInst	make_variant(MInst::AluRRR, [79, 179, 178, 122, 162])
		181: Unit	constructor(emit, [180], 3)
		182: Reg	constructor(writable_reg_to_reg, [178], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		96:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		104:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1473
		../../codegen/src/isa/aarch64/inst.isle line 2982
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		11: ALUOp	make_variant(ALUOp::Asr, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 19, 13], 2)
		16: Option(InstOutput)	some(22)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		21: ValueRegs	constructor(value_reg, [14], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1473
		../../codegen/src/isa/aarch64/inst.isle line 2978
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		11: ALUOp	make_variant(ALUOp::Asr, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 37, 13], 2)
		16: Option(InstOutput)	some(28)
		18: Type	extractor(value_type, 9)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [9], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		27: ValueRegs	constructor(value_reg, [14], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::Extend, [34, 20, 21, 23, 24])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
		../../codegen/src/isa/aarch64/inst.isle line 2965
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: ALUOp	make_variant(ALUOp::Asr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
		../../codegen/src/isa/aarch64/inst.isle line 2964
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: ALUOp	make_variant(ALUOp::Asr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
		../../codegen/src/isa/aarch64/inst.isle line 2960
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: ALUOp	make_variant(ALUOp::Asr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 38, 14], 2)
		17: Option(InstOutput)	some(29)
		19: Type	extractor(value_type, 10)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [10], 1)
		22: bool	const_prim(true)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(32, u8)
		28: ValueRegs	constructor(value_reg, [15], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::Extend, [35, 21, 22, 24, 25])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1435
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		20: Option(InstOutput)	some(23)
		22: ValueRegs	constructor(put_in_regs, [18], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1433
		../../codegen/src/isa/aarch64/inst.isle line 2750
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Imm64	match_some(13)
		19: u64	extractor(u64_from_imm64, 18)
		20: u8	constructor(shift_masked_imm, [16, 19], 0)
		23: Option(InstOutput)	some(31)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		30: ValueRegs	constructor(value_reg, [40], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecShiftImm, [27, 37, 15, 17, 20])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1428
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 2742
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: Type	match_some(6)
		10: VectorSize	constructor(vector_size, [9], 1)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ImmLogic	constructor(shift_mask, [9], 3)
		15: Type	const_prim(I32)
		17: Reg	constructor(zero_reg, [], 5)
		18: Type	const_prim(I64)
		21: Value	match_tuple(11, 0)
		22: Reg	constructor(put_in_reg, [21], 8)
		25: Option(InstOutput)	some(50)
		29: ALUOp	make_variant(ALUOp::And, [])
		34: ALUOp	make_variant(ALUOp::Sub, [])
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::VecDup, [39, 70, 10])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		46: VecALUOp	make_variant(VecALUOp::Ushl, [])
		49: ValueRegs	constructor(value_reg, [79], 1)
		50: InstOutput	constructor(output, [49], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [15], 2)
		58: MInst	make_variant(MInst::AluRRImmLogic, [29, 57, 56, 13, 14])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [18], 2)
		68: MInst	make_variant(MInst::AluRRR, [34, 67, 66, 17, 60])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		75: Type	const_prim(I8X16)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::VecRRR, [46, 76, 22, 42, 10])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1420
		../../codegen/src/isa/aarch64/lower.isle line 1449
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: usize	const_int(0, usize)
		21: Reg	constructor(value_regs_get, [10, 20], 1)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Type	const_prim(I64)
		27: Reg	constructor(zero_reg, [], 5)
		28: Type	const_prim(I32)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [24, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		40: Reg	constructor(zero_reg, [], 14)
		43: ValueRegs	constructor(with_flags, [81, 105], 17)
		47: ALUOp	make_variant(ALUOp::Lsr, [])
		52: ALUOp	make_variant(ALUOp::Lsr, [])
		57: ALUOp	make_variant(ALUOp::OrrNot, [])
		62: ALUOp	make_variant(ALUOp::Lsl, [])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::Orr, [])
		77: OperandSize	constructor(operand_size, [24], 1)
		78: WritableReg	constructor(writable_zero_reg, [], 2)
		79: ALUOp	make_variant(ALUOp::AndS, [])
		80: MInst	make_variant(MInst::AluRRImmLogic, [79, 77, 78, 14, 36])
		81: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [80])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: MInst	make_variant(MInst::CSel, [86, 38, 125, 165])
		88: Reg	constructor(writable_reg_to_reg, [86], 0)
		89: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [87, 88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 38, 40, 125])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: Reg	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		101: Reg	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		102: ValueRegs	constructor(value_regs, [100, 101], 1)
		103: MInst	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		104: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [103, 104, 102])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: OperandSize	constructor(operand_size, [24], 2)
		113: MInst	make_variant(MInst::AluRRR, [47, 112, 111, 21, 14])
		114: Unit	constructor(emit, [113], 3)
		115: Reg	constructor(writable_reg_to_reg, [111], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: OperandSize	constructor(operand_size, [24], 2)
		123: MInst	make_variant(MInst::AluRRR, [52, 122, 121, 23, 14])
		124: Unit	constructor(emit, [123], 3)
		125: Reg	constructor(writable_reg_to_reg, [121], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: OperandSize	constructor(operand_size, [28], 2)
		133: MInst	make_variant(MInst::AluRRR, [57, 132, 131, 27, 14])
		134: Unit	constructor(emit, [133], 3)
		135: Reg	constructor(writable_reg_to_reg, [131], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: OperandSize	constructor(operand_size, [24], 2)
		143: MInst	make_variant(MInst::AluRRImmShift, [62, 142, 141, 23, 31])
		144: Unit	constructor(emit, [143], 3)
		145: Reg	constructor(writable_reg_to_reg, [141], 0)
		150: Type	const_prim(I64)
		151: WritableReg	constructor(temp_writable_reg, [150], 1)
		152: OperandSize	constructor(operand_size, [24], 2)
		153: MInst	make_variant(MInst::AluRRR, [67, 152, 151, 145, 135])
		154: Unit	constructor(emit, [153], 3)
		155: Reg	constructor(writable_reg_to_reg, [151], 0)
		160: Type	const_prim(I64)
		161: WritableReg	constructor(temp_writable_reg, [160], 1)
		162: OperandSize	constructor(operand_size, [24], 2)
		163: MInst	make_variant(MInst::AluRRR, [72, 162, 161, 115, 155])
		164: Unit	constructor(emit, [163], 3)
		165: Reg	constructor(writable_reg_to_reg, [161], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		89:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		97:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1416
		../../codegen/src/isa/aarch64/inst.isle line 2990
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		11: ALUOp	make_variant(ALUOp::Lsr, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 19, 13], 2)
		16: Option(InstOutput)	some(22)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		21: ValueRegs	constructor(value_reg, [14], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1416
		../../codegen/src/isa/aarch64/inst.isle line 2986
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		11: ALUOp	make_variant(ALUOp::Lsr, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 37, 13], 2)
		16: Option(InstOutput)	some(28)
		18: Type	extractor(value_type, 9)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [9], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		27: ValueRegs	constructor(value_reg, [14], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::Extend, [34, 20, 21, 23, 24])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1412
		../../codegen/src/isa/aarch64/inst.isle line 2974
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: ALUOp	make_variant(ALUOp::Lsr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1412
		../../codegen/src/isa/aarch64/inst.isle line 2973
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: ALUOp	make_variant(ALUOp::Lsr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1412
		../../codegen/src/isa/aarch64/inst.isle line 2969
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: ALUOp	make_variant(ALUOp::Lsr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 38, 14], 2)
		17: Option(InstOutput)	some(29)
		19: Type	extractor(value_type, 10)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [10], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(32, u8)
		28: ValueRegs	constructor(value_reg, [15], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::Extend, [35, 21, 22, 24, 25])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1364
		../../codegen/src/isa/aarch64/inst.isle line 2746
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Imm64	match_some(13)
		19: u64	extractor(u64_from_imm64, 18)
		20: u8	constructor(shift_masked_imm, [16, 19], 0)
		23: Option(InstOutput)	some(31)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Shl, [])
		30: ValueRegs	constructor(value_reg, [40], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecShiftImm, [27, 37, 15, 17, 20])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1359
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 2738
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: Type	match_some(6)
		10: VectorSize	constructor(vector_size, [9], 1)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ImmLogic	constructor(shift_mask, [9], 3)
		15: Type	const_prim(I32)
		18: Value	match_tuple(11, 0)
		19: Reg	constructor(put_in_reg, [18], 6)
		22: Option(InstOutput)	some(42)
		26: ALUOp	make_variant(ALUOp::And, [])
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecDup, [31, 52, 10])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		38: VecALUOp	make_variant(VecALUOp::Sshl, [])
		41: ValueRegs	constructor(value_reg, [61], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: OperandSize	constructor(operand_size, [15], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [26, 49, 48, 13, 14])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		57: Type	const_prim(I8X16)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::VecRRR, [38, 58, 19, 34, 10])
		60: Unit	constructor(emit, [59], 2)
		61: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1329
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 459
		alu_rrr_to_emit
		alu_rrr_to_emit
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: usize	const_int(0, usize)
		21: Reg	constructor(value_regs_get, [10, 20], 1)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Type	const_prim(I64)
		27: Reg	constructor(zero_reg, [], 5)
		28: Type	const_prim(I32)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [24, 35], 11)
		38: Reg	constructor(zero_reg, [], 13)
		39: Cond	make_variant(Cond::Ne, [])
		43: ValueRegs	constructor(with_flags, [81, 105], 17)
		47: ALUOp	make_variant(ALUOp::Lsl, [])
		52: ALUOp	make_variant(ALUOp::Lsl, [])
		57: ALUOp	make_variant(ALUOp::OrrNot, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Lsr, [])
		72: ALUOp	make_variant(ALUOp::Orr, [])
		77: OperandSize	constructor(operand_size, [24], 1)
		78: WritableReg	constructor(writable_zero_reg, [], 2)
		79: ALUOp	make_variant(ALUOp::AndS, [])
		80: MInst	make_variant(MInst::AluRRImmLogic, [79, 77, 78, 14, 36])
		81: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [80])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: MInst	make_variant(MInst::CSel, [86, 39, 38, 115])
		88: Reg	constructor(writable_reg_to_reg, [86], 0)
		89: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [87, 88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 39, 115, 165])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: Reg	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		101: Reg	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		102: ValueRegs	constructor(value_regs, [100, 101], 1)
		103: MInst	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		104: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [103, 104, 102])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: OperandSize	constructor(operand_size, [24], 2)
		113: MInst	make_variant(MInst::AluRRR, [47, 112, 111, 21, 14])
		114: Unit	constructor(emit, [113], 3)
		115: Reg	constructor(writable_reg_to_reg, [111], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: OperandSize	constructor(operand_size, [24], 2)
		123: MInst	make_variant(MInst::AluRRR, [52, 122, 121, 23, 14])
		124: Unit	constructor(emit, [123], 3)
		125: Reg	constructor(writable_reg_to_reg, [121], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: OperandSize	constructor(operand_size, [28], 2)
		133: MInst	make_variant(MInst::AluRRR, [57, 132, 131, 27, 14])
		134: Unit	constructor(emit, [133], 3)
		135: Reg	constructor(writable_reg_to_reg, [131], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: OperandSize	constructor(operand_size, [24], 2)
		143: MInst	make_variant(MInst::AluRRImmShift, [62, 142, 141, 21, 31])
		144: Unit	constructor(emit, [143], 3)
		145: Reg	constructor(writable_reg_to_reg, [141], 0)
		150: Type	const_prim(I64)
		151: WritableReg	constructor(temp_writable_reg, [150], 1)
		152: OperandSize	constructor(operand_size, [24], 2)
		153: MInst	make_variant(MInst::AluRRR, [67, 152, 151, 145, 135])
		154: Unit	constructor(emit, [153], 3)
		155: Reg	constructor(writable_reg_to_reg, [151], 0)
		160: Type	const_prim(I64)
		161: WritableReg	constructor(temp_writable_reg, [160], 1)
		162: OperandSize	constructor(operand_size, [24], 2)
		163: MInst	make_variant(MInst::AluRRR, [72, 162, 161, 125, 155])
		164: Unit	constructor(emit, [163], 3)
		165: Reg	constructor(writable_reg_to_reg, [161], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		89:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		97:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1325
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ALUOp	make_variant(ALUOp::Lsl, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 10, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1321
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: ALUOp	make_variant(ALUOp::Lsl, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 11, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1316
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [13, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1315
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [13, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1312
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [14, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1312
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [15], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [14, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1312
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [15], 2)
		38: MInst	make_variant(MInst::AluRRR, [14, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1310
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [14, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1310
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [15], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [14, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1310
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [15], 2)
		38: MInst	make_variant(MInst::AluRRR, [14, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1303
		../../codegen/src/isa/aarch64/inst.isle line 2726
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Eor, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1301
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: ALUOp	make_variant(ALUOp::Eor, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [30], 2)
		15: Option(InstOutput)	some(14)
		20: ValueRegs	constructor(put_in_regs, [11], 1)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 2)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [20, 23], 3)
		25: ValueRegs	constructor(put_in_regs, [12], 4)
		26: Reg	constructor(value_regs_get, [25, 21], 5)
		27: Reg	constructor(value_regs_get, [25, 23], 6)
		30: ValueRegs	constructor(value_regs, [40, 50], 9)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [9], 2)
		38: MInst	make_variant(MInst::AluRRR, [8, 37, 36, 22, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [9], 2)
		48: MInst	make_variant(MInst::AluRRR, [8, 47, 46, 24, 27])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1298
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: ALUOp	make_variant(ALUOp::Eor, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1294
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [13, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1293
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [13, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [14, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [15], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [14, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [15], 2)
		38: MInst	make_variant(MInst::AluRRR, [14, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [14, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [15], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [14, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [15], 2)
		38: MInst	make_variant(MInst::AluRRR, [14, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1281
		../../codegen/src/isa/aarch64/inst.isle line 2708
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Orr, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1279
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: ALUOp	make_variant(ALUOp::Orr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [30], 2)
		15: Option(InstOutput)	some(14)
		20: ValueRegs	constructor(put_in_regs, [11], 1)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 2)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [20, 23], 3)
		25: ValueRegs	constructor(put_in_regs, [12], 4)
		26: Reg	constructor(value_regs_get, [25, 21], 5)
		27: Reg	constructor(value_regs_get, [25, 23], 6)
		30: ValueRegs	constructor(value_regs, [40, 50], 9)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [9], 2)
		38: MInst	make_variant(MInst::AluRRR, [8, 37, 36, 22, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [9], 2)
		48: MInst	make_variant(MInst::AluRRR, [8, 47, 46, 24, 27])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1276
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: ALUOp	make_variant(ALUOp::Orr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1271
		../../codegen/src/isa/aarch64/inst.isle line 2734
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		22: Option(InstOutput)	some(30)
		26: VecALUOp	make_variant(VecALUOp::Bic, [])
		29: ValueRegs	constructor(value_reg, [39], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::VecRRR, [26, 36, 15, 17, 19])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1269
		../../codegen/src/isa/aarch64/inst.isle line 2734
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		22: Option(InstOutput)	some(30)
		26: VecALUOp	make_variant(VecALUOp::Bic, [])
		29: ValueRegs	constructor(value_reg, [39], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::VecRRR, [26, 36, 15, 17, 19])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1267
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [13, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [13, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1263
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [14, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1263
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [15], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [14, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1263
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [15], 2)
		38: MInst	make_variant(MInst::AluRRR, [14, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1261
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [14, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1261
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [15], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [14, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1261
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [15], 2)
		38: MInst	make_variant(MInst::AluRRR, [14, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1254
		../../codegen/src/isa/aarch64/inst.isle line 2719
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::And, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1252
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: ALUOp	make_variant(ALUOp::And, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [30], 2)
		15: Option(InstOutput)	some(14)
		20: ValueRegs	constructor(put_in_regs, [11], 1)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 2)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [20, 23], 3)
		25: ValueRegs	constructor(put_in_regs, [12], 4)
		26: Reg	constructor(value_regs_get, [25, 21], 5)
		27: Reg	constructor(value_regs_get, [25, 23], 6)
		30: ValueRegs	constructor(value_regs, [40, 50], 9)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [9], 2)
		38: MInst	make_variant(MInst::AluRRR, [8, 37, 36, 22, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [9], 2)
		48: MInst	make_variant(MInst::AluRRR, [8, 47, 46, 24, 27])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1249
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: ALUOp	make_variant(ALUOp::And, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1245
		../../codegen/src/isa/aarch64/inst.isle line 3079
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Value))	extractor(bxor, 10)
		12: ALUOp	make_variant(ALUOp::EorNot, [])
		13: Type	const_prim(I64)
		14: (Value, Value)	match_some(11)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [24, 27], 3)
		29: ValueRegs	constructor(put_in_regs, [16], 4)
		30: Reg	constructor(value_regs_get, [29, 25], 5)
		31: Reg	constructor(value_regs_get, [29, 27], 6)
		34: ValueRegs	constructor(value_regs, [44, 54], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [13], 2)
		42: MInst	make_variant(MInst::AluRRR, [12, 41, 40, 26, 30])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [13], 2)
		52: MInst	make_variant(MInst::AluRRR, [12, 51, 50, 28, 31])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1243
		../../codegen/src/isa/aarch64/inst.isle line 3070
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [14, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [53], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [14], 2)
		51: MInst	make_variant(MInst::AluRRRShift, [13, 50, 49, 35, 37, 38])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1243
		../../codegen/src/isa/aarch64/inst.isle line 3067
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1878
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [14, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [45], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRImmLogic, [13, 42, 41, 30, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1243
		../../codegen/src/isa/aarch64/inst.isle line 3065
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [14], 2)
		38: MInst	make_variant(MInst::AluRRR, [13, 37, 36, 25, 26])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 2686
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(22)
		18: VecMisc2	make_variant(VecMisc2::Not, [])
		21: ValueRegs	constructor(value_reg, [30], 1)
		22: InstOutput	constructor(output, [21], 2)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 10, 12])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1230
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2691
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: usize	const_int(1, usize)
		13: Reg	constructor(value_regs_get, [9, 12], 3)
		14: Reg	constructor(zero_reg, [], 4)
		15: Type	const_prim(I64)
		17: Reg	constructor(zero_reg, [], 6)
		19: ValueRegs	constructor(value_regs, [41, 51], 8)
		20: InstOutput	constructor(output, [19], 9)
		21: Option(InstOutput)	some(20)
		25: ALUOp	make_variant(ALUOp::OrrNot, [])
		30: ALUOp	make_variant(ALUOp::OrrNot, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [15], 2)
		39: MInst	make_variant(MInst::AluRRR, [25, 38, 37, 14, 11])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [15], 2)
		49: MInst	make_variant(MInst::AluRRR, [30, 48, 47, 17, 13])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1224
		../../codegen/src/isa/aarch64/inst.isle line 2694
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(ishl, 11)
		13: (Value, Value)	match_some(12)
		14: Value	match_tuple(13, 1)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: Option(Imm64)	extractor(iconst, 16)
		18: Type	match_some(6)
		19: Imm64	match_some(17)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [18, 19], 0)
		21: Reg	constructor(zero_reg, [], 1)
		22: Value	match_tuple(13, 0)
		23: Reg	constructor(put_in_reg, [22], 2)
		24: ShiftOpAndAmt	match_some(20)
		27: Option(InstOutput)	some(36)
		32: ALUOp	make_variant(ALUOp::OrrNot, [])
		35: ValueRegs	constructor(value_reg, [47], 1)
		36: InstOutput	constructor(output, [35], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [18], 2)
		45: MInst	make_variant(MInst::AluRRRShift, [32, 44, 43, 21, 23, 24])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		17:	some
		20:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 2691
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Reg	constructor(zero_reg, [], 1)
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_some(6)
		15: Option(InstOutput)	some(23)
		19: ALUOp	make_variant(ALUOp::OrrNot, [])
		22: ValueRegs	constructor(value_reg, [33], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: OperandSize	constructor(operand_size, [12], 2)
		31: MInst	make_variant(MInst::AluRRR, [19, 30, 29, 9, 11])
		32: Unit	constructor(emit, [31], 3)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/lower.isle line 1210
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2840
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 0)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 1)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::SLoad32, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I32)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/lower.isle line 1209
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2830
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 0)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 1)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::SLoad16, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I16)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/lower.isle line 1208
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2820
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 0)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 1)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::SLoad8, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I8)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/lower.isle line 1210
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2840
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 1)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 0)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::SLoad32, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I32)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/lower.isle line 1209
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2830
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 1)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 0)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::SLoad16, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I16)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/lower.isle line 1208
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2820
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 1)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 0)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::SLoad8, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I8)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/lower.isle line 1210
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2840
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(39)
		32: AMode	constructor(amode_no_more_iconst, [19, 21, 23], 1)
		38: ValueRegs	constructor(value_reg, [46], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::SLoad32, [43, 32, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I32)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/lower.isle line 1209
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2830
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(39)
		32: AMode	constructor(amode_no_more_iconst, [19, 21, 23], 1)
		38: ValueRegs	constructor(value_reg, [46], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::SLoad16, [43, 32, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I16)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/lower.isle line 1208
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2820
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(39)
		32: AMode	constructor(amode_no_more_iconst, [19, 21, 23], 1)
		38: ValueRegs	constructor(value_reg, [46], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::SLoad8, [43, 32, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
		19:	const_prim(I8)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1192
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Reg	constructor(put_in_reg, [13], 1)
		16: Uimm8	match_tuple(12, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: u8	const_int(63, u8)
		21: ImmShift	constructor(imm_shift_from_u8, [20], 3)
		22: Type	const_prim(I64)
		24: ValueRegs	constructor(value_regs, [34, 49], 5)
		25: InstOutput	constructor(output, [24], 6)
		26: Option(InstOutput)	some(25)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::MovFromVec, [31, 15, 17, 18])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		38: ALUOp	make_variant(ALUOp::Asr, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [22], 2)
		47: MInst	make_variant(MInst::AluRRImmShift, [38, 46, 45, 34, 21])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		14:	const_prim(I64X2)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1181
		../../codegen/src/isa/aarch64/inst.isle line 3001
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: VectorSize	constructor(vector_size, [14], 2)
		18: Type	const_prim(I64)
		20: Uimm8	match_tuple(12, 1)
		21: u8	extractor(u8_from_uimm8, 20)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [39, 54], 7)
		27: InstOutput	constructor(output, [26], 8)
		28: Option(InstOutput)	some(27)
		30: OperandSize	make_variant(OperandSize::Size64, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::MovFromVecSigned, [36, 16, 21, 17, 30])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
		43: ALUOp	make_variant(ALUOp::Asr, [])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [18], 2)
		52: MInst	make_variant(MInst::AluRRImmShift, [43, 51, 50, 39, 24])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
		18:	const_prim(I64)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1181
		../../codegen/src/isa/aarch64/inst.isle line 3000
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: VectorSize	constructor(vector_size, [14], 2)
		18: Type	const_prim(I64)
		20: Uimm8	match_tuple(12, 1)
		21: u8	extractor(u8_from_uimm8, 20)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [40, 55], 7)
		27: InstOutput	constructor(output, [26], 8)
		28: Option(InstOutput)	some(27)
		30: Option(Type)	extractor(fits_in_32, 18)
		31: OperandSize	make_variant(OperandSize::Size32, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::MovFromVecSigned, [37, 16, 21, 17, 31])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		44: ALUOp	make_variant(ALUOp::Asr, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [18], 2)
		53: MInst	make_variant(MInst::AluRRImmShift, [44, 52, 51, 40, 24])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
		30:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1171
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		10: u8	const_int(63, u8)
		11: ImmShift	constructor(imm_shift_from_u8, [10], 2)
		12: Type	const_prim(I64)
		14: ValueRegs	constructor(value_regs, [19, 34], 4)
		15: InstOutput	constructor(output, [14], 5)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		23: ALUOp	make_variant(ALUOp::Asr, [])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [12], 2)
		32: MInst	make_variant(MInst::AluRRImmShift, [23, 31, 30, 19, 11])
		33: Unit	constructor(emit, [32], 3)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1171
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		10: u8	const_int(63, u8)
		11: ImmShift	constructor(imm_shift_from_u8, [10], 2)
		12: Type	const_prim(I64)
		14: ValueRegs	constructor(value_regs, [39, 49], 4)
		15: InstOutput	constructor(output, [14], 5)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		29: ALUOp	make_variant(ALUOp::Asr, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::Extend, [36, 20, 21, 23, 24])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [12], 2)
		47: MInst	make_variant(MInst::AluRRImmShift, [29, 46, 45, 39, 11])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1162
		../../codegen/src/isa/aarch64/inst.isle line 3001
		../../codegen/src/isa/aarch64/inst.isle line 2299
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	extractor(value_type, 14)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Type	match_some(6)
		20: Uimm8	match_tuple(13, 1)
		21: u8	extractor(u8_from_uimm8, 20)
		24: Option(InstOutput)	some(38)
		26: OperandSize	make_variant(OperandSize::Size64, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::MovFromVecSigned, [32, 15, 21, 17, 26])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		18:	const_prim(I64)
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1162
		../../codegen/src/isa/aarch64/inst.isle line 3000
		../../codegen/src/isa/aarch64/inst.isle line 2299
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	extractor(value_type, 14)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Type	match_some(6)
		20: Uimm8	match_tuple(13, 1)
		21: u8	extractor(u8_from_uimm8, 20)
		24: Option(InstOutput)	some(39)
		26: Option(Type)	extractor(fits_in_32, 18)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::MovFromVecSigned, [33, 15, 21, 17, 27])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		26:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1157
		../../codegen/src/isa/aarch64/inst.isle line 2312
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(true)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::Extend, [24, 10, 11, 13, 15])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/lower.isle line 1151
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2835
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 0)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 1)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::ULoad32, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I32)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/lower.isle line 1150
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2825
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 0)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 1)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::ULoad16, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I16)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3126
		../../codegen/src/isa/aarch64/lower.isle line 1149
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2815
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 0)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 1)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::ULoad8, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I8)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/lower.isle line 1151
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2835
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 1)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 0)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::ULoad32, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I32)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/lower.isle line 1150
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2825
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 1)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 0)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::ULoad16, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I16)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3123
		../../codegen/src/isa/aarch64/lower.isle line 1149
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2815
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(53)
		32: Option(Inst)	extractor(def_inst, 21)
		33: Inst	match_some(32)
		34: Option((Value, Value))	extractor(iadd, 33)
		35: (Value, Value)	match_some(34)
		36: Value	match_tuple(35, 1)
		37: Option(Inst)	extractor(def_inst, 36)
		38: Inst	match_some(37)
		39: Option(Imm64)	extractor(iconst, 38)
		40: Imm64	match_some(39)
		41: Option(i32)	extractor(simm32, 40)
		42: i32	match_some(41)
		43: Option(i32)	constructor(s32_add_fallible, [42, 23], 0)
		44: Value	match_tuple(35, 0)
		45: i32	match_some(43)
		46: AMode	constructor(amode_no_more_iconst, [19, 44, 45], 1)
		52: ValueRegs	constructor(value_reg, [60], 1)
		53: InstOutput	constructor(output, [52], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::ULoad8, [57, 46, 25])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I8)
		32:	some
		34:	some
		37:	some
		39:	some
		41:	some
		43:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/lower.isle line 1151
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2835
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(39)
		32: AMode	constructor(amode_no_more_iconst, [19, 21, 23], 1)
		38: ValueRegs	constructor(value_reg, [46], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::ULoad32, [43, 32, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I32)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/lower.isle line 1150
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2825
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(39)
		32: AMode	constructor(amode_no_more_iconst, [19, 21, 23], 1)
		38: ValueRegs	constructor(value_reg, [46], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::ULoad16, [43, 32, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I16)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/isa/aarch64/inst.isle line 3121
		../../codegen/src/isa/aarch64/lower.isle line 1149
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2815
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		25: MemFlags	match_tuple(20, 0)
		28: Option(InstOutput)	some(39)
		32: AMode	constructor(amode_no_more_iconst, [19, 21, 23], 1)
		38: ValueRegs	constructor(value_reg, [46], 1)
		39: InstOutput	constructor(output, [38], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::ULoad8, [43, 32, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
		19:	const_prim(I8)
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1137
		../../codegen/src/isa/aarch64/inst.isle line 2292
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	extractor(value_type, 13)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Uimm8	match_tuple(12, 1)
		18: u8	extractor(u8_from_uimm8, 17)
		20: Type	const_prim(I64)
		21: ImmExtend	make_variant(ImmExtend::Zero, [])
		22: u64	const_int(0, u64)
		23: Reg	constructor(imm, [20, 21, 22], 4)
		24: ValueRegs	constructor(value_regs, [34, 23], 5)
		25: InstOutput	constructor(output, [24], 6)
		26: Option(InstOutput)	some(25)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::MovFromVec, [31, 14, 18, 16])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
		../../codegen/src/isa/aarch64/inst.isle line 2990
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [19, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [34, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::Extend, [31, 20, 21, 23, 24])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		19:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1125
		../../codegen/src/isa/aarch64/inst.isle line 3033
		../../codegen/src/isa/aarch64/inst.isle line 2340
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((MemFlags, Value))	extractor(atomic_load, 11)
		13: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		14: Inst	match_some(13)
		16: Type	extractor(value_type, 9)
		17: (MemFlags, Value)	match_some(12)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(38)
		23: Option((MemFlags, Value))	extractor(atomic_load, 14)
		24: Unit	constructor(sink_inst, [14], 1)
		25: (MemFlags, Value)	match_some(23)
		26: Value	match_tuple(25, 1)
		27: Reg	constructor(put_in_reg, [26], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::LoadAcquire, [16, 32, 27, 18])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		13:	some
		23:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1118
		../../codegen/src/isa/aarch64/inst.isle line 2292
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	extractor(value_type, 14)
		17: ScalarSize	constructor(lane_size, [16], 2)
		18: Uimm8	match_tuple(13, 1)
		19: u8	extractor(u8_from_uimm8, 18)
		22: Option(InstOutput)	some(33)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::MovFromVec, [27, 15, 19, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1113
		../../codegen/src/isa/aarch64/inst.isle line 2312
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(false)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::Extend, [24, 10, 11, 13, 15])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1106
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umax, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [9], 4)
		17: Reg	constructor(put_in_reg, [11], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(40)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecRRR, [13, 27, 10, 12, 14])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		35: VectorSize	constructor(vector_size, [18], 1)
		36: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		39: ValueRegs	constructor(value_reg, [50], 1)
		40: InstOutput	constructor(output, [39], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRRMod, [36, 47, 30, 16, 17, 35])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1103
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Umax, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1100
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smax, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [9], 4)
		17: Reg	constructor(put_in_reg, [11], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(40)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecRRR, [13, 27, 10, 12, 14])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		35: VectorSize	constructor(vector_size, [18], 1)
		36: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		39: ValueRegs	constructor(value_reg, [50], 1)
		40: InstOutput	constructor(output, [39], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRRMod, [36, 47, 30, 16, 17, 35])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1097
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Smax, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1094
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umin, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 0)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [11], 4)
		17: Reg	constructor(put_in_reg, [9], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(40)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecRRR, [13, 27, 10, 12, 14])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		35: VectorSize	constructor(vector_size, [18], 1)
		36: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		39: ValueRegs	constructor(value_reg, [50], 1)
		40: InstOutput	constructor(output, [39], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRRMod, [36, 47, 30, 16, 17, 35])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1091
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Umin, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1088
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smin, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 0)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [11], 4)
		17: Reg	constructor(put_in_reg, [9], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(40)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecRRR, [13, 27, 10, 12, 14])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		35: VectorSize	constructor(vector_size, [18], 1)
		36: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		39: ValueRegs	constructor(value_reg, [50], 1)
		40: InstOutput	constructor(output, [39], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRRMod, [36, 47, 30, 16, 17, 35])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1085
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Smin, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Type	match_some(24)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		32: OperandSize	constructor(operand_size, [26], 5)
		36: ValueRegs	constructor(value_reg, [74], 9)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::Extend, [42, 25, 12, 27, 28])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::Extend, [51, 30, 12, 27, 28])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: ALUOp	make_variant(ALUOp::SubS, [])
		60: MInst	make_variant(MInst::AluRRR, [59, 32, 58, 45, 54])
		61: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [60])
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::CSel, [66, 11, 45, 54])
		68: Reg	constructor(writable_reg_to_reg, [66], 0)
		69: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [67, 68])
		72: ValueRegs	constructor(with_flags, [61, 69], 1)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [72, 73], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Reg	constructor(put_in_reg, [15], 2)
		27: Type	match_some(24)
		28: OperandSize	constructor(operand_size, [27], 3)
		32: ValueRegs	constructor(value_reg, [52], 7)
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRR, [37, 28, 36, 25, 26])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::CSel, [44, 11, 25, 26])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [45, 46])
		50: ValueRegs	constructor(with_flags, [39, 47], 1)
		51: usize	const_int(0, usize)
		52: Reg	constructor(value_regs_get, [50, 51], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Type	match_some(24)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		32: OperandSize	constructor(operand_size, [26], 5)
		36: ValueRegs	constructor(value_reg, [74], 9)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::Extend, [42, 25, 12, 27, 28])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::Extend, [51, 30, 12, 27, 28])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: ALUOp	make_variant(ALUOp::SubS, [])
		60: MInst	make_variant(MInst::AluRRR, [59, 32, 58, 45, 54])
		61: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [60])
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::CSel, [66, 11, 45, 54])
		68: Reg	constructor(writable_reg_to_reg, [66], 0)
		69: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [67, 68])
		72: ValueRegs	constructor(with_flags, [61, 69], 1)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [72, 73], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Reg	constructor(put_in_reg, [15], 2)
		27: Type	match_some(24)
		28: OperandSize	constructor(operand_size, [27], 3)
		32: ValueRegs	constructor(value_reg, [52], 7)
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRR, [37, 28, 36, 25, 26])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::CSel, [44, 11, 25, 26])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [45, 46])
		50: ValueRegs	constructor(with_flags, [39, 47], 1)
		51: usize	const_int(0, usize)
		52: Reg	constructor(value_regs_get, [50, 51], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Type	match_some(24)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		32: OperandSize	constructor(operand_size, [26], 5)
		36: ValueRegs	constructor(value_reg, [74], 9)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::Extend, [42, 25, 12, 27, 28])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::Extend, [51, 30, 12, 27, 28])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: ALUOp	make_variant(ALUOp::SubS, [])
		60: MInst	make_variant(MInst::AluRRR, [59, 32, 58, 45, 54])
		61: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [60])
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::CSel, [66, 11, 45, 54])
		68: Reg	constructor(writable_reg_to_reg, [66], 0)
		69: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [67, 68])
		72: ValueRegs	constructor(with_flags, [61, 69], 1)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [72, 73], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Reg	constructor(put_in_reg, [15], 2)
		27: Type	match_some(24)
		28: OperandSize	constructor(operand_size, [27], 3)
		32: ValueRegs	constructor(value_reg, [52], 7)
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRR, [37, 28, 36, 25, 26])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::CSel, [44, 11, 25, 26])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [45, 46])
		50: ValueRegs	constructor(with_flags, [39, 47], 1)
		51: usize	const_int(0, usize)
		52: Reg	constructor(value_regs_get, [50, 51], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Type	match_some(24)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		32: OperandSize	constructor(operand_size, [26], 5)
		36: ValueRegs	constructor(value_reg, [74], 9)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::Extend, [42, 25, 12, 27, 28])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::Extend, [51, 30, 12, 27, 28])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: ALUOp	make_variant(ALUOp::SubS, [])
		60: MInst	make_variant(MInst::AluRRR, [59, 32, 58, 45, 54])
		61: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [60])
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::CSel, [66, 11, 45, 54])
		68: Reg	constructor(writable_reg_to_reg, [66], 0)
		69: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [67, 68])
		72: ValueRegs	constructor(with_flags, [61, 69], 1)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [72, 73], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Reg	constructor(put_in_reg, [14], 1)
		26: Reg	constructor(put_in_reg, [15], 2)
		27: Type	match_some(24)
		28: OperandSize	constructor(operand_size, [27], 3)
		32: ValueRegs	constructor(value_reg, [52], 7)
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRR, [37, 28, 36, 25, 26])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::CSel, [44, 11, 25, 26])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [45, 46])
		50: ValueRegs	constructor(with_flags, [39, 47], 1)
		51: usize	const_int(0, usize)
		52: Reg	constructor(value_regs_get, [50, 51], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(45)
		20: Type	extractor(value_type, 10)
		21: Reg	constructor(put_in_reg, [10], 1)
		23: Option(Inst)	extractor(def_inst, 12)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(u64)	extractor(nonzero_u64_from_imm64, 26)
		28: Type	extractor(value_type, 12)
		29: ImmExtend	make_variant(ImmExtend::Sign, [])
		30: u64	match_some(27)
		31: Reg	constructor(imm, [28, 29, 30], 1)
		35: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ALUOp3	make_variant(ALUOp3::MSub, [])
		44: ValueRegs	constructor(value_reg, [66], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [35, 52, 51, 21, 31])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: OperandSize	constructor(operand_size, [14], 2)
		64: MInst	make_variant(MInst::AluRRRR, [41, 63, 62, 55, 31, 21])
		65: Unit	constructor(emit, [64], 3)
		66: Reg	constructor(writable_reg_to_reg, [62], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		23:	some
		25:	some
		27:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 10)
		21: Reg	constructor(put_in_reg, [10], 1)
		28: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [67], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 12)
		41: Reg	constructor(put_in_reg, [12], 1)
		43: CondBrKind	constructor(cond_br_zero, [41], 1)
		44: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		45: MInst	make_variant(MInst::TrapIf, [43, 44])
		46: Unit	constructor(emit, [45], 2)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: OperandSize	constructor(operand_size, [14], 2)
		54: MInst	make_variant(MInst::AluRRR, [28, 53, 52, 21, 41])
		55: Unit	constructor(emit, [54], 3)
		56: Reg	constructor(writable_reg_to_reg, [52], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: OperandSize	constructor(operand_size, [14], 2)
		65: MInst	make_variant(MInst::AluRRRR, [34, 64, 63, 56, 41, 21])
		66: Unit	constructor(emit, [65], 3)
		67: Reg	constructor(writable_reg_to_reg, [63], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		40:	const_prim(I64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 10)
		21: Reg	constructor(put_in_reg, [10], 1)
		28: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [73], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 12)
		41: Option(Type)	extractor(fits_in_32, 40)
		42: Reg	constructor(put_in_reg, [12], 1)
		43: bool	const_prim(true)
		44: Type	match_some(41)
		45: u8	constructor(ty_bits, [44], 0)
		46: u8	const_int(64, u8)
		49: CondBrKind	constructor(cond_br_zero, [82], 1)
		50: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		51: MInst	make_variant(MInst::TrapIf, [49, 50])
		52: Unit	constructor(emit, [51], 2)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [14], 2)
		60: MInst	make_variant(MInst::AluRRR, [28, 59, 58, 21, 82])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: OperandSize	constructor(operand_size, [14], 2)
		71: MInst	make_variant(MInst::AluRRRR, [34, 70, 69, 62, 82, 21])
		72: Unit	constructor(emit, [71], 3)
		73: Reg	constructor(writable_reg_to_reg, [69], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: MInst	make_variant(MInst::Extend, [79, 42, 43, 45, 46])
		81: Unit	constructor(emit, [80], 2)
		82: Reg	constructor(writable_reg_to_reg, [79], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		41:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(51)
		20: Type	extractor(value_type, 10)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [10], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		29: Option(Inst)	extractor(def_inst, 12)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(u64)	extractor(nonzero_u64_from_imm64, 32)
		34: Type	extractor(value_type, 12)
		35: ImmExtend	make_variant(ImmExtend::Sign, [])
		36: u64	match_some(33)
		37: Reg	constructor(imm, [34, 35, 36], 1)
		41: ALUOp	make_variant(ALUOp::SDiv, [])
		47: ALUOp3	make_variant(ALUOp3::MSub, [])
		50: ValueRegs	constructor(value_reg, [81], 1)
		51: InstOutput	constructor(output, [50], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::Extend, [57, 22, 23, 25, 26])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [14], 2)
		68: MInst	make_variant(MInst::AluRRR, [41, 67, 66, 60, 37])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: OperandSize	constructor(operand_size, [14], 2)
		79: MInst	make_variant(MInst::AluRRRR, [47, 78, 77, 70, 37, 60])
		80: Unit	constructor(emit, [79], 3)
		81: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 10)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [10], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [82], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::Extend, [50, 22, 23, 25, 26])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		55: Type	extractor(value_type, 12)
		56: Reg	constructor(put_in_reg, [12], 1)
		58: CondBrKind	constructor(cond_br_zero, [56], 1)
		59: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		60: MInst	make_variant(MInst::TrapIf, [58, 59])
		61: Unit	constructor(emit, [60], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [14], 2)
		69: MInst	make_variant(MInst::AluRRR, [34, 68, 67, 53, 56])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [14], 2)
		80: MInst	make_variant(MInst::AluRRRR, [40, 79, 78, 71, 56, 53])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		55:	const_prim(I64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 10)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [10], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [88], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::Extend, [50, 22, 23, 25, 26])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		55: Type	extractor(value_type, 12)
		56: Option(Type)	extractor(fits_in_32, 55)
		57: Reg	constructor(put_in_reg, [12], 1)
		58: bool	const_prim(true)
		59: Type	match_some(56)
		60: u8	constructor(ty_bits, [59], 0)
		61: u8	const_int(64, u8)
		64: CondBrKind	constructor(cond_br_zero, [97], 1)
		65: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		66: MInst	make_variant(MInst::TrapIf, [64, 65])
		67: Unit	constructor(emit, [66], 2)
		72: Type	const_prim(I64)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: OperandSize	constructor(operand_size, [14], 2)
		75: MInst	make_variant(MInst::AluRRR, [34, 74, 73, 53, 97])
		76: Unit	constructor(emit, [75], 3)
		77: Reg	constructor(writable_reg_to_reg, [73], 0)
		83: Type	const_prim(I64)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: OperandSize	constructor(operand_size, [14], 2)
		86: MInst	make_variant(MInst::AluRRRR, [40, 85, 84, 77, 97, 53])
		87: Unit	constructor(emit, [86], 3)
		88: Reg	constructor(writable_reg_to_reg, [84], 0)
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::Extend, [94, 57, 58, 60, 61])
		96: Unit	constructor(emit, [95], 2)
		97: Reg	constructor(writable_reg_to_reg, [94], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		56:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(45)
		20: Type	extractor(value_type, 10)
		21: Reg	constructor(put_in_reg, [10], 1)
		23: Option(Inst)	extractor(def_inst, 12)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(u64)	extractor(nonzero_u64_from_imm64, 26)
		28: Type	extractor(value_type, 12)
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	match_some(27)
		31: Reg	constructor(imm, [28, 29, 30], 1)
		35: ALUOp	make_variant(ALUOp::UDiv, [])
		41: ALUOp3	make_variant(ALUOp3::MSub, [])
		44: ValueRegs	constructor(value_reg, [66], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [35, 52, 51, 21, 31])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: OperandSize	constructor(operand_size, [14], 2)
		64: MInst	make_variant(MInst::AluRRRR, [41, 63, 62, 55, 31, 21])
		65: Unit	constructor(emit, [64], 3)
		66: Reg	constructor(writable_reg_to_reg, [62], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		23:	some
		25:	some
		27:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 10)
		21: Reg	constructor(put_in_reg, [10], 1)
		28: ALUOp	make_variant(ALUOp::UDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [67], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 12)
		41: Reg	constructor(put_in_reg, [12], 1)
		43: CondBrKind	constructor(cond_br_zero, [41], 1)
		44: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		45: MInst	make_variant(MInst::TrapIf, [43, 44])
		46: Unit	constructor(emit, [45], 2)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: OperandSize	constructor(operand_size, [14], 2)
		54: MInst	make_variant(MInst::AluRRR, [28, 53, 52, 21, 41])
		55: Unit	constructor(emit, [54], 3)
		56: Reg	constructor(writable_reg_to_reg, [52], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: OperandSize	constructor(operand_size, [14], 2)
		65: MInst	make_variant(MInst::AluRRRR, [34, 64, 63, 56, 41, 21])
		66: Unit	constructor(emit, [65], 3)
		67: Reg	constructor(writable_reg_to_reg, [63], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		40:	const_prim(I64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 10)
		21: Reg	constructor(put_in_reg, [10], 1)
		28: ALUOp	make_variant(ALUOp::UDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [73], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 12)
		41: Option(Type)	extractor(fits_in_32, 40)
		42: Reg	constructor(put_in_reg, [12], 1)
		43: bool	const_prim(false)
		44: Type	match_some(41)
		45: u8	constructor(ty_bits, [44], 0)
		46: u8	const_int(64, u8)
		49: CondBrKind	constructor(cond_br_zero, [82], 1)
		50: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		51: MInst	make_variant(MInst::TrapIf, [49, 50])
		52: Unit	constructor(emit, [51], 2)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [14], 2)
		60: MInst	make_variant(MInst::AluRRR, [28, 59, 58, 21, 82])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: OperandSize	constructor(operand_size, [14], 2)
		71: MInst	make_variant(MInst::AluRRRR, [34, 70, 69, 62, 82, 21])
		72: Unit	constructor(emit, [71], 3)
		73: Reg	constructor(writable_reg_to_reg, [69], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: MInst	make_variant(MInst::Extend, [79, 42, 43, 45, 46])
		81: Unit	constructor(emit, [80], 2)
		82: Reg	constructor(writable_reg_to_reg, [79], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		41:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(51)
		20: Type	extractor(value_type, 10)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [10], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		29: Option(Inst)	extractor(def_inst, 12)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(u64)	extractor(nonzero_u64_from_imm64, 32)
		34: Type	extractor(value_type, 12)
		35: ImmExtend	make_variant(ImmExtend::Zero, [])
		36: u64	match_some(33)
		37: Reg	constructor(imm, [34, 35, 36], 1)
		41: ALUOp	make_variant(ALUOp::UDiv, [])
		47: ALUOp3	make_variant(ALUOp3::MSub, [])
		50: ValueRegs	constructor(value_reg, [81], 1)
		51: InstOutput	constructor(output, [50], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::Extend, [57, 22, 23, 25, 26])
		59: Unit	constructor(emit, [58], 2)
		60: Reg	constructor(writable_reg_to_reg, [57], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [14], 2)
		68: MInst	make_variant(MInst::AluRRR, [41, 67, 66, 60, 37])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: OperandSize	constructor(operand_size, [14], 2)
		79: MInst	make_variant(MInst::AluRRRR, [47, 78, 77, 70, 37, 60])
		80: Unit	constructor(emit, [79], 3)
		81: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 10)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [10], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [82], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::Extend, [50, 22, 23, 25, 26])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		55: Type	extractor(value_type, 12)
		56: Reg	constructor(put_in_reg, [12], 1)
		58: CondBrKind	constructor(cond_br_zero, [56], 1)
		59: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		60: MInst	make_variant(MInst::TrapIf, [58, 59])
		61: Unit	constructor(emit, [60], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [14], 2)
		69: MInst	make_variant(MInst::AluRRR, [34, 68, 67, 53, 56])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [14], 2)
		80: MInst	make_variant(MInst::AluRRRR, [40, 79, 78, 71, 56, 53])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		55:	const_prim(I64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 10)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [10], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [88], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::Extend, [50, 22, 23, 25, 26])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		55: Type	extractor(value_type, 12)
		56: Option(Type)	extractor(fits_in_32, 55)
		57: Reg	constructor(put_in_reg, [12], 1)
		58: bool	const_prim(false)
		59: Type	match_some(56)
		60: u8	constructor(ty_bits, [59], 0)
		61: u8	const_int(64, u8)
		64: CondBrKind	constructor(cond_br_zero, [97], 1)
		65: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		66: MInst	make_variant(MInst::TrapIf, [64, 65])
		67: Unit	constructor(emit, [66], 2)
		72: Type	const_prim(I64)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: OperandSize	constructor(operand_size, [14], 2)
		75: MInst	make_variant(MInst::AluRRR, [34, 74, 73, 53, 97])
		76: Unit	constructor(emit, [75], 3)
		77: Reg	constructor(writable_reg_to_reg, [73], 0)
		83: Type	const_prim(I64)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: OperandSize	constructor(operand_size, [14], 2)
		86: MInst	make_variant(MInst::AluRRRR, [40, 85, 84, 77, 97, 53])
		87: Unit	constructor(emit, [86], 3)
		88: Reg	constructor(writable_reg_to_reg, [84], 0)
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::Extend, [94, 57, 58, 60, 61])
		96: Unit	constructor(emit, [95], 2)
		97: Reg	constructor(writable_reg_to_reg, [94], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		56:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmExtend	make_variant(ImmExtend::Sign, [])
		20: u64	match_some(16)
		21: Reg	constructor(imm, [14, 19, 20], 2)
		22: Type	const_prim(I64)
		25: Option(InstOutput)	some(36)
		27: Type	extractor(value_type, 17)
		28: Reg	constructor(put_in_reg, [17], 1)
		32: ALUOp	make_variant(ALUOp::SDiv, [])
		35: ValueRegs	constructor(value_reg, [46], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: OperandSize	constructor(operand_size, [22], 2)
		44: MInst	make_variant(MInst::AluRRR, [32, 43, 42, 28, 21])
		45: Unit	constructor(emit, [44], 3)
		46: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		27:	const_prim(I64)
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmExtend	make_variant(ImmExtend::Sign, [])
		20: u64	match_some(16)
		21: Reg	constructor(imm, [14, 19, 20], 2)
		22: Type	const_prim(I64)
		25: Option(InstOutput)	some(42)
		27: Type	extractor(value_type, 17)
		28: Option(Type)	extractor(fits_in_32, 27)
		29: Reg	constructor(put_in_reg, [17], 1)
		30: bool	const_prim(true)
		31: Type	match_some(28)
		32: u8	constructor(ty_bits, [31], 0)
		33: u8	const_int(64, u8)
		38: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ValueRegs	constructor(value_reg, [61], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::Extend, [48, 29, 30, 32, 33])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [22], 2)
		59: MInst	make_variant(MInst::AluRRR, [38, 58, 57, 51, 21])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		28:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3001
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(62)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		24: Option(Inst)	extractor(def_inst, 12)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(u64)	extractor(nonzero_u64_from_imm64, 27)
		29: Type	extractor(value_type, 12)
		30: ImmExtend	make_variant(ImmExtend::Sign, [])
		31: u64	match_some(28)
		32: Reg	constructor(imm, [29, 30, 31], 1)
		36: OperandSize	constructor(operand_size, [14], 1)
		37: WritableReg	constructor(writable_zero_reg, [], 2)
		38: u8	const_int(1, u8)
		39: Imm12	constructor(u8_into_imm12, [38], 3)
		40: ALUOp	make_variant(ALUOp::AddS, [])
		41: MInst	make_variant(MInst::AluRRImm12, [40, 36, 37, 32, 39])
		42: Unit	constructor(emit, [41], 4)
		44: UImm5	constructor(u8_into_uimm5, [38], 6)
		45: bool	const_prim(false)
		46: NZCV	constructor(nzcv, [45, 45, 45, 45], 7)
		47: Cond	make_variant(Cond::Eq, [])
		48: MInst	make_variant(MInst::CCmpImm, [64, 22, 44, 46, 47])
		49: Unit	constructor(emit, [48], 8)
		50: Cond	make_variant(Cond::Vs, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 9)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: Unit	constructor(emit, [53], 10)
		58: ALUOp	make_variant(ALUOp::SDiv, [])
		61: ValueRegs	constructor(value_reg, [74], 1)
		62: InstOutput	constructor(output, [61], 2)
		64: OperandSize	make_variant(OperandSize::Size64, [])
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: OperandSize	constructor(operand_size, [16], 2)
		72: MInst	make_variant(MInst::AluRRR, [58, 71, 70, 22, 32])
		73: Unit	constructor(emit, [72], 3)
		74: Reg	constructor(writable_reg_to_reg, [70], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		14:	const_prim(I64)
		21:	const_prim(I64)
		24:	some
		26:	some
		28:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3000
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(62)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		24: Option(Inst)	extractor(def_inst, 12)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(u64)	extractor(nonzero_u64_from_imm64, 27)
		29: Type	extractor(value_type, 12)
		30: ImmExtend	make_variant(ImmExtend::Sign, [])
		31: u64	match_some(28)
		32: Reg	constructor(imm, [29, 30, 31], 1)
		36: OperandSize	constructor(operand_size, [14], 1)
		37: WritableReg	constructor(writable_zero_reg, [], 2)
		38: u8	const_int(1, u8)
		39: Imm12	constructor(u8_into_imm12, [38], 3)
		40: ALUOp	make_variant(ALUOp::AddS, [])
		41: MInst	make_variant(MInst::AluRRImm12, [40, 36, 37, 32, 39])
		42: Unit	constructor(emit, [41], 4)
		44: UImm5	constructor(u8_into_uimm5, [38], 6)
		45: bool	const_prim(false)
		46: NZCV	constructor(nzcv, [45, 45, 45, 45], 7)
		47: Cond	make_variant(Cond::Eq, [])
		48: MInst	make_variant(MInst::CCmpImm, [65, 22, 44, 46, 47])
		49: Unit	constructor(emit, [48], 8)
		50: Cond	make_variant(Cond::Vs, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 9)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: Unit	constructor(emit, [53], 10)
		58: ALUOp	make_variant(ALUOp::SDiv, [])
		61: ValueRegs	constructor(value_reg, [75], 1)
		62: InstOutput	constructor(output, [61], 2)
		64: Option(Type)	extractor(fits_in_32, 14)
		65: OperandSize	make_variant(OperandSize::Size32, [])
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: OperandSize	constructor(operand_size, [16], 2)
		73: MInst	make_variant(MInst::AluRRR, [58, 72, 71, 22, 32])
		74: Unit	constructor(emit, [73], 3)
		75: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
		24:	some
		26:	some
		28:	some
		64:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3001
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(55)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		29: OperandSize	constructor(operand_size, [14], 1)
		30: WritableReg	constructor(writable_zero_reg, [], 2)
		31: u8	const_int(1, u8)
		32: Imm12	constructor(u8_into_imm12, [31], 3)
		33: ALUOp	make_variant(ALUOp::AddS, [])
		34: MInst	make_variant(MInst::AluRRImm12, [33, 29, 30, 58, 32])
		35: Unit	constructor(emit, [34], 4)
		37: UImm5	constructor(u8_into_uimm5, [31], 6)
		38: bool	const_prim(false)
		39: NZCV	constructor(nzcv, [38, 38, 38, 38], 7)
		40: Cond	make_variant(Cond::Eq, [])
		41: MInst	make_variant(MInst::CCmpImm, [65, 22, 37, 39, 40])
		42: Unit	constructor(emit, [41], 8)
		43: Cond	make_variant(Cond::Vs, [])
		44: CondBrKind	constructor(cond_br_cond, [43], 9)
		45: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		46: MInst	make_variant(MInst::TrapIf, [44, 45])
		47: Unit	constructor(emit, [46], 10)
		51: ALUOp	make_variant(ALUOp::SDiv, [])
		54: ValueRegs	constructor(value_reg, [75], 1)
		55: InstOutput	constructor(output, [54], 2)
		57: Type	extractor(value_type, 12)
		58: Reg	constructor(put_in_reg, [12], 1)
		60: CondBrKind	constructor(cond_br_zero, [58], 1)
		61: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		62: MInst	make_variant(MInst::TrapIf, [60, 61])
		63: Unit	constructor(emit, [62], 2)
		65: OperandSize	make_variant(OperandSize::Size64, [])
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: OperandSize	constructor(operand_size, [16], 2)
		73: MInst	make_variant(MInst::AluRRR, [51, 72, 71, 22, 58])
		74: Unit	constructor(emit, [73], 3)
		75: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		14:	const_prim(I64)
		21:	const_prim(I64)
		57:	const_prim(I64)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3000
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(55)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		29: OperandSize	constructor(operand_size, [14], 1)
		30: WritableReg	constructor(writable_zero_reg, [], 2)
		31: u8	const_int(1, u8)
		32: Imm12	constructor(u8_into_imm12, [31], 3)
		33: ALUOp	make_variant(ALUOp::AddS, [])
		34: MInst	make_variant(MInst::AluRRImm12, [33, 29, 30, 58, 32])
		35: Unit	constructor(emit, [34], 4)
		37: UImm5	constructor(u8_into_uimm5, [31], 6)
		38: bool	const_prim(false)
		39: NZCV	constructor(nzcv, [38, 38, 38, 38], 7)
		40: Cond	make_variant(Cond::Eq, [])
		41: MInst	make_variant(MInst::CCmpImm, [66, 22, 37, 39, 40])
		42: Unit	constructor(emit, [41], 8)
		43: Cond	make_variant(Cond::Vs, [])
		44: CondBrKind	constructor(cond_br_cond, [43], 9)
		45: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		46: MInst	make_variant(MInst::TrapIf, [44, 45])
		47: Unit	constructor(emit, [46], 10)
		51: ALUOp	make_variant(ALUOp::SDiv, [])
		54: ValueRegs	constructor(value_reg, [76], 1)
		55: InstOutput	constructor(output, [54], 2)
		57: Type	extractor(value_type, 12)
		58: Reg	constructor(put_in_reg, [12], 1)
		60: CondBrKind	constructor(cond_br_zero, [58], 1)
		61: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		62: MInst	make_variant(MInst::TrapIf, [60, 61])
		63: Unit	constructor(emit, [62], 2)
		65: Option(Type)	extractor(fits_in_32, 14)
		66: OperandSize	make_variant(OperandSize::Size32, [])
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: OperandSize	constructor(operand_size, [16], 2)
		74: MInst	make_variant(MInst::AluRRR, [51, 73, 72, 22, 58])
		75: Unit	constructor(emit, [74], 3)
		76: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
		57:	const_prim(I64)
		65:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3001
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(55)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		29: OperandSize	constructor(operand_size, [14], 1)
		30: WritableReg	constructor(writable_zero_reg, [], 2)
		31: u8	const_int(1, u8)
		32: Imm12	constructor(u8_into_imm12, [31], 3)
		33: ALUOp	make_variant(ALUOp::AddS, [])
		34: MInst	make_variant(MInst::AluRRImm12, [33, 29, 30, 90, 32])
		35: Unit	constructor(emit, [34], 4)
		37: UImm5	constructor(u8_into_uimm5, [31], 6)
		38: bool	const_prim(false)
		39: NZCV	constructor(nzcv, [38, 38, 38, 38], 7)
		40: Cond	make_variant(Cond::Eq, [])
		41: MInst	make_variant(MInst::CCmpImm, [71, 22, 37, 39, 40])
		42: Unit	constructor(emit, [41], 8)
		43: Cond	make_variant(Cond::Vs, [])
		44: CondBrKind	constructor(cond_br_cond, [43], 9)
		45: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		46: MInst	make_variant(MInst::TrapIf, [44, 45])
		47: Unit	constructor(emit, [46], 10)
		51: ALUOp	make_variant(ALUOp::SDiv, [])
		54: ValueRegs	constructor(value_reg, [81], 1)
		55: InstOutput	constructor(output, [54], 2)
		57: Type	extractor(value_type, 12)
		58: Option(Type)	extractor(fits_in_32, 57)
		59: Reg	constructor(put_in_reg, [12], 1)
		60: bool	const_prim(true)
		61: Type	match_some(58)
		62: u8	constructor(ty_bits, [61], 0)
		63: u8	const_int(64, u8)
		66: CondBrKind	constructor(cond_br_zero, [90], 1)
		67: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		68: MInst	make_variant(MInst::TrapIf, [66, 67])
		69: Unit	constructor(emit, [68], 2)
		71: OperandSize	make_variant(OperandSize::Size64, [])
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: OperandSize	constructor(operand_size, [16], 2)
		79: MInst	make_variant(MInst::AluRRR, [51, 78, 77, 22, 90])
		80: Unit	constructor(emit, [79], 3)
		81: Reg	constructor(writable_reg_to_reg, [77], 0)
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::Extend, [87, 59, 60, 62, 63])
		89: Unit	constructor(emit, [88], 2)
		90: Reg	constructor(writable_reg_to_reg, [87], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		14:	const_prim(I64)
		21:	const_prim(I64)
		58:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3000
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(55)
		21: Type	extractor(value_type, 10)
		22: Reg	constructor(put_in_reg, [10], 1)
		29: OperandSize	constructor(operand_size, [14], 1)
		30: WritableReg	constructor(writable_zero_reg, [], 2)
		31: u8	const_int(1, u8)
		32: Imm12	constructor(u8_into_imm12, [31], 3)
		33: ALUOp	make_variant(ALUOp::AddS, [])
		34: MInst	make_variant(MInst::AluRRImm12, [33, 29, 30, 91, 32])
		35: Unit	constructor(emit, [34], 4)
		37: UImm5	constructor(u8_into_uimm5, [31], 6)
		38: bool	const_prim(false)
		39: NZCV	constructor(nzcv, [38, 38, 38, 38], 7)
		40: Cond	make_variant(Cond::Eq, [])
		41: MInst	make_variant(MInst::CCmpImm, [72, 22, 37, 39, 40])
		42: Unit	constructor(emit, [41], 8)
		43: Cond	make_variant(Cond::Vs, [])
		44: CondBrKind	constructor(cond_br_cond, [43], 9)
		45: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		46: MInst	make_variant(MInst::TrapIf, [44, 45])
		47: Unit	constructor(emit, [46], 10)
		51: ALUOp	make_variant(ALUOp::SDiv, [])
		54: ValueRegs	constructor(value_reg, [82], 1)
		55: InstOutput	constructor(output, [54], 2)
		57: Type	extractor(value_type, 12)
		58: Option(Type)	extractor(fits_in_32, 57)
		59: Reg	constructor(put_in_reg, [12], 1)
		60: bool	const_prim(true)
		61: Type	match_some(58)
		62: u8	constructor(ty_bits, [61], 0)
		63: u8	const_int(64, u8)
		66: CondBrKind	constructor(cond_br_zero, [91], 1)
		67: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		68: MInst	make_variant(MInst::TrapIf, [66, 67])
		69: Unit	constructor(emit, [68], 2)
		71: Option(Type)	extractor(fits_in_32, 14)
		72: OperandSize	make_variant(OperandSize::Size32, [])
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [16], 2)
		80: MInst	make_variant(MInst::AluRRR, [51, 79, 78, 22, 91])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: MInst	make_variant(MInst::Extend, [88, 59, 60, 62, 63])
		90: Unit	constructor(emit, [89], 2)
		91: Reg	constructor(writable_reg_to_reg, [88], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
		58:	some
		71:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 3001
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(68)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		30: Option(Inst)	extractor(def_inst, 12)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(u64)	extractor(nonzero_u64_from_imm64, 33)
		35: Type	extractor(value_type, 12)
		36: ImmExtend	make_variant(ImmExtend::Sign, [])
		37: u64	match_some(34)
		38: Reg	constructor(imm, [35, 36, 37], 1)
		42: OperandSize	constructor(operand_size, [14], 1)
		43: WritableReg	constructor(writable_zero_reg, [], 2)
		44: u8	const_int(1, u8)
		45: Imm12	constructor(u8_into_imm12, [44], 3)
		46: ALUOp	make_variant(ALUOp::AddS, [])
		47: MInst	make_variant(MInst::AluRRImm12, [46, 42, 43, 38, 45])
		48: Unit	constructor(emit, [47], 4)
		50: UImm5	constructor(u8_into_uimm5, [44], 6)
		51: bool	const_prim(false)
		52: NZCV	constructor(nzcv, [51, 51, 51, 51], 7)
		53: Cond	make_variant(Cond::Eq, [])
		54: MInst	make_variant(MInst::CCmpImm, [79, 77, 50, 52, 53])
		55: Unit	constructor(emit, [54], 8)
		56: Cond	make_variant(Cond::Vs, [])
		57: CondBrKind	constructor(cond_br_cond, [56], 9)
		58: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		59: MInst	make_variant(MInst::TrapIf, [57, 58])
		60: Unit	constructor(emit, [59], 10)
		64: ALUOp	make_variant(ALUOp::SDiv, [])
		67: ValueRegs	constructor(value_reg, [89], 1)
		68: InstOutput	constructor(output, [67], 2)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: MInst	make_variant(MInst::Extend, [74, 23, 24, 26, 27])
		76: Unit	constructor(emit, [75], 2)
		77: Reg	constructor(writable_reg_to_reg, [74], 0)
		79: OperandSize	make_variant(OperandSize::Size64, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: OperandSize	constructor(operand_size, [16], 2)
		87: MInst	make_variant(MInst::AluRRR, [64, 86, 85, 77, 38])
		88: Unit	constructor(emit, [87], 3)
		89: Reg	constructor(writable_reg_to_reg, [85], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		14:	const_prim(I64)
		22:	some
		30:	some
		32:	some
		34:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 3000
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(68)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		30: Option(Inst)	extractor(def_inst, 12)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(u64)	extractor(nonzero_u64_from_imm64, 33)
		35: Type	extractor(value_type, 12)
		36: ImmExtend	make_variant(ImmExtend::Sign, [])
		37: u64	match_some(34)
		38: Reg	constructor(imm, [35, 36, 37], 1)
		42: OperandSize	constructor(operand_size, [14], 1)
		43: WritableReg	constructor(writable_zero_reg, [], 2)
		44: u8	const_int(1, u8)
		45: Imm12	constructor(u8_into_imm12, [44], 3)
		46: ALUOp	make_variant(ALUOp::AddS, [])
		47: MInst	make_variant(MInst::AluRRImm12, [46, 42, 43, 38, 45])
		48: Unit	constructor(emit, [47], 4)
		50: UImm5	constructor(u8_into_uimm5, [44], 6)
		51: bool	const_prim(false)
		52: NZCV	constructor(nzcv, [51, 51, 51, 51], 7)
		53: Cond	make_variant(Cond::Eq, [])
		54: MInst	make_variant(MInst::CCmpImm, [80, 77, 50, 52, 53])
		55: Unit	constructor(emit, [54], 8)
		56: Cond	make_variant(Cond::Vs, [])
		57: CondBrKind	constructor(cond_br_cond, [56], 9)
		58: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		59: MInst	make_variant(MInst::TrapIf, [57, 58])
		60: Unit	constructor(emit, [59], 10)
		64: ALUOp	make_variant(ALUOp::SDiv, [])
		67: ValueRegs	constructor(value_reg, [90], 1)
		68: InstOutput	constructor(output, [67], 2)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: MInst	make_variant(MInst::Extend, [74, 23, 24, 26, 27])
		76: Unit	constructor(emit, [75], 2)
		77: Reg	constructor(writable_reg_to_reg, [74], 0)
		79: Option(Type)	extractor(fits_in_32, 14)
		80: OperandSize	make_variant(OperandSize::Size32, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: OperandSize	constructor(operand_size, [16], 2)
		88: MInst	make_variant(MInst::AluRRR, [64, 87, 86, 77, 38])
		89: Unit	constructor(emit, [88], 3)
		90: Reg	constructor(writable_reg_to_reg, [86], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		30:	some
		32:	some
		34:	some
		79:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3001
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(61)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		35: OperandSize	constructor(operand_size, [14], 1)
		36: WritableReg	constructor(writable_zero_reg, [], 2)
		37: u8	const_int(1, u8)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		39: ALUOp	make_variant(ALUOp::AddS, [])
		40: MInst	make_variant(MInst::AluRRImm12, [39, 35, 36, 73, 38])
		41: Unit	constructor(emit, [40], 4)
		43: UImm5	constructor(u8_into_uimm5, [37], 6)
		44: bool	const_prim(false)
		45: NZCV	constructor(nzcv, [44, 44, 44, 44], 7)
		46: Cond	make_variant(Cond::Eq, [])
		47: MInst	make_variant(MInst::CCmpImm, [80, 70, 43, 45, 46])
		48: Unit	constructor(emit, [47], 8)
		49: Cond	make_variant(Cond::Vs, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 9)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: Unit	constructor(emit, [52], 10)
		57: ALUOp	make_variant(ALUOp::SDiv, [])
		60: ValueRegs	constructor(value_reg, [90], 1)
		61: InstOutput	constructor(output, [60], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::Extend, [67, 23, 24, 26, 27])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
		72: Type	extractor(value_type, 12)
		73: Reg	constructor(put_in_reg, [12], 1)
		75: CondBrKind	constructor(cond_br_zero, [73], 1)
		76: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		77: MInst	make_variant(MInst::TrapIf, [75, 76])
		78: Unit	constructor(emit, [77], 2)
		80: OperandSize	make_variant(OperandSize::Size64, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: OperandSize	constructor(operand_size, [16], 2)
		88: MInst	make_variant(MInst::AluRRR, [57, 87, 86, 70, 73])
		89: Unit	constructor(emit, [88], 3)
		90: Reg	constructor(writable_reg_to_reg, [86], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		14:	const_prim(I64)
		22:	some
		72:	const_prim(I64)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3000
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(61)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		35: OperandSize	constructor(operand_size, [14], 1)
		36: WritableReg	constructor(writable_zero_reg, [], 2)
		37: u8	const_int(1, u8)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		39: ALUOp	make_variant(ALUOp::AddS, [])
		40: MInst	make_variant(MInst::AluRRImm12, [39, 35, 36, 73, 38])
		41: Unit	constructor(emit, [40], 4)
		43: UImm5	constructor(u8_into_uimm5, [37], 6)
		44: bool	const_prim(false)
		45: NZCV	constructor(nzcv, [44, 44, 44, 44], 7)
		46: Cond	make_variant(Cond::Eq, [])
		47: MInst	make_variant(MInst::CCmpImm, [81, 70, 43, 45, 46])
		48: Unit	constructor(emit, [47], 8)
		49: Cond	make_variant(Cond::Vs, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 9)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: Unit	constructor(emit, [52], 10)
		57: ALUOp	make_variant(ALUOp::SDiv, [])
		60: ValueRegs	constructor(value_reg, [91], 1)
		61: InstOutput	constructor(output, [60], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::Extend, [67, 23, 24, 26, 27])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
		72: Type	extractor(value_type, 12)
		73: Reg	constructor(put_in_reg, [12], 1)
		75: CondBrKind	constructor(cond_br_zero, [73], 1)
		76: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		77: MInst	make_variant(MInst::TrapIf, [75, 76])
		78: Unit	constructor(emit, [77], 2)
		80: Option(Type)	extractor(fits_in_32, 14)
		81: OperandSize	make_variant(OperandSize::Size32, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: OperandSize	constructor(operand_size, [16], 2)
		89: MInst	make_variant(MInst::AluRRR, [57, 88, 87, 70, 73])
		90: Unit	constructor(emit, [89], 3)
		91: Reg	constructor(writable_reg_to_reg, [87], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		72:	const_prim(I64)
		80:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3001
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(61)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		35: OperandSize	constructor(operand_size, [14], 1)
		36: WritableReg	constructor(writable_zero_reg, [], 2)
		37: u8	const_int(1, u8)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		39: ALUOp	make_variant(ALUOp::AddS, [])
		40: MInst	make_variant(MInst::AluRRImm12, [39, 35, 36, 105, 38])
		41: Unit	constructor(emit, [40], 4)
		43: UImm5	constructor(u8_into_uimm5, [37], 6)
		44: bool	const_prim(false)
		45: NZCV	constructor(nzcv, [44, 44, 44, 44], 7)
		46: Cond	make_variant(Cond::Eq, [])
		47: MInst	make_variant(MInst::CCmpImm, [86, 70, 43, 45, 46])
		48: Unit	constructor(emit, [47], 8)
		49: Cond	make_variant(Cond::Vs, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 9)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: Unit	constructor(emit, [52], 10)
		57: ALUOp	make_variant(ALUOp::SDiv, [])
		60: ValueRegs	constructor(value_reg, [96], 1)
		61: InstOutput	constructor(output, [60], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::Extend, [67, 23, 24, 26, 27])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
		72: Type	extractor(value_type, 12)
		73: Option(Type)	extractor(fits_in_32, 72)
		74: Reg	constructor(put_in_reg, [12], 1)
		75: bool	const_prim(true)
		76: Type	match_some(73)
		77: u8	constructor(ty_bits, [76], 0)
		78: u8	const_int(64, u8)
		81: CondBrKind	constructor(cond_br_zero, [105], 1)
		82: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		83: MInst	make_variant(MInst::TrapIf, [81, 82])
		84: Unit	constructor(emit, [83], 2)
		86: OperandSize	make_variant(OperandSize::Size64, [])
		91: Type	const_prim(I64)
		92: WritableReg	constructor(temp_writable_reg, [91], 1)
		93: OperandSize	constructor(operand_size, [16], 2)
		94: MInst	make_variant(MInst::AluRRR, [57, 93, 92, 70, 105])
		95: Unit	constructor(emit, [94], 3)
		96: Reg	constructor(writable_reg_to_reg, [92], 0)
		101: Type	const_prim(I64)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: MInst	make_variant(MInst::Extend, [102, 74, 75, 77, 78])
		104: Unit	constructor(emit, [103], 2)
		105: Reg	constructor(writable_reg_to_reg, [102], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		14:	const_prim(I64)
		22:	some
		73:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2995
		../../codegen/src/isa/aarch64/inst.isle line 3000
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(61)
		21: Type	extractor(value_type, 10)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [10], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		35: OperandSize	constructor(operand_size, [14], 1)
		36: WritableReg	constructor(writable_zero_reg, [], 2)
		37: u8	const_int(1, u8)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		39: ALUOp	make_variant(ALUOp::AddS, [])
		40: MInst	make_variant(MInst::AluRRImm12, [39, 35, 36, 106, 38])
		41: Unit	constructor(emit, [40], 4)
		43: UImm5	constructor(u8_into_uimm5, [37], 6)
		44: bool	const_prim(false)
		45: NZCV	constructor(nzcv, [44, 44, 44, 44], 7)
		46: Cond	make_variant(Cond::Eq, [])
		47: MInst	make_variant(MInst::CCmpImm, [87, 70, 43, 45, 46])
		48: Unit	constructor(emit, [47], 8)
		49: Cond	make_variant(Cond::Vs, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 9)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: Unit	constructor(emit, [52], 10)
		57: ALUOp	make_variant(ALUOp::SDiv, [])
		60: ValueRegs	constructor(value_reg, [97], 1)
		61: InstOutput	constructor(output, [60], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::Extend, [67, 23, 24, 26, 27])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
		72: Type	extractor(value_type, 12)
		73: Option(Type)	extractor(fits_in_32, 72)
		74: Reg	constructor(put_in_reg, [12], 1)
		75: bool	const_prim(true)
		76: Type	match_some(73)
		77: u8	constructor(ty_bits, [76], 0)
		78: u8	const_int(64, u8)
		81: CondBrKind	constructor(cond_br_zero, [106], 1)
		82: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		83: MInst	make_variant(MInst::TrapIf, [81, 82])
		84: Unit	constructor(emit, [83], 2)
		86: Option(Type)	extractor(fits_in_32, 14)
		87: OperandSize	make_variant(OperandSize::Size32, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: OperandSize	constructor(operand_size, [16], 2)
		95: MInst	make_variant(MInst::AluRRR, [57, 94, 93, 70, 106])
		96: Unit	constructor(emit, [95], 3)
		97: Reg	constructor(writable_reg_to_reg, [93], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: MInst	make_variant(MInst::Extend, [103, 74, 75, 77, 78])
		105: Unit	constructor(emit, [104], 2)
		106: Reg	constructor(writable_reg_to_reg, [103], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		73:	some
		86:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2678
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(38)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		22: Option(Inst)	extractor(def_inst, 12)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(u64)	extractor(nonzero_u64_from_imm64, 25)
		27: Type	extractor(value_type, 12)
		28: ImmExtend	make_variant(ImmExtend::Zero, [])
		29: u64	match_some(26)
		30: Reg	constructor(imm, [27, 28, 29], 1)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		37: ValueRegs	constructor(value_reg, [48], 1)
		38: InstOutput	constructor(output, [37], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [14], 2)
		46: MInst	make_variant(MInst::AluRRR, [34, 45, 44, 20, 30])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		22:	some
		24:	some
		26:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(31)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		27: ALUOp	make_variant(ALUOp::UDiv, [])
		30: ValueRegs	constructor(value_reg, [49], 1)
		31: InstOutput	constructor(output, [30], 2)
		33: Type	extractor(value_type, 12)
		34: Reg	constructor(put_in_reg, [12], 1)
		36: CondBrKind	constructor(cond_br_zero, [34], 1)
		37: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		38: MInst	make_variant(MInst::TrapIf, [36, 37])
		39: Unit	constructor(emit, [38], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [14], 2)
		47: MInst	make_variant(MInst::AluRRR, [27, 46, 45, 20, 34])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		33:	const_prim(I64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(31)
		19: Type	extractor(value_type, 10)
		20: Reg	constructor(put_in_reg, [10], 1)
		27: ALUOp	make_variant(ALUOp::UDiv, [])
		30: ValueRegs	constructor(value_reg, [55], 1)
		31: InstOutput	constructor(output, [30], 2)
		33: Type	extractor(value_type, 12)
		34: Option(Type)	extractor(fits_in_32, 33)
		35: Reg	constructor(put_in_reg, [12], 1)
		36: bool	const_prim(false)
		37: Type	match_some(34)
		38: u8	constructor(ty_bits, [37], 0)
		39: u8	const_int(64, u8)
		42: CondBrKind	constructor(cond_br_zero, [64], 1)
		43: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		44: MInst	make_variant(MInst::TrapIf, [42, 43])
		45: Unit	constructor(emit, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [27, 52, 51, 20, 64])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::Extend, [61, 35, 36, 38, 39])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		34:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2678
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(44)
		19: Type	extractor(value_type, 10)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [10], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		28: Option(Inst)	extractor(def_inst, 12)
		29: Inst	match_some(28)
		30: Option(Imm64)	extractor(iconst, 29)
		31: Imm64	match_some(30)
		32: Option(u64)	extractor(nonzero_u64_from_imm64, 31)
		33: Type	extractor(value_type, 12)
		34: ImmExtend	make_variant(ImmExtend::Zero, [])
		35: u64	match_some(32)
		36: Reg	constructor(imm, [33, 34, 35], 1)
		40: ALUOp	make_variant(ALUOp::UDiv, [])
		43: ValueRegs	constructor(value_reg, [63], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::Extend, [50, 21, 22, 24, 25])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: OperandSize	constructor(operand_size, [14], 2)
		61: MInst	make_variant(MInst::AluRRR, [40, 60, 59, 53, 36])
		62: Unit	constructor(emit, [61], 3)
		63: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(37)
		19: Type	extractor(value_type, 10)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [10], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		36: ValueRegs	constructor(value_reg, [64], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 21, 22, 24, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: Type	extractor(value_type, 12)
		49: Reg	constructor(put_in_reg, [12], 1)
		51: CondBrKind	constructor(cond_br_zero, [49], 1)
		52: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: Unit	constructor(emit, [53], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: OperandSize	constructor(operand_size, [14], 2)
		62: MInst	make_variant(MInst::AluRRR, [33, 61, 60, 46, 49])
		63: Unit	constructor(emit, [62], 3)
		64: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		48:	const_prim(I64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2678
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2995
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(37)
		19: Type	extractor(value_type, 10)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [10], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		36: ValueRegs	constructor(value_reg, [70], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::Extend, [43, 21, 22, 24, 25])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: Type	extractor(value_type, 12)
		49: Option(Type)	extractor(fits_in_32, 48)
		50: Reg	constructor(put_in_reg, [12], 1)
		51: bool	const_prim(false)
		52: Type	match_some(49)
		53: u8	constructor(ty_bits, [52], 0)
		54: u8	const_int(64, u8)
		57: CondBrKind	constructor(cond_br_zero, [79], 1)
		58: TrapCode	constructor(trap_code_division_by_zero, [], 0)
		59: MInst	make_variant(MInst::TrapIf, [57, 58])
		60: Unit	constructor(emit, [59], 2)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [14], 2)
		68: MInst	make_variant(MInst::AluRRR, [33, 67, 66, 46, 79])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::Extend, [76, 50, 51, 53, 54])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		49:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [61], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 10)
		26: Reg	constructor(put_in_reg, [10], 1)
		28: Type	extractor(value_type, 12)
		29: Reg	constructor(put_in_reg, [12], 1)
		34: ALUOp3	make_variant(ALUOp3::MAdd, [])
		39: ALUOp	make_variant(ALUOp::Lsr, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [15], 2)
		49: MInst	make_variant(MInst::AluRRRR, [34, 48, 47, 26, 29, 14])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [15], 2)
		59: MInst	make_variant(MInst::AluRRImmShift, [39, 58, 57, 51, 19])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	const_prim(I64)
		28:	const_prim(I64)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [76], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 10)
		26: Reg	constructor(put_in_reg, [10], 1)
		28: Type	extractor(value_type, 12)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [12], 1)
		31: bool	const_prim(false)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(64, u8)
		40: ALUOp3	make_variant(ALUOp3::MAdd, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: MInst	make_variant(MInst::Extend, [52, 30, 31, 33, 34])
		54: Unit	constructor(emit, [53], 2)
		55: Reg	constructor(writable_reg_to_reg, [52], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: OperandSize	constructor(operand_size, [15], 2)
		64: MInst	make_variant(MInst::AluRRRR, [40, 63, 62, 26, 55, 14])
		65: Unit	constructor(emit, [64], 3)
		66: Reg	constructor(writable_reg_to_reg, [62], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: OperandSize	constructor(operand_size, [15], 2)
		74: MInst	make_variant(MInst::AluRRImmShift, [45, 73, 72, 66, 19])
		75: Unit	constructor(emit, [74], 3)
		76: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	const_prim(I64)
		29:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2990
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [76], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 10)
		26: Option(Type)	extractor(fits_in_32, 25)
		27: Reg	constructor(put_in_reg, [10], 1)
		28: bool	const_prim(false)
		29: Type	match_some(26)
		30: u8	constructor(ty_bits, [29], 0)
		31: u8	const_int(64, u8)
		34: Type	extractor(value_type, 12)
		35: Reg	constructor(put_in_reg, [12], 1)
		40: ALUOp3	make_variant(ALUOp3::MAdd, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: MInst	make_variant(MInst::Extend, [52, 27, 28, 30, 31])
		54: Unit	constructor(emit, [53], 2)
		55: Reg	constructor(writable_reg_to_reg, [52], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: OperandSize	constructor(operand_size, [15], 2)
		64: MInst	make_variant(MInst::AluRRRR, [40, 63, 62, 55, 35, 14])
		65: Unit	constructor(emit, [64], 3)
		66: Reg	constructor(writable_reg_to_reg, [62], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: OperandSize	constructor(operand_size, [15], 2)
		74: MInst	make_variant(MInst::AluRRImmShift, [45, 73, 72, 66, 19])
		75: Unit	constructor(emit, [74], 3)
		76: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		26:	some
		34:	const_prim(I64)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2986
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [91], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 10)
		26: Option(Type)	extractor(fits_in_32, 25)
		27: Reg	constructor(put_in_reg, [10], 1)
		28: bool	const_prim(false)
		29: Type	match_some(26)
		30: u8	constructor(ty_bits, [29], 0)
		31: u8	const_int(64, u8)
		34: Type	extractor(value_type, 12)
		35: Option(Type)	extractor(fits_in_32, 34)
		36: Reg	constructor(put_in_reg, [12], 1)
		37: bool	const_prim(false)
		38: Type	match_some(35)
		39: u8	constructor(ty_bits, [38], 0)
		40: u8	const_int(64, u8)
		46: ALUOp3	make_variant(ALUOp3::MAdd, [])
		51: ALUOp	make_variant(ALUOp::Lsr, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::Extend, [58, 27, 28, 30, 31])
		60: Unit	constructor(emit, [59], 2)
		61: Reg	constructor(writable_reg_to_reg, [58], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::Extend, [67, 36, 37, 39, 40])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: OperandSize	constructor(operand_size, [15], 2)
		79: MInst	make_variant(MInst::AluRRRR, [46, 78, 77, 61, 70, 14])
		80: Unit	constructor(emit, [79], 3)
		81: Reg	constructor(writable_reg_to_reg, [77], 0)
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: OperandSize	constructor(operand_size, [15], 2)
		89: MInst	make_variant(MInst::AluRRImmShift, [51, 88, 87, 81, 19])
		90: Unit	constructor(emit, [89], 3)
		91: Reg	constructor(writable_reg_to_reg, [87], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		26:	some
		35:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 949
		../../codegen/src/isa/aarch64/inst.isle line 2513
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umulhi, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Type	const_prim(I64)
		16: Option(InstOutput)	some(24)
		20: ALUOp	make_variant(ALUOp::UMulH, [])
		23: ValueRegs	constructor(value_reg, [34], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [13], 2)
		32: MInst	make_variant(MInst::AluRRR, [20, 31, 30, 10, 12])
		33: Unit	constructor(emit, [32], 3)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2660
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(42)
		24: Type	extractor(value_type, 10)
		25: Reg	constructor(put_in_reg, [10], 1)
		27: Type	extractor(value_type, 12)
		28: Reg	constructor(put_in_reg, [12], 1)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::Asr, [])
		41: ValueRegs	constructor(value_reg, [63], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRRR, [33, 50, 49, 25, 28, 14])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: OperandSize	constructor(operand_size, [15], 2)
		61: MInst	make_variant(MInst::AluRRImmShift, [38, 60, 59, 53, 19])
		62: Unit	constructor(emit, [61], 3)
		63: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
		27:	const_prim(I64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2660
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(48)
		24: Type	extractor(value_type, 10)
		25: Reg	constructor(put_in_reg, [10], 1)
		27: Type	extractor(value_type, 12)
		28: Option(Type)	extractor(fits_in_32, 27)
		29: Reg	constructor(put_in_reg, [12], 1)
		30: bool	const_prim(true)
		31: Type	match_some(28)
		32: u8	constructor(ty_bits, [31], 0)
		33: u8	const_int(64, u8)
		39: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::Asr, [])
		47: ValueRegs	constructor(value_reg, [78], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::Extend, [54, 29, 30, 32, 33])
		56: Unit	constructor(emit, [55], 2)
		57: Reg	constructor(writable_reg_to_reg, [54], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: OperandSize	constructor(operand_size, [15], 2)
		66: MInst	make_variant(MInst::AluRRRR, [39, 65, 64, 25, 57, 14])
		67: Unit	constructor(emit, [66], 3)
		68: Reg	constructor(writable_reg_to_reg, [64], 0)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: OperandSize	constructor(operand_size, [15], 2)
		76: MInst	make_variant(MInst::AluRRImmShift, [44, 75, 74, 68, 19])
		77: Unit	constructor(emit, [76], 3)
		78: Reg	constructor(writable_reg_to_reg, [74], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
		28:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2982
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2660
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(48)
		24: Type	extractor(value_type, 10)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [10], 1)
		27: bool	const_prim(true)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(64, u8)
		33: Type	extractor(value_type, 12)
		34: Reg	constructor(put_in_reg, [12], 1)
		39: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::Asr, [])
		47: ValueRegs	constructor(value_reg, [78], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::Extend, [54, 26, 27, 29, 30])
		56: Unit	constructor(emit, [55], 2)
		57: Reg	constructor(writable_reg_to_reg, [54], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: OperandSize	constructor(operand_size, [15], 2)
		66: MInst	make_variant(MInst::AluRRRR, [39, 65, 64, 57, 34, 14])
		67: Unit	constructor(emit, [66], 3)
		68: Reg	constructor(writable_reg_to_reg, [64], 0)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: OperandSize	constructor(operand_size, [15], 2)
		76: MInst	make_variant(MInst::AluRRImmShift, [44, 75, 74, 68, 19])
		77: Unit	constructor(emit, [76], 3)
		78: Reg	constructor(writable_reg_to_reg, [74], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
		33:	const_prim(I64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2978
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2660
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(54)
		24: Type	extractor(value_type, 10)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [10], 1)
		27: bool	const_prim(true)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(64, u8)
		33: Type	extractor(value_type, 12)
		34: Option(Type)	extractor(fits_in_32, 33)
		35: Reg	constructor(put_in_reg, [12], 1)
		36: bool	const_prim(true)
		37: Type	match_some(34)
		38: u8	constructor(ty_bits, [37], 0)
		39: u8	const_int(64, u8)
		45: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::Asr, [])
		53: ValueRegs	constructor(value_reg, [93], 1)
		54: InstOutput	constructor(output, [53], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::Extend, [60, 26, 27, 29, 30])
		62: Unit	constructor(emit, [61], 2)
		63: Reg	constructor(writable_reg_to_reg, [60], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: MInst	make_variant(MInst::Extend, [69, 35, 36, 38, 39])
		71: Unit	constructor(emit, [70], 2)
		72: Reg	constructor(writable_reg_to_reg, [69], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: OperandSize	constructor(operand_size, [15], 2)
		81: MInst	make_variant(MInst::AluRRRR, [45, 80, 79, 63, 72, 14])
		82: Unit	constructor(emit, [81], 3)
		83: Reg	constructor(writable_reg_to_reg, [79], 0)
		88: Type	const_prim(I64)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: OperandSize	constructor(operand_size, [15], 2)
		91: MInst	make_variant(MInst::AluRRImmShift, [50, 90, 89, 83, 19])
		92: Unit	constructor(emit, [91], 3)
		93: Reg	constructor(writable_reg_to_reg, [89], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
		34:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 937
		../../codegen/src/isa/aarch64/inst.isle line 2517
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smulhi, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Type	const_prim(I64)
		16: Option(InstOutput)	some(24)
		20: ALUOp	make_variant(ALUOp::SMulH, [])
		23: ValueRegs	constructor(value_reg, [34], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [13], 2)
		32: MInst	make_variant(MInst::AluRRR, [20, 31, 30, 10, 12])
		33: Unit	constructor(emit, [32], 3)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 930
		../../codegen/src/isa/aarch64/inst.isle line 2653
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 924
		../../codegen/src/isa/aarch64/inst.isle line 2653
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 918
		../../codegen/src/isa/aarch64/inst.isle line 2649
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 912
		../../codegen/src/isa/aarch64/inst.isle line 2649
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I32X4)
		16:	some
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 906
		../../codegen/src/isa/aarch64/inst.isle line 2645
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 900
		../../codegen/src/isa/aarch64/inst.isle line 2645
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 894
		../../codegen/src/isa/aarch64/inst.isle line 2641
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 888
		../../codegen/src/isa/aarch64/inst.isle line 2641
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I16X8)
		16:	some
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 882
		../../codegen/src/isa/aarch64/inst.isle line 2637
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 876
		../../codegen/src/isa/aarch64/inst.isle line 2637
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 870
		../../codegen/src/isa/aarch64/inst.isle line 2633
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 864
		../../codegen/src/isa/aarch64/inst.isle line 2633
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		33: ValueRegs	constructor(value_reg, [43], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecRRRLong, [30, 40, 21, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I8X16)
		16:	some
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 825
		../../codegen/src/isa/aarch64/inst.isle line 2537
		../../codegen/src/isa/aarch64/inst.isle line 2521
		../../codegen/src/isa/aarch64/inst.isle line 2541
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/isa/aarch64/inst.isle line 2541
		../../codegen/src/isa/aarch64/inst.isle line 2611
		../../codegen/src/isa/aarch64/inst.isle line 2629
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2216
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VectorSize	make_variant(VectorSize::Size32x4, [])
		16: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: bool	const_prim(false)
		24: Option(InstOutput)	some(59)
		27: VecMisc2	make_variant(VecMisc2::Rev64, [])
		32: VecALUOp	make_variant(VecALUOp::Mul, [])
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		41: VecALUOp	make_variant(VecALUOp::Addp, [])
		45: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		49: VecRRLongOp	make_variant(VecRRLongOp::Shll32, [])
		55: VecRRRLongModOp	make_variant(VecRRRLongModOp::Umlal32, [])
		58: ValueRegs	constructor(value_reg, [119], 1)
		59: InstOutput	constructor(output, [58], 2)
		63: Type	const_prim(I8X16)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::VecMisc, [27, 64, 12, 13])
		66: Unit	constructor(emit, [65], 2)
		67: Reg	constructor(writable_reg_to_reg, [64], 0)
		72: Type	const_prim(I8X16)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: MInst	make_variant(MInst::VecRRR, [32, 73, 67, 10, 13])
		75: Unit	constructor(emit, [74], 2)
		76: Reg	constructor(writable_reg_to_reg, [73], 0)
		80: Type	const_prim(I8X16)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: MInst	make_variant(MInst::VecRRNarrowLow, [36, 81, 10, 16])
		83: Unit	constructor(emit, [82], 2)
		84: Reg	constructor(writable_reg_to_reg, [81], 0)
		89: Type	const_prim(I8X16)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: MInst	make_variant(MInst::VecRRR, [41, 90, 76, 76, 13])
		92: Unit	constructor(emit, [91], 2)
		93: Reg	constructor(writable_reg_to_reg, [90], 0)
		97: Type	const_prim(I8X16)
		98: WritableReg	constructor(temp_writable_reg, [97], 1)
		99: MInst	make_variant(MInst::VecRRNarrowLow, [45, 98, 12, 16])
		100: Unit	constructor(emit, [99], 2)
		101: Reg	constructor(writable_reg_to_reg, [98], 0)
		105: Type	const_prim(I8X16)
		106: WritableReg	constructor(temp_writable_reg, [105], 1)
		107: MInst	make_variant(MInst::VecRRLong, [49, 106, 93, 20])
		108: Unit	constructor(emit, [107], 2)
		109: Reg	constructor(writable_reg_to_reg, [106], 0)
		115: Type	const_prim(I8X16)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::VecRRRLongMod, [55, 116, 109, 101, 84, 20])
		118: Unit	constructor(emit, [117], 2)
		119: Reg	constructor(writable_reg_to_reg, [116], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 793
		../../codegen/src/isa/aarch64/inst.isle line 2521
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option(())	extractor(not_i64x2, 9)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [9], 3)
		19: Option(InstOutput)	some(27)
		23: VecALUOp	make_variant(VecALUOp::Mul, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 13, 15, 16])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 765
		../../codegen/src/isa/aarch64/inst.isle line 2513
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2480
		alu_rrr_to_emit
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Value	match_tuple(8, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 4)
		17: Reg	constructor(value_regs_get, [16, 11], 5)
		18: Reg	constructor(value_regs_get, [16, 13], 6)
		19: Type	const_prim(I64)
		23: Reg	constructor(zero_reg, [], 10)
		25: ValueRegs	constructor(value_regs, [93, 82], 12)
		26: InstOutput	constructor(output, [25], 13)
		27: Option(InstOutput)	some(26)
		31: ALUOp	make_variant(ALUOp::UMulH, [])
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp3	make_variant(ALUOp3::MAdd, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [19], 2)
		58: MInst	make_variant(MInst::AluRRR, [31, 57, 56, 12, 17])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [19], 2)
		69: MInst	make_variant(MInst::AluRRRR, [37, 68, 67, 12, 18, 60])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: OperandSize	constructor(operand_size, [19], 2)
		80: MInst	make_variant(MInst::AluRRRR, [43, 79, 78, 14, 17, 71])
		81: Unit	constructor(emit, [80], 3)
		82: Reg	constructor(writable_reg_to_reg, [78], 0)
		88: Type	const_prim(I64)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: OperandSize	constructor(operand_size, [19], 2)
		91: MInst	make_variant(MInst::AluRRRR, [49, 90, 89, 12, 17, 23])
		92: Unit	constructor(emit, [91], 3)
		93: Reg	constructor(writable_reg_to_reg, [89], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 761
		../../codegen/src/isa/aarch64/inst.isle line 2480
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(27)
		23: ALUOp3	make_variant(ALUOp3::MAdd, [])
		26: ValueRegs	constructor(value_reg, [38], 1)
		27: InstOutput	constructor(output, [26], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [15], 2)
		36: MInst	make_variant(MInst::AluRRRR, [23, 35, 34, 11, 13, 14])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 755
		../../codegen/src/isa/aarch64/inst.isle line 2525
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(22)
		18: VecMisc2	make_variant(VecMisc2::Neg, [])
		21: ValueRegs	constructor(value_reg, [30], 1)
		22: InstOutput	constructor(output, [21], 2)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 10, 12])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1849
		../../codegen/src/isa/aarch64/inst.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 2089
		../../codegen/src/isa/aarch64/inst.isle line 2134
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [31], 4)
		13: Option(InstOutput)	some(12)
		14: Type	const_prim(I64)
		15: ImmExtend	make_variant(ImmExtend::Zero, [])
		16: u64	const_int(0, u64)
		17: Reg	constructor(imm, [14, 15, 16], 1)
		18: Reg	constructor(imm, [14, 15, 16], 2)
		19: ValueRegs	constructor(value_regs, [17, 18], 3)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [19, 22], 1)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [19, 24], 2)
		26: Reg	constructor(value_regs_get, [10, 22], 3)
		27: Reg	constructor(value_regs_get, [10, 24], 4)
		28: Type	const_prim(I64)
		31: ValueRegs	constructor(with_flags, [41, 51], 7)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [28], 2)
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: MInst	make_variant(MInst::AluRRR, [38, 37, 36, 23, 26])
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [39, 40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [28], 2)
		48: ALUOp	make_variant(ALUOp::Sbc, [])
		49: MInst	make_variant(MInst::AluRRR, [48, 47, 46, 25, 27])
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
		51: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [49, 50])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 747
		../../codegen/src/isa/aarch64/inst.isle line 2445
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Reg	constructor(zero_reg, [], 1)
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_some(6)
		15: Option(InstOutput)	some(23)
		19: ALUOp	make_variant(ALUOp::Sub, [])
		22: ValueRegs	constructor(value_reg, [33], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: OperandSize	constructor(operand_size, [12], 2)
		31: MInst	make_variant(MInst::AluRRR, [19, 30, 29, 9, 11])
		32: Unit	constructor(emit, [31], 3)
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 741
		../../codegen/src/isa/aarch64/inst.isle line 2509
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Sqsub, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 736
		../../codegen/src/isa/aarch64/inst.isle line 2505
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Uqsub, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 731
		../../codegen/src/isa/aarch64/inst.isle line 2501
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Sqadd, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 726
		../../codegen/src/isa/aarch64/inst.isle line 2497
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Uqadd, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 15])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 2089
		../../codegen/src/isa/aarch64/inst.isle line 2134
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [27], 4)
		15: Option(InstOutput)	some(14)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 1)
		20: usize	const_int(1, usize)
		21: Reg	constructor(value_regs_get, [10, 20], 2)
		22: Reg	constructor(value_regs_get, [12, 18], 3)
		23: Reg	constructor(value_regs_get, [12, 20], 4)
		24: Type	const_prim(I64)
		27: ValueRegs	constructor(with_flags, [37, 47], 7)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [24], 2)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: MInst	make_variant(MInst::AluRRR, [34, 33, 32, 19, 22])
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [35, 36])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: OperandSize	constructor(operand_size, [24], 2)
		44: ALUOp	make_variant(ALUOp::Sbc, [])
		45: MInst	make_variant(MInst::AluRRR, [44, 43, 42, 21, 23])
		46: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [45, 46])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 717
		../../codegen/src/isa/aarch64/inst.isle line 2457
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		17: Option(InstOutput)	some(25)
		21: VecALUOp	make_variant(VecALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [34], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRR, [21, 31, 11, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 711
		../../codegen/src/isa/aarch64/inst.isle line 2454
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(38)
		34: ALUOp	make_variant(ALUOp::Sub, [])
		37: ValueRegs	constructor(value_reg, [49], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [19], 2)
		47: MInst	make_variant(MInst::AluRRRShift, [34, 46, 45, 23, 25, 26])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 706
		../../codegen/src/isa/aarch64/inst.isle line 2451
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2036
		../../codegen/src/isa/aarch64/inst.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Sub, [])
		25: ValueRegs	constructor(value_reg, [44], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Reg	constructor(put_extended_in_reg, [15], 1)
		32: ExtendOp	constructor(get_extended_op, [15], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRRExtend, [22, 41, 40, 13, 31, 32])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 700
		../../codegen/src/isa/aarch64/inst.isle line 1803
		../../codegen/src/isa/aarch64/inst.isle line 2428
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(33)
		18: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Type, Inst))	extractor(has_type, 21)
		23: (Type, Inst)	match_some(22)
		24: Inst	match_tuple(23, 1)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Type	match_tuple(23, 0)
		27: Imm64	match_some(25)
		28: i64	constructor(i64_sextend_imm64, [26, 27], 0)
		29: i64	constructor(i64_neg, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		31: Option(Imm12)	extractor(imm12_from_u64, 30)
		32: Imm12	match_some(31)
		33: Option(Imm12)	some(32)
		37: ALUOp	make_variant(ALUOp::Add, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [14], 2)
		49: MInst	make_variant(MInst::AluRRImm12, [37, 48, 47, 13, 15])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		22:	some
		25:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 695
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Sub, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [14], 2)
		34: MInst	make_variant(MInst::AluRRImm12, [22, 33, 32, 13, 15])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 691
		../../codegen/src/isa/aarch64/inst.isle line 2445
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		17: Option(InstOutput)	some(25)
		21: ALUOp	make_variant(ALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [35], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: OperandSize	constructor(operand_size, [14], 2)
		33: MInst	make_variant(MInst::AluRRR, [21, 32, 31, 11, 13])
		34: Unit	constructor(emit, [33], 3)
		35: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 683
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 677
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 674
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 671
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 668
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 663
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 660
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 657
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 654
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 651
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 648
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 643
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::I64ToF64, [])
		14: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::IntToFpu, [11, 18, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 640
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::I64ToF32, [])
		14: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::IntToFpu, [11, 18, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(34)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::IntToFpu, [12, 28, 43])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::Extend, [40, 19, 20, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		18:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(34)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::IntToFpu, [12, 28, 43])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::Extend, [40, 19, 20, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		18:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 631
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 628
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 623
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::U64ToF64, [])
		14: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::IntToFpu, [11, 18, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 620
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::U64ToF32, [])
		14: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::IntToFpu, [11, 18, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(34)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::IntToFpu, [12, 28, 43])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::Extend, [40, 19, 20, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		18:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(28)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::IntToFpu, [12, 22, 18])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 3680
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(34)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::IntToFpu, [12, 28, 43])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::Extend, [40, 19, 20, 22, 23])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		18:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 611
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 608
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		21: Option(InstOutput)	some(32)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [18, 26, 16, 17])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 603
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [64], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 10])
		43: ValueRegs	constructor(with_flags, [69, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [74, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::FpuToInt, [11, 61, 57])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: MInst	make_variant(MInst::FpuCmp, [23, 10, 10])
		69: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [68])
		73: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		74: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [73])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 600
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		13: bool	const_prim(true)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 11])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [12, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 11, 11])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 597
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [64], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 10])
		43: ValueRegs	constructor(with_flags, [69, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [74, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::FpuToInt, [11, 61, 57])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: MInst	make_variant(MInst::FpuCmp, [23, 10, 10])
		69: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [68])
		73: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		74: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [73])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 594
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		13: bool	const_prim(true)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 11])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [12, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 11, 11])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 589
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [64], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 10])
		43: ValueRegs	constructor(with_flags, [69, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [74, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::FpuToInt, [11, 61, 57])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: MInst	make_variant(MInst::FpuCmp, [23, 10, 10])
		69: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [68])
		73: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		74: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [73])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 586
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		13: bool	const_prim(false)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 11])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [12, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 11, 11])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 583
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [64], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 10])
		43: ValueRegs	constructor(with_flags, [69, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [74, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::FpuToInt, [11, 61, 57])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: MInst	make_variant(MInst::FpuCmp, [23, 10, 10])
		69: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [68])
		73: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		74: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [73])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 580
		../../codegen/src/isa/aarch64/inst.isle line 3624
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		13: bool	const_prim(false)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 11])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [12, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 11, 11])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3552
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3542
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 3542
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option((u32, u32))	extractor(multi_lane, 12)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	constructor(lane_type, [12], 0)
		24: VectorSize	constructor(vector_size, [12], 3)
		26: VectorSize	constructor(vector_size, [12], 5)
		28: VecShiftImmModOp	make_variant(VecShiftImmModOp::Sli, [])
		29: MInst	make_variant(MInst::VecShiftImmMod, [28, 21, 9, 52, 26, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(31, u8)
		40: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		43: u8	const_int(31, u8)
		48: Type	const_prim(I8X16)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::VecShiftImm, [40, 49, 11, 24, 36])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3552
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3542
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 3541
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option((u32, u32))	extractor(multi_lane, 12)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	constructor(lane_type, [12], 0)
		24: VectorSize	constructor(vector_size, [12], 3)
		26: VectorSize	constructor(vector_size, [12], 5)
		28: VecShiftImmModOp	make_variant(VecShiftImmModOp::Sli, [])
		29: MInst	make_variant(MInst::VecShiftImmMod, [28, 21, 9, 52, 26, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(31, u8)
		40: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		43: u8	const_int(63, u8)
		48: Type	const_prim(I8X16)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::VecShiftImm, [40, 49, 11, 24, 36])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3552
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3541
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 3542
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option((u32, u32))	extractor(multi_lane, 12)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	constructor(lane_type, [12], 0)
		24: VectorSize	constructor(vector_size, [12], 3)
		26: VectorSize	constructor(vector_size, [12], 5)
		28: VecShiftImmModOp	make_variant(VecShiftImmModOp::Sli, [])
		29: MInst	make_variant(MInst::VecShiftImmMod, [28, 21, 9, 52, 26, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(63, u8)
		40: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		43: u8	const_int(31, u8)
		48: Type	const_prim(I8X16)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::VecShiftImm, [40, 49, 11, 24, 36])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3552
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3541
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 3541
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option((u32, u32))	extractor(multi_lane, 12)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	constructor(lane_type, [12], 0)
		24: VectorSize	constructor(vector_size, [12], 3)
		26: VectorSize	constructor(vector_size, [12], 5)
		28: VecShiftImmModOp	make_variant(VecShiftImmModOp::Sli, [])
		29: MInst	make_variant(MInst::VecShiftImmMod, [28, 21, 9, 52, 26, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(63, u8)
		40: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		43: u8	const_int(63, u8)
		48: Type	const_prim(I8X16)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::VecShiftImm, [40, 49, 11, 24, 36])
		51: Unit	constructor(emit, [50], 2)
		52: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3547
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3542
		../../codegen/src/isa/aarch64/inst.isle line 1928
		../../codegen/src/isa/aarch64/inst.isle line 3542
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option(Type)	extractor(ty_scalar_float, 12)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	match_some(19)
		24: u8	constructor(ty_bits, [22], 0)
		25: FPUOpRI	constructor(fpu_op_ri_ushr, [24, 36], 3)
		28: FPUOpRIMod	constructor(fpu_op_ri_sli, [24, 45], 6)
		29: MInst	make_variant(MInst::FpuRRIMod, [28, 21, 9, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(31, u8)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuRRI, [25, 40, 11])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: u8	const_int(31, u8)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3547
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3542
		../../codegen/src/isa/aarch64/inst.isle line 1928
		../../codegen/src/isa/aarch64/inst.isle line 3541
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option(Type)	extractor(ty_scalar_float, 12)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	match_some(19)
		24: u8	constructor(ty_bits, [22], 0)
		25: FPUOpRI	constructor(fpu_op_ri_ushr, [24, 36], 3)
		28: FPUOpRIMod	constructor(fpu_op_ri_sli, [24, 45], 6)
		29: MInst	make_variant(MInst::FpuRRIMod, [28, 21, 9, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(31, u8)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuRRI, [25, 40, 11])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: u8	const_int(63, u8)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3547
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3541
		../../codegen/src/isa/aarch64/inst.isle line 1928
		../../codegen/src/isa/aarch64/inst.isle line 3542
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option(Type)	extractor(ty_scalar_float, 12)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	match_some(19)
		24: u8	constructor(ty_bits, [22], 0)
		25: FPUOpRI	constructor(fpu_op_ri_ushr, [24, 36], 3)
		28: FPUOpRIMod	constructor(fpu_op_ri_sli, [24, 45], 6)
		29: MInst	make_variant(MInst::FpuRRIMod, [28, 21, 9, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(63, u8)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuRRI, [25, 40, 11])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: u8	const_int(31, u8)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F32)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3547
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 3541
		../../codegen/src/isa/aarch64/inst.isle line 1928
		../../codegen/src/isa/aarch64/inst.isle line 3541
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(34)
		19: Option(Type)	extractor(ty_scalar_float, 12)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Type	match_some(19)
		24: u8	constructor(ty_bits, [22], 0)
		25: FPUOpRI	constructor(fpu_op_ri_ushr, [24, 36], 3)
		28: FPUOpRIMod	constructor(fpu_op_ri_sli, [24, 45], 6)
		29: MInst	make_variant(MInst::FpuRRIMod, [28, 21, 9, 43])
		30: Unit	constructor(emit, [29], 7)
		31: Reg	constructor(writable_reg_to_reg, [21], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
		36: u8	const_int(63, u8)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::FpuRRI, [25, 40, 11])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: u8	const_int(63, u8)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
		22:	const_prim(F64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 520
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: VectorSize	constructor(vector_size, [5], 1)
		10: VecALUModOp	make_variant(VecALUModOp::Fmla, [])
		11: (Value, Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Value	match_tuple(11, 2)
		15: Reg	constructor(lower_fmla, [10, 12, 13, 14, 9], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 516
		../../codegen/src/isa/aarch64/inst.isle line 1948
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: Type	match_some(6)
		10: ScalarSize	constructor(scalar_size, [9], 1)
		11: (Value, Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Value	match_tuple(11, 2)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: FPUOp3	make_variant(FPUOp3::MAdd, [])
		21: Option(InstOutput)	some(34)
		27: Type	const_prim(F64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::FpuRRRR, [18, 10, 28, 13, 15, 17])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 511
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Nearest64, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 508
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Nearest32, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 505
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(nearest, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintn, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 500
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Zero64, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 497
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Zero32, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 494
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(trunc, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintz, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 489
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Minus64, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 486
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Minus32, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 483
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(floor, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintm, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 478
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Plus64, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 475
		../../codegen/src/isa/aarch64/inst.isle line 2246
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Plus32, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuRound, [10, 17, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 472
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ceil, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintp, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 467
		../../codegen/src/isa/aarch64/inst.isle line 1906
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fdemote, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FPUOp1	make_variant(FPUOp1::Cvt64To32, [])
		11: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: Option(InstOutput)	some(25)
		18: Type	const_prim(F64)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::FpuRR, [10, 11, 19, 9])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 462
		../../codegen/src/isa/aarch64/inst.isle line 1906
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fpromote, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FPUOp1	make_variant(FPUOp1::Cvt32To64, [])
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		14: Option(InstOutput)	some(25)
		18: Type	const_prim(F64)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::FpuRR, [10, 11, 19, 9])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 457
		../../codegen/src/isa/aarch64/inst.isle line 1906
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(scalar_size, [11], 2)
		13: FPUOp1	make_variant(FPUOp1::Abs, [])
		16: Option(InstOutput)	some(27)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::FpuRR, [13, 12, 21, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 454
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Fabs, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 449
		../../codegen/src/isa/aarch64/inst.isle line 1906
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(scalar_size, [11], 2)
		13: FPUOp1	make_variant(FPUOp1::Neg, [])
		16: Option(InstOutput)	some(27)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::FpuRR, [13, 12, 21, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 446
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Fneg, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 441
		../../codegen/src/isa/aarch64/inst.isle line 1906
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(scalar_size, [11], 2)
		13: FPUOp1	make_variant(FPUOp1::Sqrt, [])
		16: Option(InstOutput)	some(27)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::FpuRR, [13, 12, 21, 10])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 438
		../../codegen/src/isa/aarch64/inst.isle line 2142
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Fsqrt, [])
		15: Option(InstOutput)	some(26)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecMisc, [12, 20, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 433
		../../codegen/src/isa/aarch64/inst.isle line 1941
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Max, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuRRR, [16, 15, 25, 11, 13])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 430
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmax, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 425
		../../codegen/src/isa/aarch64/inst.isle line 1941
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Min, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuRRR, [16, 15, 25, 11, 13])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 422
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmin, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 417
		../../codegen/src/isa/aarch64/inst.isle line 1941
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Div, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuRRR, [16, 15, 25, 11, 13])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 414
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 409
		../../codegen/src/isa/aarch64/inst.isle line 1941
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Mul, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuRRR, [16, 15, 25, 11, 13])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 406
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmul, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 401
		../../codegen/src/isa/aarch64/inst.isle line 1941
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Sub, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuRRR, [16, 15, 25, 11, 13])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 398
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fsub, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 393
		../../codegen/src/isa/aarch64/inst.isle line 1941
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(8)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Add, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuRRR, [16, 15, 25, 11, 13])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 390
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fadd, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 385
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sqmul_round_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Sqrdmulh, [])
		18: Option(InstOutput)	some(30)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecRRR, [15, 24, 11, 13, 14])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 1899
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(avg_round, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(lane_fits_in_32, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(8)
		15: VectorSize	constructor(vector_size, [14], 3)
		16: VecALUOp	make_variant(VecALUOp::Urhadd, [])
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [16, 25, 11, 13, 15])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 371
		../../codegen/src/isa/aarch64/inst.isle line 2708
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 2440
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(avg_round, 6)
		8: u64	const_int(1, u64)
		9: VectorSize	make_variant(VectorSize::Size64x2, [])
		10: Reg	constructor(splat_const, [8, 9], 1)
		11: (Value, Value)	match_some(7)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		18: Reg	constructor(put_in_reg, [12], 6)
		19: u8	const_int(1, u8)
		21: Reg	constructor(put_in_reg, [14], 8)
		26: Option(InstOutput)	some(59)
		30: VecALUOp	make_variant(VecALUOp::Orr, [])
		35: VecALUOp	make_variant(VecALUOp::And, [])
		40: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		45: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		50: VecALUOp	make_variant(VecALUOp::Add, [])
		55: VecALUOp	make_variant(VecALUOp::Add, [])
		58: ValueRegs	constructor(value_reg, [113], 1)
		59: InstOutput	constructor(output, [58], 2)
		64: Type	const_prim(I8X16)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::VecRRR, [30, 65, 13, 15, 9])
		67: Unit	constructor(emit, [66], 2)
		68: Reg	constructor(writable_reg_to_reg, [65], 0)
		73: Type	const_prim(I8X16)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: MInst	make_variant(MInst::VecRRR, [35, 74, 68, 10, 9])
		76: Unit	constructor(emit, [75], 2)
		77: Reg	constructor(writable_reg_to_reg, [74], 0)
		82: Type	const_prim(I8X16)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: MInst	make_variant(MInst::VecShiftImm, [40, 83, 18, 9, 19])
		85: Unit	constructor(emit, [84], 2)
		86: Reg	constructor(writable_reg_to_reg, [83], 0)
		91: Type	const_prim(I8X16)
		92: WritableReg	constructor(temp_writable_reg, [91], 1)
		93: MInst	make_variant(MInst::VecShiftImm, [45, 92, 21, 9, 19])
		94: Unit	constructor(emit, [93], 2)
		95: Reg	constructor(writable_reg_to_reg, [92], 0)
		100: Type	const_prim(I8X16)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: MInst	make_variant(MInst::VecRRR, [50, 101, 86, 95, 9])
		103: Unit	constructor(emit, [102], 2)
		104: Reg	constructor(writable_reg_to_reg, [101], 0)
		109: Type	const_prim(I8X16)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: MInst	make_variant(MInst::VecRRR, [55, 110, 77, 104, 9])
		112: Unit	constructor(emit, [111], 2)
		113: Reg	constructor(writable_reg_to_reg, [110], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2089
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 1885
		alu_rrr_to_emit
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: usize	const_int(1, usize)
		13: Reg	constructor(value_regs_get, [9, 12], 3)
		14: u8	const_int(63, u8)
		15: ImmShift	constructor(imm_shift_from_u8, [14], 4)
		16: Type	const_prim(I64)
		22: ValueRegs	constructor(with_flags, [49, 59], 10)
		23: InstOutput	constructor(output, [22], 11)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::Asr, [])
		33: ALUOp	make_variant(ALUOp::Eor, [])
		38: ALUOp	make_variant(ALUOp::Eor, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [16], 2)
		46: ALUOp	make_variant(ALUOp::SubS, [])
		47: MInst	make_variant(MInst::AluRRR, [46, 45, 44, 89, 69])
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
		49: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [47, 48])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: OperandSize	constructor(operand_size, [16], 2)
		56: ALUOp	make_variant(ALUOp::Sbc, [])
		57: MInst	make_variant(MInst::AluRRR, [56, 55, 54, 79, 69])
		58: Reg	constructor(writable_reg_to_reg, [54], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [16], 2)
		67: MInst	make_variant(MInst::AluRRImmShift, [28, 66, 65, 13, 15])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: OperandSize	constructor(operand_size, [16], 2)
		77: MInst	make_variant(MInst::AluRRR, [33, 76, 75, 13, 69])
		78: Unit	constructor(emit, [77], 3)
		79: Reg	constructor(writable_reg_to_reg, [75], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: OperandSize	constructor(operand_size, [16], 2)
		87: MInst	make_variant(MInst::AluRRR, [38, 86, 85, 11, 69])
		88: Unit	constructor(emit, [87], 3)
		89: Reg	constructor(writable_reg_to_reg, [85], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2965
		../../codegen/src/isa/aarch64/inst.isle line 2601
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2400
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: Value	match_some(6)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		14: Option(InstOutput)	some(30)
		16: Type	extractor(value_type, 9)
		17: Reg	constructor(put_in_reg, [9], 1)
		20: u8	const_int(0, u8)
		21: Imm12	constructor(u8_into_imm12, [20], 1)
		23: Cond	make_variant(Cond::Gt, [])
		25: ValueRegs	constructor(with_flags, [37, 45], 4)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 5)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: MInst	make_variant(MInst::AluRRImm12, [35, 11, 34, 17, 21])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::CSNeg, [42, 23, 17, 17])
		44: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 44])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		16:	const_prim(I64)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2964
		../../codegen/src/isa/aarch64/inst.isle line 2601
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2400
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: Value	match_some(6)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		14: Option(InstOutput)	some(30)
		16: Type	extractor(value_type, 9)
		17: Reg	constructor(put_in_reg, [9], 1)
		20: u8	const_int(0, u8)
		21: Imm12	constructor(u8_into_imm12, [20], 1)
		23: Cond	make_variant(Cond::Gt, [])
		25: ValueRegs	constructor(with_flags, [37, 45], 4)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 5)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: MInst	make_variant(MInst::AluRRImm12, [35, 11, 34, 17, 21])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::CSNeg, [42, 23, 17, 17])
		44: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 44])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		16:	const_prim(I32)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2960
		../../codegen/src/isa/aarch64/inst.isle line 2601
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2400
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: Value	match_some(6)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		14: Option(InstOutput)	some(36)
		16: Type	extractor(value_type, 9)
		17: Option(Type)	extractor(fits_in_32, 16)
		18: Reg	constructor(put_in_reg, [9], 1)
		19: bool	const_prim(true)
		20: Type	match_some(17)
		21: u8	constructor(ty_bits, [20], 0)
		22: u8	const_int(32, u8)
		26: u8	const_int(0, u8)
		27: Imm12	constructor(u8_into_imm12, [26], 1)
		29: Cond	make_variant(Cond::Gt, [])
		31: ValueRegs	constructor(with_flags, [52, 60], 4)
		32: usize	const_int(0, usize)
		33: Reg	constructor(value_regs_get, [31, 32], 5)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::Extend, [42, 18, 19, 21, 22])
		44: Unit	constructor(emit, [43], 2)
		45: Reg	constructor(writable_reg_to_reg, [42], 0)
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: MInst	make_variant(MInst::AluRRImm12, [50, 11, 49, 45, 27])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSNeg, [57, 29, 45, 45])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [58, 59])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		17:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 345
		../../codegen/src/isa/aarch64/inst.isle line 2601
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2400
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		13: Option(InstOutput)	some(26)
		16: u8	const_int(0, u8)
		17: Imm12	constructor(u8_into_imm12, [16], 1)
		19: Cond	make_variant(Cond::Gt, [])
		21: ValueRegs	constructor(with_flags, [33, 41], 4)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 5)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: WritableReg	constructor(writable_zero_reg, [], 1)
		31: ALUOp	make_variant(ALUOp::SubS, [])
		32: MInst	make_variant(MInst::AluRRImm12, [31, 10, 30, 9, 17])
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [32])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::CSNeg, [38, 19, 9, 9])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [39, 40])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 342
		../../codegen/src/isa/aarch64/inst.isle line 2596
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(iabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		14: Option(InstOutput)	some(21)
		17: VecMisc2	make_variant(VecMisc2::Abs, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 10, 11])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 337
		../../codegen/src/isa/aarch64/inst.isle line 2588
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd_pairwise, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		13: VectorSize	constructor(vector_size, [12], 3)
		16: Option(InstOutput)	some(24)
		20: VecALUOp	make_variant(VecALUOp::Addp, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 13])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 334
		../../codegen/src/isa/aarch64/inst.isle line 2625
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp16, [])
		27: ValueRegs	constructor(value_reg, [35], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRPairLong, [24, 32, 19])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 2622
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp8, [])
		27: ValueRegs	constructor(value_reg, [35], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRPairLong, [24, 32, 19])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 326
		../../codegen/src/isa/aarch64/inst.isle line 2619
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp16, [])
		27: ValueRegs	constructor(value_reg, [35], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRPairLong, [24, 32, 19])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 322
		../../codegen/src/isa/aarch64/inst.isle line 2616
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp8, [])
		27: ValueRegs	constructor(value_reg, [35], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRPairLong, [24, 32, 19])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 3799
		../../codegen/src/isa/aarch64/inst.isle line 2098
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2117
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [42, 27], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
		15: Option(Type)	constructor(ty_vec64, [6], 0)
		16: u8	const_int(0, u8)
		17: ScalarSize	make_variant(ScalarSize::Size64, [])
		19: Imm12	constructor(u8_into_imm12, [16], 2)
		20: OperandSize	make_variant(OperandSize::Size64, [])
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::CSet, [24, 8])
		26: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [25, 26])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::MovFromVec, [32, 5, 16, 17])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: ALUOp	make_variant(ALUOp::SubS, [])
		41: MInst	make_variant(MInst::AluRRImm12, [40, 20, 39, 35, 19])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
	]
	constraints = [
		3:	some
		15:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 3795
		../../codegen/src/isa/aarch64/inst.isle line 2098
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2117
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [54, 30], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
		15: Option(Type)	extractor(ty_vec128, 6)
		16: VecALUOp	make_variant(VecALUOp::Umaxp, [])
		17: VectorSize	make_variant(VectorSize::Size32x4, [])
		19: u8	const_int(0, u8)
		20: ScalarSize	make_variant(ScalarSize::Size64, [])
		22: Imm12	constructor(u8_into_imm12, [19], 3)
		23: OperandSize	make_variant(OperandSize::Size64, [])
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::CSet, [27, 8])
		29: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [28, 29])
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::VecRRR, [16, 36, 5, 5, 17])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::MovFromVec, [44, 39, 19, 20])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [44], 0)
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: ALUOp	make_variant(ALUOp::SubS, [])
		53: MInst	make_variant(MInst::AluRRImm12, [52, 23, 51, 47, 22])
		54: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [53])
	]
	constraints = [
		3:	some
		15:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 306
		../../codegen/src/isa/aarch64/inst.isle line 1961
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Type	match_some(6)
		8: Option(Type)	constructor(not_vec32x2, [7], 0)
		9: Reg	constructor(put_in_reg, [4], 1)
		10: VectorSize	constructor(vector_size, [7], 2)
		11: VecLanesOp	make_variant(VecLanesOp::Uminv, [])
		13: u8	const_int(0, u8)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: Imm12	constructor(u8_into_imm12, [13], 5)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		19: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(with_flags, [46, 52], 8)
		22: InstOutput	constructor(output, [21], 9)
		23: Option(InstOutput)	some(22)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecLanes, [11, 28, 9, 10])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::MovFromVec, [36, 31, 13, 14])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
		43: WritableReg	constructor(writable_zero_reg, [], 1)
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: MInst	make_variant(MInst::AluRRImm12, [44, 17, 43, 39, 16])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 19])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 289
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2011
		../../codegen/src/isa/aarch64/inst.isle line 2415
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: Reg	constructor(put_in_reg, [4], 1)
		11: u8	const_int(0, u8)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: Reg	constructor(zero_reg, [], 3)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: u64	const_int(32, u64)
		18: UImm5	constructor(u8_into_uimm5, [11], 5)
		19: bool	const_prim(false)
		20: bool	const_prim(true)
		21: NZCV	constructor(nzcv, [19, 20, 19, 19], 6)
		22: OperandSize	make_variant(OperandSize::Size32, [])
		23: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(with_flags, [46, 58], 8)
		26: InstOutput	constructor(output, [25], 9)
		27: Option(InstOutput)	some(26)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::MovFromVec, [32, 10, 11, 12])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
		40: Type	const_prim(I64)
		41: Option(ShiftOpAndAmt)	constructor(lshr_from_u64, [40, 16], 0)
		42: WritableReg	constructor(writable_zero_reg, [], 1)
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: ShiftOpAndAmt	match_some(41)
		45: MInst	make_variant(MInst::AluRRRShift, [43, 15, 42, 14, 35, 44])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		55: ValueRegs	constructor(value_reg, [54], 2)
		56: MInst	make_variant(MInst::CCmpImm, [22, 35, 18, 21, 23])
		57: MInst	make_variant(MInst::CSet, [53, 23])
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [56, 57, 55])
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		9:	const_int(2)
		41:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 283
		../../codegen/src/isa/aarch64/inst.isle line 3408
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 2098
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: Reg	constructor(put_in_reg, [4], 1)
		11: VectorSize	make_variant(VectorSize::Size64x2, [])
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: Cond	make_variant(Cond::Eq, [])
		18: ValueRegs	constructor(with_flags, [34, 40], 6)
		19: InstOutput	constructor(output, [18], 7)
		20: Option(InstOutput)	some(19)
		23: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		28: VecALUOp	make_variant(VecALUOp::Addp, [])
		33: MInst	make_variant(MInst::FpuCmp, [14, 57, 57])
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [33])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::CSet, [37, 16])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [38, 39])
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecMisc, [23, 45, 10, 11])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
		53: Type	const_prim(I8X16)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::VecRRR, [28, 54, 48, 48, 11])
		56: Unit	constructor(emit, [55], 2)
		57: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		9:	const_int(2)
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2974
		../../codegen/src/isa/aarch64/inst.isle line 2264
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(24)
		13: Type	extractor(value_type, 4)
		14: Reg	constructor(put_in_reg, [4], 1)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::MovToFpu, [18, 14, 8])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		13:	const_prim(I64)
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2973
		../../codegen/src/isa/aarch64/inst.isle line 2264
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(24)
		13: Type	extractor(value_type, 4)
		14: Reg	constructor(put_in_reg, [4], 1)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::MovToFpu, [18, 14, 8])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		13:	const_prim(I32)
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2969
		../../codegen/src/isa/aarch64/inst.isle line 2264
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2312
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(30)
		13: Type	extractor(value_type, 4)
		14: Option(Type)	extractor(fits_in_32, 13)
		15: Reg	constructor(put_in_reg, [4], 1)
		16: bool	const_prim(false)
		17: Type	match_some(14)
		18: u8	constructor(ty_bits, [17], 0)
		19: u8	const_int(32, u8)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::MovToFpu, [24, 39, 8])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::Extend, [36, 15, 16, 18, 19])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		14:	some
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 266
		../../codegen/src/isa/aarch64/inst.isle line 2264
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: ScalarSize	make_variant(ScalarSize::Size64, [])
		10: Option(InstOutput)	some(20)
		13: Type	const_prim(I8X16)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: MInst	make_variant(MInst::MovToFpu, [14, 6, 7])
		16: Unit	constructor(emit, [15], 2)
		17: Reg	constructor(writable_reg_to_reg, [14], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 263
		../../codegen/src/isa/aarch64/inst.isle line 2319
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F32X4)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuExtend, [17, 9, 10])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64X2)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 260
		../../codegen/src/isa/aarch64/inst.isle line 2319
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		13: Option(InstOutput)	some(23)
		16: Type	const_prim(F32X4)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::FpuExtend, [17, 9, 10])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32X4)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 255
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iconcat, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: ValueRegs	constructor(value_regs, [10, 12], 3)
		14: InstOutput	constructor(output, [13], 4)
		15: Option(InstOutput)	some(14)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 246
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(isplit, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: ValueRegs	constructor(put_in_regs, [4], 1)
		7: usize	const_int(0, usize)
		8: Reg	constructor(value_regs_get, [6, 7], 2)
		9: ValueRegs	constructor(value_reg, [8], 3)
		10: usize	const_int(1, usize)
		11: Reg	constructor(value_regs_get, [6, 10], 4)
		12: ValueRegs	constructor(value_reg, [11], 5)
		13: InstOutput	constructor(output_pair, [9, 12], 6)
		14: Option(InstOutput)	some(13)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 241
		../../codegen/src/isa/aarch64/inst.isle line 2149
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(swizzle, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		14: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::VecTbl, [18, 9, 11])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 235
		../../codegen/src/isa/aarch64/inst.isle line 2162
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Immediate))	extractor(shuffle, 5)
		7: (Value, Value, Immediate)	match_some(6)
		8: Immediate	match_tuple(7, 2)
		9: Option(u128)	extractor(u128_from_immediate, 8)
		10: u128	match_some(9)
		11: Reg	constructor(constant_f128, [10], 1)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(7, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_tuple(4, 0)
		19: Option(InstOutput)	some(31)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecTbl2, [25, 13, 15, 11])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 232
		../../codegen/src/isa/aarch64/inst.isle line 2537
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev64, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(14673614102390417578512422760905835780)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 230
		../../codegen/src/isa/aarch64/inst.isle line 2537
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev64, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(12004814239757670119517129289737963270)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 228
		../../codegen/src/isa/aarch64/inst.isle line 2537
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev64, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(10680758337341567148842519922299176455)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 226
		../../codegen/src/isa/aarch64/inst.isle line 2533
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev32, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(17342576855639742879858139805557719810)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 224
		../../codegen/src/isa/aarch64/inst.isle line 2533
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev32, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(16018520953223639909183530438118932995)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 222
		../../codegen/src/isa/aarch64/inst.isle line 2529
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev16, [])
		19: ValueRegs	constructor(value_reg, [28], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecMisc, [16, 25, 9, 10])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(18687320815856387368178823909286805505)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 212
		../../codegen/src/isa/aarch64/inst.isle line 4185
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909301208165426529540)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 210
		../../codegen/src/isa/aarch64/inst.isle line 4181
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664569647092737326704519438008576)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 208
		../../codegen/src/isa/aarch64/inst.isle line 4185
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142128814346332279593629287318274)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 206
		../../codegen/src/isa/aarch64/inst.isle line 4181
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693260819630515246292341806293057792)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 204
		../../codegen/src/isa/aarch64/inst.isle line 4185
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284541550424544734358823780242100481)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 202
		../../codegen/src/isa/aarch64/inst.isle line 4181
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(39950100895832629191365197868744970240)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 194
		../../codegen/src/isa/aarch64/inst.isle line 4177
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909590568856778836232)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 192
		../../codegen/src/isa/aarch64/inst.isle line 4173
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901951279430565641561564801794304)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 190
		../../codegen/src/isa/aarch64/inst.isle line 4177
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142129435743685477327603181816072)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 188
		../../codegen/src/isa/aarch64/inst.isle line 4173
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686616892700419341528320311204774144)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 186
		../../codegen/src/isa/aarch64/inst.isle line 4177
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284561912683712994304547342093195272)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 184
		../../codegen/src/isa/aarch64/inst.isle line 4173
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30609036675948388650355540050116153344)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 179
		../../codegen/src/isa/aarch64/inst.isle line 4169
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427191743139026172726477975062792)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 177
		../../codegen/src/isa/aarch64/inst.isle line 4165
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901955007814682223719185998020864)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 175
		../../codegen/src/isa/aarch64/inst.isle line 4169
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427190500344320355979912890680580)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 173
		../../codegen/src/isa/aarch64/inst.isle line 4165
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664572132682148381476266902159616)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 171
		../../codegen/src/isa/aarch64/inst.isle line 4169
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362386467224802506860000736977486594)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 169
		../../codegen/src/isa/aarch64/inst.isle line 4165
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693505158040971420872748913983226112)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 167
		../../codegen/src/isa/aarch64/inst.isle line 4169
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41357194091136896220700492464948314881)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 165
		../../codegen/src/isa/aarch64/inst.isle line 4165
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [32], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecRRR, [19, 29, 9, 11, 12])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(40022753436544980677706866553451184640)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 152
		../../codegen/src/isa/aarch64/inst.isle line 2333
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(vec_extract_imm4_from_immediate, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Value	match_tuple(4, 1)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: u8	match_some(6)
		14: Option(InstOutput)	some(25)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecExtract, [19, 8, 10, 11])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 133
		../../codegen/src/isa/aarch64/inst.isle line 1982
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup64_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size64x2, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::VecDupFromFpu, [18, 8, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 131
		../../codegen/src/isa/aarch64/inst.isle line 1982
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup32_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::VecDupFromFpu, [18, 8, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 129
		../../codegen/src/isa/aarch64/inst.isle line 1982
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup16_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::VecDupFromFpu, [18, 8, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 127
		../../codegen/src/isa/aarch64/inst.isle line 1982
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup8_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(24)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::VecDupFromFpu, [18, 8, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2081
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Value	match_tuple(8, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 4)
		17: Reg	constructor(value_regs_get, [16, 11], 5)
		18: Reg	constructor(value_regs_get, [16, 13], 6)
		19: Type	const_prim(I64)
		22: ValueRegs	constructor(with_flags, [34, 44], 9)
		23: InstOutput	constructor(output, [22], 10)
		24: Option(InstOutput)	some(23)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: OperandSize	constructor(operand_size, [19], 2)
		31: ALUOp	make_variant(ALUOp::AddS, [])
		32: MInst	make_variant(MInst::AluRRR, [31, 30, 29, 12, 17])
		33: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [32, 33])
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [19], 2)
		41: ALUOp	make_variant(ALUOp::Adc, [])
		42: MInst	make_variant(MInst::AluRRR, [41, 40, 39, 14, 18])
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [42, 43])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 100
		../../codegen/src/isa/aarch64/inst.isle line 2440
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		17: Option(InstOutput)	some(25)
		21: VecALUOp	make_variant(VecALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [34], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRR, [21, 31, 11, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 95
		../../codegen/src/isa/aarch64/inst.isle line 2485
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Value	match_tuple(9, 0)
		20: Reg	constructor(put_in_reg, [19], 3)
		21: Type	match_some(6)
		24: Option(InstOutput)	some(33)
		29: ALUOp3	make_variant(ALUOp3::MSub, [])
		32: ValueRegs	constructor(value_reg, [44], 1)
		33: InstOutput	constructor(output, [32], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [21], 2)
		42: MInst	make_variant(MInst::AluRRRR, [29, 41, 40, 16, 18, 20])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 91
		../../codegen/src/isa/aarch64/inst.isle line 2480
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Value	match_tuple(9, 1)
		20: Reg	constructor(put_in_reg, [19], 3)
		21: Type	match_some(6)
		24: Option(InstOutput)	some(33)
		29: ALUOp3	make_variant(ALUOp3::MAdd, [])
		32: ValueRegs	constructor(value_reg, [44], 1)
		33: InstOutput	constructor(output, [32], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [21], 2)
		42: MInst	make_variant(MInst::AluRRRR, [29, 41, 40, 16, 18, 20])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 88
		../../codegen/src/isa/aarch64/inst.isle line 2480
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Value	match_tuple(9, 0)
		20: Reg	constructor(put_in_reg, [19], 3)
		21: Type	match_some(6)
		24: Option(InstOutput)	some(33)
		29: ALUOp3	make_variant(ALUOp3::MAdd, [])
		32: ValueRegs	constructor(value_reg, [44], 1)
		33: InstOutput	constructor(output, [32], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [21], 2)
		42: MInst	make_variant(MInst::AluRRRR, [29, 41, 40, 16, 18, 20])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 82
		../../codegen/src/isa/aarch64/inst.isle line 2437
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 1)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(38)
		34: ALUOp	make_variant(ALUOp::Add, [])
		37: ValueRegs	constructor(value_reg, [49], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [19], 2)
		47: MInst	make_variant(MInst::AluRRRShift, [34, 46, 45, 23, 25, 26])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 77
		../../codegen/src/isa/aarch64/inst.isle line 2437
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(38)
		34: ALUOp	make_variant(ALUOp::Add, [])
		37: ValueRegs	constructor(value_reg, [49], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [19], 2)
		47: MInst	make_variant(MInst::AluRRRShift, [34, 46, 45, 23, 25, 26])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 72
		../../codegen/src/isa/aarch64/inst.isle line 2431
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2036
		../../codegen/src/isa/aarch64/inst.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [44], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Reg	constructor(put_extended_in_reg, [15], 1)
		32: ExtendOp	constructor(get_extended_op, [15], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRRExtend, [22, 41, 40, 13, 31, 32])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 69
		../../codegen/src/isa/aarch64/inst.isle line 2431
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2036
		../../codegen/src/isa/aarch64/inst.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [44], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Reg	constructor(put_extended_in_reg, [15], 1)
		32: ExtendOp	constructor(get_extended_op, [15], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRRExtend, [22, 41, 40, 13, 31, 32])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 63
		../../codegen/src/isa/aarch64/inst.isle line 1803
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(33)
		18: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Type, Inst))	extractor(has_type, 21)
		23: (Type, Inst)	match_some(22)
		24: Inst	match_tuple(23, 1)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Type	match_tuple(23, 0)
		27: Imm64	match_some(25)
		28: i64	constructor(i64_sextend_imm64, [26, 27], 0)
		29: i64	constructor(i64_neg, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		31: Option(Imm12)	extractor(imm12_from_u64, 30)
		32: Imm12	match_some(31)
		33: Option(Imm12)	some(32)
		37: ALUOp	make_variant(ALUOp::Sub, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [14], 2)
		49: MInst	make_variant(MInst::AluRRImm12, [37, 48, 47, 13, 15])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		22:	some
		25:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 59
		../../codegen/src/isa/aarch64/inst.isle line 1803
		../../codegen/src/isa/aarch64/inst.isle line 2448
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(33)
		18: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Type, Inst))	extractor(has_type, 21)
		23: (Type, Inst)	match_some(22)
		24: Inst	match_tuple(23, 1)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Type	match_tuple(23, 0)
		27: Imm64	match_some(25)
		28: i64	constructor(i64_sextend_imm64, [26, 27], 0)
		29: i64	constructor(i64_neg, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		31: Option(Imm12)	extractor(imm12_from_u64, 30)
		32: Imm12	match_some(31)
		33: Option(Imm12)	some(32)
		37: ALUOp	make_variant(ALUOp::Sub, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [14], 2)
		49: MInst	make_variant(MInst::AluRRImm12, [37, 48, 47, 13, 15])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		22:	some
		25:	some
		31:	some
		33:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 54
		../../codegen/src/isa/aarch64/inst.isle line 2428
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [14], 2)
		34: MInst	make_variant(MInst::AluRRImm12, [22, 33, 32, 13, 15])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 51
		../../codegen/src/isa/aarch64/inst.isle line 2428
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [14], 2)
		34: MInst	make_variant(MInst::AluRRImm12, [22, 33, 32, 13, 15])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		iadd_base_case
		add_to_alu_rrr
		output_reg
		alu_rrr_to_emit
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		17: Option(InstOutput)	some(25)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [35], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: OperandSize	constructor(operand_size, [14], 2)
		33: MInst	make_variant(MInst::AluRRR, [21, 32, 31, 11, 13])
		34: Unit	constructor(emit, [33], 3)
		35: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 39
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(nop, 0)
		4: Reg	constructor(invalid_reg, [], 1)
		6: Option(InstOutput)	some(9)
		8: ValueRegs	constructor(value_reg, [4], 1)
		9: InstOutput	constructor(output, [8], 2)
	]
	constraints = [
		3:	some
	]
	result = 6
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 34
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee64)	extractor(f64const, 0)
		4: Ieee64	match_some(3)
		5: u64	extractor(u64_from_ieee64, 4)
		6: Reg	constructor(constant_f64, [5], 1)
		8: Option(InstOutput)	some(11)
		10: ValueRegs	constructor(value_reg, [6], 1)
		11: InstOutput	constructor(output, [10], 2)
	]
	constraints = [
		3:	some
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3242
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2264
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		8: Option(InstOutput)	some(18)
		10: Type	const_prim(I32)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	constructor(u32_as_u64, [5], 0)
		13: Reg	constructor(imm, [10, 11, 12], 1)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: ValueRegs	constructor(value_reg, [25], 1)
		18: InstOutput	constructor(output, [17], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::MovToFpu, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
	]
	constraints = [
		3:	some
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3239
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 2271
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		8: Option(InstOutput)	some(17)
		10: u64	constructor(u32_as_u64, [5], 0)
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: Option(ASIMDFPModImm)	constructor(asimd_fp_mod_imm_from_u64, [10, 11], 0)
		13: ASIMDFPModImm	match_some(12)
		16: ValueRegs	constructor(value_reg, [24], 1)
		17: InstOutput	constructor(output, [16], 2)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::FpuMoveFPImm, [21, 13, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
	]
	constraints = [
		3:	some
		12:	some
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3235
		output_reg
		../../codegen/src/isa/aarch64/inst.isle line 1989
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		8: Option(InstOutput)	some(17)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: ASIMDMovModImm	constructor(asimd_mov_mod_imm_zero, [10], 1)
		12: bool	const_prim(false)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		16: ValueRegs	constructor(value_reg, [25], 1)
		17: InstOutput	constructor(output, [16], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecDupImm, [22, 11, 12, 13])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 24
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(())	extractor(null, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: u64	const_int(0, u64)
		10: Reg	constructor(imm, [7, 8, 9], 1)
		12: Option(InstOutput)	some(15)
		14: ValueRegs	constructor(value_reg, [10], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 19
		output_reg
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Imm64)	extractor(iconst, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: Imm64	match_some(6)
		10: u64	extractor(u64_from_imm64, 9)
		11: Reg	constructor(imm, [7, 8, 10], 1)
		13: Option(InstOutput)	some(16)
		15: ValueRegs	constructor(value_reg, [11], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}

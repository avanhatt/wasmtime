inline term: lower
expansions = 802
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 97
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_high, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(true)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 92
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_high, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(true)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 87
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Uimm8))	extractor(extract_vector, 0)
		4: (Value, Uimm8)	match_some(3)
		5: Uimm8	match_tuple(4, 1)
		6: Value	match_tuple(4, 0)
		7: Reg	constructor(put_in_reg, [6], 1)
		8: ValueRegs	constructor(value_reg, [7], 2)
		9: InstOutput	constructor(output, [8], 3)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 81
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(DynamicStackSlot)	extractor(dynamic_stack_addr, 0)
		4: Type	const_prim(I64)
		5: WritableReg	constructor(temp_writable_reg, [4], 1)
		6: Reg	constructor(writable_reg_to_reg, [5], 0)
		7: ValueRegs	constructor(value_reg, [6], 4)
		8: InstOutput	constructor(output, [7], 5)
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 75
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/isa/aarch64/inst.isle line 2576
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		27: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 71
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		32: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		35: ValueRegs	constructor(value_reg, [42], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 67
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		20: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		23: ValueRegs	constructor(value_reg, [30], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 61
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/isa/aarch64/inst.isle line 2568
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		27: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 57
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		32: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		35: ValueRegs	constructor(value_reg, [42], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 53
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		20: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		23: ValueRegs	constructor(value_reg, [30], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/isa/aarch64/inst.isle line 2560
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		27: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 43
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		32: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		35: ValueRegs	constructor(value_reg, [42], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 39
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		20: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		23: ValueRegs	constructor(value_reg, [30], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 35
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmax, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmax, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [25], 5)
		18: InstOutput	constructor(output, [17], 6)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 31
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmin, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmin, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [25], 5)
		18: InstOutput	constructor(output, [17], 6)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 27
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fdiv, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [25], 5)
		18: InstOutput	constructor(output, [17], 6)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 23
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmul, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmul, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [25], 5)
		18: InstOutput	constructor(output, [17], 6)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 19
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fsub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fsub, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [25], 5)
		18: InstOutput	constructor(output, [17], 6)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 15
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fadd, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [25], 5)
		18: InstOutput	constructor(output, [17], 6)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 11
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option((u32, u32))	extractor(dynamic_lane, 9)
		11: VecALUOp	make_variant(VecALUOp::Mul, [])
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: VectorSize	constructor(vector_size, [9], 3)
		19: ValueRegs	constructor(value_reg, [27], 5)
		20: InstOutput	constructor(output, [19], 6)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 7
		../../codegen/src/isa/aarch64/inst.isle line 2464
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [29], 5)
		17: InstOutput	constructor(output, [16], 6)
		21: VecALUOp	make_variant(VecALUOp::Sub, [])
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 3
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [29], 5)
		17: InstOutput	constructor(output, [16], 6)
		21: VecALUOp	make_variant(VecALUOp::Add, [])
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2860
		../../codegen/src/isa/aarch64/inst.isle line 2223
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvpromote_low, 0)
		4: VecRRLongOp	make_variant(VecRRLongOp::Fcvtl32, [])
		5: Value	match_some(3)
		6: Reg	constructor(put_in_reg, [5], 1)
		7: bool	const_prim(false)
		13: Type	const_prim(I8X16)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: Reg	constructor(writable_reg_to_reg, [14], 0)
		17: ValueRegs	constructor(value_reg, [15], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 3822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		16: Type	const_prim(I64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::Macho)
		8:	some
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2852
		../../codegen/src/isa/aarch64/inst.isle line 3815
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		16: Type	const_prim(I64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::ElfGd)
		8:	some
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2839
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2524
		../../codegen/src/isa/aarch64/inst.isle line 2027
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		16: ValueRegs	constructor(value_reg, [68], 11)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		18: Reg	constructor(put_in_reg, [10], 5)
		19: Reg	constructor(put_in_reg, [12], 6)
		21: u64	const_int(63, u64)
		23: Cond	make_variant(Cond::Ne, [])
		26: ValueRegs	constructor(value_reg, [60], 12)
		27: InstOutput	constructor(output_pair, [16, 26], 13)
		32: ALUOp3	make_variant(ALUOp3::MAdd, [])
		37: ALUOp	make_variant(ALUOp::SMulH, [])
		43: Type	const_prim(I64)
		44: Option(ShiftOpAndAmt)	constructor(ashr_from_u64, [43, 21], 0)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: WritableReg	constructor(writable_zero_reg, [], 1)
		47: ShiftOpAndAmt	match_some(44)
		48: MInst	make_variant(MInst::AluRRRShift, [45, 17, 46, 75, 68, 47])
		49: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [48])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: MInst	make_variant(MInst::CSet, [52, 23])
		54: Reg	constructor(writable_reg_to_reg, [52], 0)
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 54])
		58: ValueRegs	constructor(with_flags, [49, 55], 1)
		59: usize	const_int(0, usize)
		60: Reg	constructor(value_regs_get, [58, 59], 2)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: Reg	constructor(writable_reg_to_reg, [74], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		44:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2825
		../../codegen/src/isa/aarch64/inst.isle line 2500
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: ValueRegs	constructor(value_reg, [56], 8)
		16: OperandSize	make_variant(OperandSize::Size64, [])
		17: ExtendOp	make_variant(ExtendOp::SXTW, [])
		19: Cond	make_variant(Cond::Ne, [])
		22: ValueRegs	constructor(value_reg, [48], 9)
		23: InstOutput	constructor(output_pair, [15, 22], 10)
		27: ALUOp3	make_variant(ALUOp3::SMAddL, [])
		28: Type	const_prim(I32)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRRExtend, [34, 16, 35, 56, 56, 17])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::CSet, [40, 19])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 42])
		46: ValueRegs	constructor(with_flags, [37, 43], 1)
		47: usize	const_int(0, usize)
		48: Reg	constructor(value_regs_get, [46, 47], 2)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I64)
		31:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I64)
		31:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Option(Type)	extractor(fits_in_32, 31)
		33: Reg	constructor(put_in_reg, [13], 1)
		34: bool	const_prim(true)
		35: Type	match_some(32)
		36: u8	constructor(ty_bits, [35], 0)
		37: u8	const_int(32, u8)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I64)
		32:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I32)
		31:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I32)
		31:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Option(Type)	extractor(fits_in_32, 31)
		33: Reg	constructor(put_in_reg, [13], 1)
		34: bool	const_prim(true)
		35: Type	match_some(32)
		36: u8	constructor(ty_bits, [35], 0)
		37: u8	const_int(32, u8)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I32)
		32:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [11], 1)
		31: bool	const_prim(true)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(32, u8)
		37: Type	extractor(value_type, 13)
		38: Reg	constructor(put_in_reg, [13], 1)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	some
		37:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [11], 1)
		31: bool	const_prim(true)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(32, u8)
		37: Type	extractor(value_type, 13)
		38: Reg	constructor(put_in_reg, [13], 1)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	some
		37:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [91], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [69], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [11], 1)
		31: bool	const_prim(true)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(32, u8)
		37: Type	extractor(value_type, 13)
		38: Option(Type)	extractor(fits_in_32, 37)
		39: Reg	constructor(put_in_reg, [13], 1)
		40: bool	const_prim(true)
		41: Type	match_some(38)
		42: u8	constructor(ty_bits, [41], 0)
		43: u8	const_int(32, u8)
		49: ALUOp3	make_variant(ALUOp3::MAdd, [])
		55: ALUOp	make_variant(ALUOp::SubS, [])
		56: WritableReg	constructor(writable_zero_reg, [], 1)
		57: MInst	make_variant(MInst::AluRRRExtend, [55, 18, 56, 91, 91, 20])
		58: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [57])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::CSet, [61, 22])
		63: Reg	constructor(writable_reg_to_reg, [61], 0)
		64: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [62, 63])
		67: ValueRegs	constructor(with_flags, [58, 64], 1)
		68: usize	const_int(0, usize)
		69: Reg	constructor(value_regs_get, [67, 68], 2)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		89: Type	const_prim(I64)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: Reg	constructor(writable_reg_to_reg, [90], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	some
		38:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2791
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2520
		../../codegen/src/isa/aarch64/inst.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2124
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		16: ValueRegs	constructor(value_reg, [61], 12)
		17: Reg	constructor(put_in_reg, [10], 5)
		18: Reg	constructor(put_in_reg, [12], 6)
		20: u8	const_int(0, u8)
		21: Imm12	constructor(u8_into_imm12, [20], 8)
		23: Cond	make_variant(Cond::Ne, [])
		26: ValueRegs	constructor(value_reg, [53], 13)
		27: InstOutput	constructor(output_pair, [16, 26], 14)
		32: ALUOp3	make_variant(ALUOp3::MAdd, [])
		37: ALUOp	make_variant(ALUOp::UMulH, [])
		41: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 23])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [46, 47])
		51: ValueRegs	constructor(with_flags, [75, 48], 1)
		52: usize	const_int(0, usize)
		53: Reg	constructor(value_regs_get, [51, 52], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
		72: ALUOp	make_variant(ALUOp::SubS, [])
		73: WritableReg	constructor(writable_zero_reg, [], 1)
		74: MInst	make_variant(MInst::AluRRImm12, [72, 41, 73, 68, 21])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2496
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: ValueRegs	constructor(value_reg, [56], 8)
		16: OperandSize	make_variant(OperandSize::Size64, [])
		17: ExtendOp	make_variant(ExtendOp::UXTW, [])
		19: Cond	make_variant(Cond::Ne, [])
		22: ValueRegs	constructor(value_reg, [48], 9)
		23: InstOutput	constructor(output_pair, [15, 22], 10)
		27: ALUOp3	make_variant(ALUOp3::UMAddL, [])
		28: Type	const_prim(I32)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRRExtend, [34, 16, 35, 56, 56, 17])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::CSet, [40, 19])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 42])
		46: ValueRegs	constructor(with_flags, [37, 43], 1)
		47: usize	const_int(0, usize)
		48: Reg	constructor(value_regs_get, [46, 47], 2)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I64)
		31:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I64)
		31:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Option(Type)	extractor(fits_in_32, 31)
		33: Reg	constructor(put_in_reg, [13], 1)
		34: bool	const_prim(false)
		35: Type	match_some(32)
		36: u8	constructor(ty_bits, [35], 0)
		37: u8	const_int(32, u8)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I64)
		32:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I32)
		31:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [65], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [57], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Reg	constructor(put_in_reg, [13], 1)
		37: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::SubS, [])
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: MInst	make_variant(MInst::AluRRRExtend, [43, 18, 44, 65, 65, 20])
		46: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [45])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: MInst	make_variant(MInst::CSet, [49, 22])
		51: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [50, 51])
		55: ValueRegs	constructor(with_flags, [46, 52], 1)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 2)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I32)
		31:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Reg	constructor(put_in_reg, [11], 1)
		31: Type	extractor(value_type, 13)
		32: Option(Type)	extractor(fits_in_32, 31)
		33: Reg	constructor(put_in_reg, [13], 1)
		34: bool	const_prim(false)
		35: Type	match_some(32)
		36: u8	constructor(ty_bits, [35], 0)
		37: u8	const_int(32, u8)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		28:	const_prim(I32)
		32:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [11], 1)
		31: bool	const_prim(false)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(32, u8)
		37: Type	extractor(value_type, 13)
		38: Reg	constructor(put_in_reg, [13], 1)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	some
		37:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [78], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [63], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [11], 1)
		31: bool	const_prim(false)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(32, u8)
		37: Type	extractor(value_type, 13)
		38: Reg	constructor(put_in_reg, [13], 1)
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 18, 50, 78, 78, 20])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 22])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	some
		37:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [91], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [69], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		28: Type	extractor(value_type, 11)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [11], 1)
		31: bool	const_prim(false)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(32, u8)
		37: Type	extractor(value_type, 13)
		38: Option(Type)	extractor(fits_in_32, 37)
		39: Reg	constructor(put_in_reg, [13], 1)
		40: bool	const_prim(false)
		41: Type	match_some(38)
		42: u8	constructor(ty_bits, [41], 0)
		43: u8	const_int(32, u8)
		49: ALUOp3	make_variant(ALUOp3::MAdd, [])
		55: ALUOp	make_variant(ALUOp::SubS, [])
		56: WritableReg	constructor(writable_zero_reg, [], 1)
		57: MInst	make_variant(MInst::AluRRRExtend, [55, 18, 56, 91, 91, 20])
		58: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [57])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::CSet, [61, 22])
		63: Reg	constructor(writable_reg_to_reg, [61], 0)
		64: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [62, 63])
		67: ValueRegs	constructor(with_flags, [58, 64], 1)
		68: usize	const_int(0, usize)
		69: Reg	constructor(value_regs_get, [67, 68], 2)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		89: Type	const_prim(I64)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: Reg	constructor(writable_reg_to_reg, [90], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	some
		38:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2745
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Vs, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_64, 9)
		51: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2745
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Vs, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_32, 9)
		51: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(false)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(true)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2725
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Lo, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_64, 9)
		51: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2725
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Lo, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_32, 9)
		51: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(false)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(true)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Vs, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_64, 9)
		51: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Vs, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_32, 9)
		51: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(false)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(true)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_64, 20)
		69: OperandSize	make_variant(OperandSize::Size64, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_64, 20)
		72: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		20: Type	const_prim(I64)
		21: ValueRegs	constructor(put_in_regs, [9], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: ValueRegs	constructor(put_in_regs, [10], 4)
		25: Reg	constructor(value_regs_get, [24, 22], 5)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [21, 27], 3)
		29: Reg	constructor(value_regs_get, [24, 27], 6)
		32: MultiReg	constructor(with_flags_chained, [43, 53, 59], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [11, 69, 40, 23, 25])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::AluRRR, [12, 72, 50, 28, 29])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [51, 52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 13])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		61: Reg	match_variant(32, MultiReg::Three, a)
		62: Reg	match_variant(32, MultiReg::Three, b)
		63: ValueRegs	constructor(value_regs, [61, 62], 1)
		64: Reg	match_variant(32, MultiReg::Three, c)
		65: ValueRegs	constructor(value_reg, [64], 2)
		66: InstOutput	constructor(output_pair, [63, 65], 3)
		68: Option(Type)	extractor(fits_in_32, 20)
		69: OperandSize	make_variant(OperandSize::Size32, [])
		71: Option(Type)	extractor(fits_in_32, 20)
		72: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		32:	variant(MultiReg::Three)
		68:	some
		71:	some
	]
	result = 66
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2687
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uadd_overflow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Hs, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_64, 9)
		51: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2687
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uadd_overflow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Hs, [])
		21: Reg	constructor(put_in_reg, [11], 1)
		22: Reg	constructor(put_in_reg, [12], 2)
		25: ValueRegs	constructor(with_flags, [42, 48], 5)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 6)
		28: ValueRegs	constructor(value_reg, [27], 7)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [25, 29], 8)
		31: ValueRegs	constructor(value_reg, [30], 9)
		32: InstOutput	constructor(output_pair, [28, 31], 10)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::AluRRR, [13, 51, 39, 21, 22])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 14])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
		50: Option(Type)	extractor(fits_in_32, 9)
		51: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		50:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(false)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I64)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		64:	const_prim(I32)
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		22: Reg	constructor(put_in_reg, [12], 3)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		25: ValueRegs	constructor(value_reg, [43], 8)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		28: Cond	make_variant(Cond::Ne, [])
		31: ValueRegs	constructor(value_reg, [62], 9)
		32: InstOutput	constructor(output_pair, [25, 31], 10)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 1)
		50: MInst	make_variant(MInst::AluRRRExtend, [48, 26, 49, 43, 43, 23])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 28])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		64: Type	extractor(value_type, 11)
		65: Option(Type)	extractor(fits_in_32, 64)
		66: Reg	constructor(put_in_reg, [11], 1)
		67: bool	const_prim(true)
		68: Type	match_some(65)
		69: u8	constructor(ty_bits, [68], 0)
		70: u8	const_int(32, u8)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2603
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 3033
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, TrapCode))	extractor(uadd_overflow_trap, 7)
		9: Type	match_some(6)
		10: (Value, Value, TrapCode)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		16: TrapCode	match_tuple(10, 2)
		22: ALUOp	make_variant(ALUOp::AddS, [])
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::AluRRR, [22, 41, 25, 12, 14])
		27: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [26, 27])
		31: Cond	make_variant(Cond::Hs, [])
		32: CondBrKind	constructor(cond_br_cond, [31], 1)
		33: MInst	make_variant(MInst::TrapIf, [32, 16])
		34: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect, [33])
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Option(Type)	extractor(fits_in_64, 9)
		41: OperandSize	make_variant(OperandSize::Size64, [])
		44: ValueRegs	constructor(with_flags, [28, 34], 1)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		40:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2603
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 3033
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, TrapCode))	extractor(uadd_overflow_trap, 7)
		9: Type	match_some(6)
		10: (Value, Value, TrapCode)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		16: TrapCode	match_tuple(10, 2)
		22: ALUOp	make_variant(ALUOp::AddS, [])
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::AluRRR, [22, 41, 25, 12, 14])
		27: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [26, 27])
		31: Cond	make_variant(Cond::Hs, [])
		32: CondBrKind	constructor(cond_br_cond, [31], 1)
		33: MInst	make_variant(MInst::TrapIf, [32, 16])
		34: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect, [33])
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Option(Type)	extractor(fits_in_32, 9)
		41: OperandSize	make_variant(OperandSize::Size32, [])
		44: ValueRegs	constructor(with_flags, [28, 34], 1)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		40:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2589
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2444
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Type	const_prim(I64)
		7: Reg	constructor(put_in_reg, [4], 3)
		8: u8	const_int(0, u8)
		9: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 7)
		14: Reg	constructor(put_in_reg, [4], 1)
		15: u8	const_int(1, u8)
		17: ImmShift	constructor(imm_shift_from_u8, [11], 5)
		19: u64	const_int(1, u64)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_u64, [6, 19], 0)
		21: ShiftOpAndAmt	match_some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ALUOp	make_variant(ALUOp::Lsr, [])
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ALUOp	make_variant(ALUOp::Lsr, [])
		50: ALUOp	make_variant(ALUOp::Add, [])
		53: ValueRegs	constructor(value_reg, [76], 1)
		54: InstOutput	constructor(output, [53], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
	]
	result = 54
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2576
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(31, u8)
		8: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u128	const_int(633825300187901677051779743745, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size32, [])
		21: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		26: VecALUOp	make_variant(VecALUOp::And, [])
		30: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		52: Type	const_prim(I8X16)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2563
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(15, u8)
		8: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u128	const_int(664619068533544770747334646890102785, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size16, [])
		21: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		26: VecALUOp	make_variant(VecALUOp::And, [])
		30: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		52: Type	const_prim(I8X16)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2539
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2340
		../../codegen/src/isa/aarch64/inst.isle line 2599
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(7, u8)
		8: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u128	const_int(-169808226154284360427508033573982305791, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		13: u8	const_int(8, u8)
		16: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: u8	const_int(0, u8)
		19: ScalarSize	make_variant(ScalarSize::Size16, [])
		25: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		30: VecALUOp	make_variant(VecALUOp::And, [])
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		41: VecALUOp	make_variant(VecALUOp::Zip1, [])
		45: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ValueRegs	constructor(value_reg, [52], 1)
		55: InstOutput	constructor(output, [54], 2)
		60: Type	const_prim(I8X16)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I8X16)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
		74: Type	const_prim(I8X16)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		80: Type	const_prim(I8X16)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
	]
	result = 55
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2525
		../../codegen/src/isa/aarch64/inst.isle line 3709
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((StackSlot, Offset32))	extractor(stack_addr, 0)
		4: (StackSlot, Offset32)	match_some(3)
		5: StackSlot	match_tuple(4, 0)
		6: Offset32	match_tuple(4, 1)
		11: Type	const_prim(I64)
		12: WritableReg	constructor(temp_writable_reg, [11], 1)
		13: Reg	constructor(writable_reg_to_reg, [12], 0)
		15: ValueRegs	constructor(value_reg, [13], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2518
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Uimm8	match_tuple(4, 2)
		12: u8	extractor(u8_from_uimm8, 11)
		13: u8	const_int(0, u8)
		14: Type	extractor(value_type, 8)
		15: VectorSize	constructor(vector_size, [14], 3)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2513
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_int, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Uimm8	match_tuple(4, 2)
		12: u8	extractor(u8_from_uimm8, 11)
		13: Type	extractor(value_type, 8)
		14: VectorSize	constructor(vector_size, [13], 3)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2506
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Uimm8	match_tuple(9, 1)
		13: u8	extractor(u8_from_uimm8, 12)
		14: Type	extractor(value_type, 10)
		15: VectorSize	constructor(vector_size, [14], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2501
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Uimm8	match_tuple(9, 1)
		13: u8	extractor(u8_from_uimm8, 12)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 2)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2498
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Uimm8	match_tuple(9, 1)
		11: u8	extractor(u8_from_uimm8, 10)
		12: Value	match_tuple(9, 0)
		15: ValueRegs	constructor(put_in_regs, [12], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_int(0)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2492
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value))	extractor(bitcast, 6)
		8: (MemFlags, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Type	extractor(value_type, 9)
		13: ValueRegs	constructor(put_in_regs, [9], 1)
		14: InstOutput	constructor(output, [13], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	const_prim(I128)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2488
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: ValueRegs	constructor(put_in_regs, [10], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(false)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(false)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(false)
		21:	const_prim(true)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(false)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(false)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(false)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(false)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		21: bool	const_prim(true)
		24: Type	const_prim(I32)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		19:	const_prim(true)
		21:	const_prim(false)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(fits_in_64, 11)
		13: Type	match_some(12)
		14: Option(Type)	extractor(ty_float_or_vec, 13)
		15: Reg	constructor(put_in_reg, [10], 1)
		16: u8	const_int(0, u8)
		17: ScalarSize	constructor(scalar_size, [5], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
		14:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2462
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		13: Reg	constructor(put_in_reg, [10], 1)
		14: ScalarSize	constructor(scalar_size, [11], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2458
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_float_or_vec, 11)
		15: ValueRegs	constructor(put_in_regs, [10], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3703
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3493
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(set_pinned_reg, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		9: PReg	constructor(preg_pinned, [], 1)
		12: InstOutput	constructor(output_none, [], 2)
		15: MInst	make_variant(MInst::MovToPReg, [9, 5])
		16: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [15])
	]
	constraints = [
		3:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2449
		../../codegen/src/isa/aarch64/inst.isle line 3487
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_pinned_reg, 0)
		4: PReg	constructor(preg_pinned, [], 1)
		8: Type	const_prim(I64)
		9: WritableReg	constructor(temp_writable_reg, [8], 1)
		10: Reg	constructor(writable_reg_to_reg, [9], 0)
		12: ValueRegs	constructor(value_reg, [10], 1)
		13: InstOutput	constructor(output, [12], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore128, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore128, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		24: MInst	make_variant(MInst::FpuStore128, [14, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		24: MInst	make_variant(MInst::FpuStore64, [14, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore128, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore128, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		24: MInst	make_variant(MInst::FpuStore128, [14, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: Option(Inst)	extractor(def_inst, 9)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 11], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [14, 34, 13])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		20: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		24: MInst	make_variant(MInst::FpuStore64, [14, 20, 13])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3212
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		22: i64	constructor(i32_as_i64, [9], 0)
		23: Type	const_prim(I64)
		24: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [22, 23], 0)
		25: Reg	constructor(put_in_reg, [7], 1)
		26: SImm7Scaled	match_some(24)
		27: PairAMode	make_variant(PairAMode::SignedOffset, [25, 26])
		32: MInst	make_variant(MInst::StoreP64, [14, 17, 27, 11])
		33: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [32])
		35: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		24:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3200
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		22: i64	const_int(0, i64)
		23: Type	const_prim(I64)
		24: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [22, 23], 0)
		25: Reg	constructor(put_in_reg, [7], 1)
		27: SImm7Scaled	match_some(24)
		28: PairAMode	make_variant(PairAMode::SignedOffset, [25, 27])
		33: MInst	make_variant(MInst::StoreP64, [14, 17, 28, 11])
		34: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [33])
		36: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		9:	const_int(0)
		24:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3197
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		22: i64	const_int(0, i64)
		23: Type	const_prim(I64)
		24: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [22, 23], 0)
		25: Reg	constructor(put_in_reg, [7], 1)
		27: SImm7Scaled	match_some(24)
		28: PairAMode	make_variant(PairAMode::SignedOffset, [56, 27])
		33: MInst	make_variant(MInst::StoreP64, [14, 17, 28, 11])
		34: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [33])
		36: InstOutput	constructor(output_none, [], 2)
		39: i64	constructor(i32_as_i64, [9], 0)
		40: u64	constructor(i64_as_u64, [39], 0)
		41: Option(Imm12)	extractor(imm12_from_u64, 40)
		42: Type	const_prim(I64)
		43: Imm12	match_some(41)
		48: ALUOp	make_variant(ALUOp::Add, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		24:	some
		41:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3195
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		22: i64	const_int(0, i64)
		23: Type	const_prim(I64)
		24: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [22, 23], 0)
		25: Reg	constructor(put_in_reg, [7], 1)
		27: SImm7Scaled	match_some(24)
		28: PairAMode	make_variant(PairAMode::SignedOffset, [56, 27])
		33: MInst	make_variant(MInst::StoreP64, [14, 17, 28, 11])
		34: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [33])
		36: InstOutput	constructor(output_none, [], 2)
		39: Type	const_prim(I64)
		40: ImmExtend	make_variant(ImmExtend::Zero, [])
		41: i64	constructor(i32_as_i64, [9], 0)
		42: u64	constructor(i64_as_u64, [41], 0)
		43: Reg	constructor(imm, [39, 40, 42], 1)
		48: ALUOp	make_variant(ALUOp::Add, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		24:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::FpuStore64, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::FpuStore64, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::FpuStore64, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2893
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::FpuStore32, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2893
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::FpuStore32, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2893
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::FpuStore32, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: Option(Inst)	extractor(def_inst, 6)
		19: Inst	match_some(18)
		20: Option((Value, Value))	extractor(iadd, 19)
		21: (Value, Value)	match_some(20)
		22: Value	match_tuple(21, 0)
		23: Option(Inst)	extractor(def_inst, 22)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(i32)	extractor(simm32, 26)
		28: i32	match_some(27)
		29: Option(i32)	constructor(s32_add_fallible, [28, 8], 0)
		30: Value	match_tuple(21, 1)
		31: i32	match_some(29)
		32: AMode	constructor(amode_no_more_iconst, [4, 30, 31], 1)
		36: MInst	make_variant(MInst::Store32, [12, 32, 10])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		18:	some
		20:	some
		23:	some
		25:	some
		27:	some
		29:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: Option(Inst)	extractor(def_inst, 6)
		19: Inst	match_some(18)
		20: Option((Value, Value))	extractor(iadd, 19)
		21: (Value, Value)	match_some(20)
		22: Value	match_tuple(21, 1)
		23: Option(Inst)	extractor(def_inst, 22)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(i32)	extractor(simm32, 26)
		28: i32	match_some(27)
		29: Option(i32)	constructor(s32_add_fallible, [28, 8], 0)
		30: Value	match_tuple(21, 0)
		31: i32	match_some(29)
		32: AMode	constructor(amode_no_more_iconst, [4, 30, 31], 1)
		36: MInst	make_variant(MInst::Store32, [12, 32, 10])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		18:	some
		20:	some
		23:	some
		25:	some
		27:	some
		29:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		22: MInst	make_variant(MInst::Store32, [12, 18, 10])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: Option(Inst)	extractor(def_inst, 6)
		19: Inst	match_some(18)
		20: Option((Value, Value))	extractor(iadd, 19)
		21: (Value, Value)	match_some(20)
		22: Value	match_tuple(21, 0)
		23: Option(Inst)	extractor(def_inst, 22)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(i32)	extractor(simm32, 26)
		28: i32	match_some(27)
		29: Option(i32)	constructor(s32_add_fallible, [28, 8], 0)
		30: Value	match_tuple(21, 1)
		31: i32	match_some(29)
		32: AMode	constructor(amode_no_more_iconst, [4, 30, 31], 1)
		36: MInst	make_variant(MInst::Store16, [12, 32, 10])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		18:	some
		20:	some
		23:	some
		25:	some
		27:	some
		29:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: Option(Inst)	extractor(def_inst, 6)
		19: Inst	match_some(18)
		20: Option((Value, Value))	extractor(iadd, 19)
		21: (Value, Value)	match_some(20)
		22: Value	match_tuple(21, 1)
		23: Option(Inst)	extractor(def_inst, 22)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(i32)	extractor(simm32, 26)
		28: i32	match_some(27)
		29: Option(i32)	constructor(s32_add_fallible, [28, 8], 0)
		30: Value	match_tuple(21, 0)
		31: i32	match_some(29)
		32: AMode	constructor(amode_no_more_iconst, [4, 30, 31], 1)
		36: MInst	make_variant(MInst::Store16, [12, 32, 10])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		18:	some
		20:	some
		23:	some
		25:	some
		27:	some
		29:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		22: MInst	make_variant(MInst::Store16, [12, 18, 10])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: Option(Inst)	extractor(def_inst, 6)
		19: Inst	match_some(18)
		20: Option((Value, Value))	extractor(iadd, 19)
		21: (Value, Value)	match_some(20)
		22: Value	match_tuple(21, 0)
		23: Option(Inst)	extractor(def_inst, 22)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(i32)	extractor(simm32, 26)
		28: i32	match_some(27)
		29: Option(i32)	constructor(s32_add_fallible, [28, 8], 0)
		30: Value	match_tuple(21, 1)
		31: i32	match_some(29)
		32: AMode	constructor(amode_no_more_iconst, [4, 30, 31], 1)
		36: MInst	make_variant(MInst::Store8, [12, 32, 10])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		18:	some
		20:	some
		23:	some
		25:	some
		27:	some
		29:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: Option(Inst)	extractor(def_inst, 6)
		19: Inst	match_some(18)
		20: Option((Value, Value))	extractor(iadd, 19)
		21: (Value, Value)	match_some(20)
		22: Value	match_tuple(21, 1)
		23: Option(Inst)	extractor(def_inst, 22)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(i32)	extractor(simm32, 26)
		28: i32	match_some(27)
		29: Option(i32)	constructor(s32_add_fallible, [28, 8], 0)
		30: Value	match_tuple(21, 0)
		31: i32	match_some(29)
		32: AMode	constructor(amode_no_more_iconst, [4, 30, 31], 1)
		36: MInst	make_variant(MInst::Store8, [12, 32, 10])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		18:	some
		20:	some
		23:	some
		25:	some
		27:	some
		29:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		22: MInst	make_variant(MInst::Store8, [12, 18, 10])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store64, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store64, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::Store64, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store64, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store64, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::Store64, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store32, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store32, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::Store32, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store16, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store16, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::Store16, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store8, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: Option(Inst)	extractor(def_inst, 8)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 10], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [7, 31, 32], 1)
		37: MInst	make_variant(MInst::Store8, [13, 33, 12])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		19: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		23: MInst	make_variant(MInst::Store8, [13, 19, 12])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		20: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		20: Option(Inst)	extractor(def_inst, 7)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 9], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [5, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ValueRegs	constructor(value_reg, [46], 1)
		49: InstOutput	constructor(output, [48], 2)
	]
	constraints = [
		3:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 49
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		20: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2847
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 0)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 1)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2847
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 1)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 0)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2847
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 0)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 1)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 1)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 0)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2837
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 0)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 1)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2837
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 1)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 0)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2837
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 0)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 1)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 1)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 0)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2827
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 0)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 1)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2827
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 1)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 0)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2827
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 0)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 1)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: Option(Inst)	extractor(def_inst, 6)
		17: Inst	match_some(16)
		18: Option((Value, Value))	extractor(iadd, 17)
		19: (Value, Value)	match_some(18)
		20: Value	match_tuple(19, 1)
		21: Option(Inst)	extractor(def_inst, 20)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(i32)	extractor(simm32, 24)
		26: i32	match_some(25)
		27: Option(i32)	constructor(s32_add_fallible, [26, 8], 0)
		28: Value	match_tuple(19, 0)
		29: i32	match_some(27)
		30: AMode	constructor(amode_no_more_iconst, [4, 28, 29], 1)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ValueRegs	constructor(value_reg, [35], 1)
		38: InstOutput	constructor(output, [37], 2)
	]
	constraints = [
		3:	some
		16:	some
		18:	some
		21:	some
		23:	some
		25:	some
		27:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		16: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64X2)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64X2)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		24: Type	const_prim(F64X2)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64X2)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64X2)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		24: Type	const_prim(F64X2)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: Option(Inst)	extractor(def_inst, 11)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 13], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [9, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		21: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3212
		../../codegen/src/isa/aarch64/inst.isle line 2872
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [31], 3)
		18: i64	constructor(i32_as_i64, [11], 0)
		19: Type	const_prim(I64)
		20: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [18, 19], 0)
		21: Reg	constructor(put_in_reg, [9], 1)
		22: SImm7Scaled	match_some(20)
		23: PairAMode	make_variant(PairAMode::SignedOffset, [21, 22])
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		29: WritableReg	constructor(temp_writable_reg, [26], 2)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		31: ValueRegs	constructor(value_regs, [28, 30], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		20:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2872
		../../codegen/src/isa/aarch64/inst.isle line 3200
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [32], 3)
		18: i64	const_int(0, i64)
		19: Type	const_prim(I64)
		20: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [18, 19], 0)
		21: Reg	constructor(put_in_reg, [9], 1)
		23: SImm7Scaled	match_some(20)
		24: PairAMode	make_variant(PairAMode::SignedOffset, [21, 23])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		30: WritableReg	constructor(temp_writable_reg, [27], 2)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		32: ValueRegs	constructor(value_regs, [29, 31], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		11:	const_int(0)
		20:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2872
		../../codegen/src/isa/aarch64/inst.isle line 3197
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [32], 3)
		18: i64	const_int(0, i64)
		19: Type	const_prim(I64)
		20: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [18, 19], 0)
		21: Reg	constructor(put_in_reg, [9], 1)
		23: SImm7Scaled	match_some(20)
		24: PairAMode	make_variant(PairAMode::SignedOffset, [52, 23])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		30: WritableReg	constructor(temp_writable_reg, [27], 2)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		32: ValueRegs	constructor(value_regs, [29, 31], 4)
		35: i64	constructor(i32_as_i64, [11], 0)
		36: u64	constructor(i64_as_u64, [35], 0)
		37: Option(Imm12)	extractor(imm12_from_u64, 36)
		38: Type	const_prim(I64)
		39: Imm12	match_some(37)
		44: ALUOp	make_variant(ALUOp::Add, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		20:	some
		37:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2872
		../../codegen/src/isa/aarch64/inst.isle line 3195
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [32], 3)
		18: i64	const_int(0, i64)
		19: Type	const_prim(I64)
		20: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [18, 19], 0)
		21: Reg	constructor(put_in_reg, [9], 1)
		23: SImm7Scaled	match_some(20)
		24: PairAMode	make_variant(PairAMode::SignedOffset, [52, 23])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		30: WritableReg	constructor(temp_writable_reg, [27], 2)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		32: ValueRegs	constructor(value_regs, [29, 31], 4)
		35: Type	const_prim(I64)
		36: ImmExtend	make_variant(ImmExtend::Zero, [])
		37: i64	constructor(i32_as_i64, [11], 0)
		38: u64	constructor(i64_as_u64, [37], 0)
		39: Reg	constructor(imm, [35, 36, 38], 1)
		44: ALUOp	make_variant(ALUOp::Add, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		20:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2857
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2857
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(F64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2857
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 12], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [8, 32, 33], 1)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		20: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2276
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(return_call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_return_call_indirect, [5, 6, 7], 1)
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2273
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(return_call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_return_call, [7, 8, 9, 10], 1)
	]
	constraints = [
		3:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2268
		../../codegen/src/prelude_lower.isle line 1044
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(ValueSlice)	extractor(return, 0)
		4: ValueSlice	match_some(3)
		7: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2262
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_call_indirect, [5, 6, 7], 1)
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2259
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_call, [7, 8, 9, 10], 1)
	]
	constraints = [
		3:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2254
		../../codegen/src/isa/aarch64/inst.isle line 3533
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3487
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		6: Option(Unit)	constructor(preserve_frame_pointers, [], 0)
		7: PReg	constructor(preg_link, [], 4)
		10: ValueRegs	constructor(value_reg, [15], 1)
		11: InstOutput	constructor(output, [10], 2)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: Reg	constructor(writable_reg_to_reg, [14], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2254
		../../codegen/src/isa/aarch64/inst.isle line 3517
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		6: Option(Unit)	constructor(preserve_frame_pointers, [], 0)
		7: Option(Unit)	constructor(sign_return_address_disabled, [], 0)
		8: Type	const_prim(I64)
		9: WritableReg	constructor(temp_writable_reg, [8], 1)
		10: Reg	constructor(writable_reg_to_reg, [9], 0)
		12: ValueRegs	constructor(value_reg, [10], 1)
		13: InstOutput	constructor(output, [12], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2251
		../../codegen/src/isa/aarch64/inst.isle line 3509
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3487
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_stack_pointer, 0)
		6: PReg	constructor(preg_sp, [], 1)
		9: ValueRegs	constructor(value_reg, [14], 1)
		10: InstOutput	constructor(output, [9], 2)
		12: Type	const_prim(I64)
		13: WritableReg	constructor(temp_writable_reg, [12], 1)
		14: Reg	constructor(writable_reg_to_reg, [13], 0)
	]
	constraints = [
		3:	some
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2248
		../../codegen/src/isa/aarch64/inst.isle line 3513
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3487
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_frame_pointer, 0)
		6: PReg	constructor(preg_fp, [], 1)
		9: ValueRegs	constructor(value_reg, [14], 1)
		10: InstOutput	constructor(output, [9], 2)
		12: Type	const_prim(I64)
		13: WritableReg	constructor(temp_writable_reg, [12], 1)
		14: Reg	constructor(writable_reg_to_reg, [13], 0)
	]
	constraints = [
		3:	some
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2243
		../../codegen/src/isa/aarch64/inst.isle line 3108
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(GlobalValue)	extractor(symbol_value, 0)
		4: GlobalValue	match_some(3)
		5: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 4)
		6: (ExternalName, RelocDistance, i64)	match_some(5)
		7: ExternalName	match_tuple(6, 0)
		8: BoxExternalName	constructor(box_external_name, [7], 1)
		9: i64	match_tuple(6, 2)
		14: Type	const_prim(I64)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: Reg	constructor(writable_reg_to_reg, [15], 0)
		18: ValueRegs	constructor(value_reg, [16], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2238
		../../codegen/src/isa/aarch64/inst.isle line 3108
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(FuncRef)	extractor(func_addr, 0)
		4: FuncRef	match_some(3)
		5: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 4)
		6: ExternalName	match_tuple(5, 1)
		7: BoxExternalName	constructor(box_external_name, [6], 1)
		8: i64	const_int(0, i64)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: Reg	constructor(writable_reg_to_reg, [14], 0)
		17: ValueRegs	constructor(value_reg, [15], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2233
		../../codegen/src/isa/aarch64/inst.isle line 2590
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(debugtrap, 0)
		6: MInst	make_variant(MInst::Brk, [])
		7: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [6])
		9: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2227
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2112
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_invalid, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(1, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [24, 30], 6)
		14: InstOutput	constructor(output, [13], 7)
		16: Option(Type)	extractor(fits_in_64, 5)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		21: ALUOp	make_variant(ALUOp::AddS, [])
		22: WritableReg	constructor(writable_zero_reg, [], 1)
		23: MInst	make_variant(MInst::AluRRImm12, [21, 17, 22, 7, 9])
		24: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [23])
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::CSet, [27, 11])
		29: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [28, 29])
	]
	constraints = [
		3:	some
		16:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2227
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2112
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_invalid, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(1, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [24, 30], 6)
		14: InstOutput	constructor(output, [13], 7)
		16: Option(Type)	extractor(fits_in_32, 5)
		17: OperandSize	make_variant(OperandSize::Size32, [])
		21: ALUOp	make_variant(ALUOp::AddS, [])
		22: WritableReg	constructor(writable_zero_reg, [], 1)
		23: MInst	make_variant(MInst::AluRRImm12, [21, 17, 22, 7, 9])
		24: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [23])
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::CSet, [27, 11])
		29: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [28, 29])
	]
	constraints = [
		3:	some
		16:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2221
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_null, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(0, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [24, 30], 6)
		14: InstOutput	constructor(output, [13], 7)
		16: Option(Type)	extractor(fits_in_64, 5)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		21: ALUOp	make_variant(ALUOp::SubS, [])
		22: WritableReg	constructor(writable_zero_reg, [], 1)
		23: MInst	make_variant(MInst::AluRRImm12, [21, 17, 22, 7, 9])
		24: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [23])
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::CSet, [27, 11])
		29: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [28, 29])
	]
	constraints = [
		3:	some
		16:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2221
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_null, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(0, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [24, 30], 6)
		14: InstOutput	constructor(output, [13], 7)
		16: Option(Type)	extractor(fits_in_32, 5)
		17: OperandSize	make_variant(OperandSize::Size32, [])
		21: ALUOp	make_variant(ALUOp::SubS, [])
		22: WritableReg	constructor(writable_zero_reg, [], 1)
		23: MInst	make_variant(MInst::AluRRImm12, [21, 17, 22, 7, 9])
		24: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [23])
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::CSet, [27, 11])
		29: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [28, 29])
	]
	constraints = [
		3:	some
		16:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2216
		../../codegen/src/isa/aarch64/inst.isle line 2580
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(fence, 0)
		6: MInst	make_variant(MInst::Fence, [])
		7: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [6])
		9: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2209
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: u8	const_int(1, u8)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		15: bool	const_prim(false)
		16: ScalarSize	constructor(lane_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2206
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: bool	const_prim(true)
		13: Type	match_some(6)
		14: ScalarSize	constructor(lane_size, [13], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_low, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(false)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2194
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: u8	const_int(1, u8)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		15: bool	const_prim(false)
		16: ScalarSize	constructor(lane_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2191
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: bool	const_prim(true)
		13: Type	match_some(6)
		14: ScalarSize	constructor(lane_size, [13], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2186
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_low, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(false)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2179
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/isa/aarch64/inst.isle line 2576
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		27: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2175
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		32: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		35: ValueRegs	constructor(value_reg, [42], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2171
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		20: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		23: ValueRegs	constructor(value_reg, [30], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2163
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/isa/aarch64/inst.isle line 2568
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		27: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2159
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		32: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		35: ValueRegs	constructor(value_reg, [42], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2155
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		20: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		23: ValueRegs	constructor(value_reg, [30], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2148
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/isa/aarch64/inst.isle line 2560
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		27: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2144
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		32: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		35: ValueRegs	constructor(value_reg, [42], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2140
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		20: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		23: ValueRegs	constructor(value_reg, [30], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2135
		../../codegen/src/isa/aarch64/inst.isle line 2552
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvdemote, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: VecRRNarrowOp	make_variant(VecRRNarrowOp::Fcvtn, [])
		14: ValueRegs	constructor(value_reg, [21], 1)
		15: InstOutput	constructor(output, [14], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
	]
	constraints = [
		3:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 3458
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 7)
		9: (MemFlags, Value, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2125
		../../codegen/src/isa/aarch64/inst.isle line 3430
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 8)
		10: (MemFlags, Value, Value, Value)	match_some(9)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 2)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 3)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Type	match_some(6)
		18: MemFlags	match_tuple(10, 0)
		26: WritableReg	constructor(temp_writable_reg, [17], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2120
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Xchg, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xchg)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umax, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umax)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2114
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umin, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umin)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smax, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smax)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2108
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smin, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smin)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Eor, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xor)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2102
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Orr, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Or)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2099
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Nand, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Nand)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::And, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::And)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2093
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Sub, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Sub)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2090
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Add, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Add)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2084
		../../codegen/src/isa/aarch64/inst.isle line 2800
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Clr, [])
		13: Value	match_tuple(10, 2)
		14: Type	match_some(6)
		15: Value	match_tuple(10, 3)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Reg	constructor(zero_reg, [], 2)
		19: MemFlags	match_tuple(10, 0)
		25: ALUOp	make_variant(ALUOp::EorNot, [])
		32: WritableReg	constructor(temp_writable_reg, [14], 2)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::And)
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		13: Value	match_tuple(10, 2)
		14: Type	match_some(6)
		15: Reg	constructor(zero_reg, [], 1)
		16: Value	match_tuple(10, 3)
		17: Reg	constructor(put_in_reg, [16], 2)
		19: MemFlags	match_tuple(10, 0)
		25: ALUOp	make_variant(ALUOp::Sub, [])
		32: WritableReg	constructor(temp_writable_reg, [14], 2)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Sub)
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2076
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Umin, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umin)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2072
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Umax, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umax)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2068
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Smin, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smin)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2064
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Smax, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smax)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2060
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Set, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Or)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Eor, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Xor)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2052
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		25: WritableReg	constructor(temp_writable_reg, [16], 2)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Add)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2045
		../../codegen/src/isa/aarch64/inst.isle line 2354
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value))	extractor(atomic_store, 0)
		4: (MemFlags, Value, Value)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Type	match_some(7)
		9: MemFlags	match_tuple(4, 0)
		10: Reg	constructor(put_in_reg, [5], 1)
		11: Value	match_tuple(4, 2)
		12: Reg	constructor(put_in_reg, [11], 2)
		19: MInst	make_variant(MInst::StoreRelease, [8, 10, 12, 9])
		20: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [19])
		22: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2040
		../../codegen/src/isa/aarch64/inst.isle line 2347
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(atomic_load, 7)
		9: Type	match_some(6)
		10: (MemFlags, Value)	match_some(8)
		11: MemFlags	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		19: Type	const_prim(I64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3234
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		23: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		24: (MemFlags, Value, Offset32)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Reg	constructor(put_in_reg, [25], 2)
		27: Offset32	match_tuple(24, 2)
		28: i32	extractor(offset32, 27)
		29: i64	constructor(i32_as_i64, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		43: Type	const_prim(I64)
		44: ImmExtend	make_variant(ImmExtend::Zero, [])
		45: Reg	constructor(imm, [43, 44, 30], 1)
		50: ALUOp	make_variant(ALUOp::Add, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		23:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3233
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		23: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		24: (MemFlags, Value, Offset32)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Reg	constructor(put_in_reg, [25], 2)
		27: Offset32	match_tuple(24, 2)
		28: i32	extractor(offset32, 27)
		29: i64	constructor(i32_as_i64, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		43: Option(Imm12)	extractor(imm12_from_u64, 30)
		44: Type	const_prim(I64)
		45: Imm12	match_some(43)
		50: ALUOp	make_variant(ALUOp::Add, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		23:	some
		43:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3232
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		23: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		24: (MemFlags, Value, Offset32)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Reg	constructor(put_in_reg, [25], 2)
		27: Offset32	match_tuple(24, 2)
		28: i32	extractor(offset32, 27)
		29: i64	constructor(i32_as_i64, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		23:	some
		30:	const_int(0)
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2031
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Value)	extractor(ireduce, 9)
		11: Value	match_some(10)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: Option(Imm64)	extractor(iconst, 13)
		15: Imm64	match_some(14)
		16: u64	extractor(u64_from_imm64, 15)
		17: Type	match_tuple(4, 0)
		18: VectorSize	constructor(vector_size, [17], 1)
		19: Reg	constructor(splat_const, [16, 18], 2)
		22: ValueRegs	constructor(value_reg, [19], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		14:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2028
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Imm64)	extractor(iconst, 9)
		11: Imm64	match_some(10)
		12: u64	extractor(u64_from_imm64, 11)
		13: Type	match_tuple(4, 0)
		14: VectorSize	constructor(vector_size, [13], 1)
		15: Reg	constructor(splat_const, [12, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2025
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee64)	extractor(f64const, 9)
		11: Ieee64	match_some(10)
		12: u64	extractor(u64_from_ieee64, 11)
		13: Type	match_tuple(4, 0)
		14: VectorSize	constructor(vector_size, [13], 1)
		15: Reg	constructor(splat_const, [12, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2022
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee32)	extractor(f32const, 9)
		11: Ieee32	match_some(10)
		12: u32	extractor(u32_from_ieee32, 11)
		13: u64	constructor(u32_as_u64, [12], 0)
		14: Type	match_tuple(4, 0)
		15: VectorSize	constructor(vector_size, [14], 1)
		16: Reg	constructor(splat_const, [13, 15], 2)
		19: ValueRegs	constructor(value_reg, [16], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2019
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_scalar_float, 8)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: u8	const_int(0, u8)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2015
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	constructor(ty_int_ref_scalar_64, [8], 0)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2009
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Constant)	extractor(vconst, 5)
		7: Constant	match_some(6)
		8: Option(u64)	extractor(u64_from_constant, 7)
		9: Type	match_tuple(4, 0)
		10: Option(Type)	constructor(ty_vec64, [9], 0)
		11: u64	match_some(8)
		12: Reg	constructor(constant_f64, [11], 1)
		15: ValueRegs	constructor(value_reg, [12], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2006
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Constant)	extractor(vconst, 7)
		9: Constant	match_some(8)
		10: Option(u128)	extractor(u128_from_constant, 9)
		11: u128	match_some(10)
		12: Reg	constructor(constant_f128, [11], 1)
		15: ValueRegs	constructor(value_reg, [12], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1995
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Type	const_prim(I64)
		12: ValueRegs	constructor(put_in_regs, [8], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [12, 15], 3)
		18: Reg	constructor(zero_reg, [], 5)
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [37, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		29: ALUOp	make_variant(ALUOp::Orr, [])
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRR, [34, 10, 35, 44, 18])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1989
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [30, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Reg	constructor(put_in_reg, [8], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: MInst	make_variant(MInst::AluRRR, [27, 11, 28, 23, 13])
		30: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [29])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		22:	const_prim(I64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1989
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [36, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Option(Type)	extractor(fits_in_32, 22)
		24: Reg	constructor(put_in_reg, [8], 1)
		25: bool	const_prim(false)
		26: Type	match_some(23)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::SubS, [])
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: MInst	make_variant(MInst::AluRRR, [33, 11, 34, 43, 13])
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [35])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 3842
		../../codegen/src/isa/aarch64/inst.isle line 3846
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [31], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [29, 22, 23, 24, 25], 5)
		27: InstOutput	constructor(output, [26], 8)
		29: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		31: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1964
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Type	const_prim(I64)
		12: ValueRegs	constructor(put_in_regs, [8], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [12, 15], 3)
		18: Reg	constructor(zero_reg, [], 5)
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [37, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		29: ALUOp	make_variant(ALUOp::Orr, [])
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRR, [34, 10, 35, 44, 18])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1958
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [30, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Reg	constructor(put_in_reg, [8], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: MInst	make_variant(MInst::AluRRR, [27, 11, 28, 23, 13])
		30: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [29])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		22:	const_prim(I64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1958
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [36, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Option(Type)	extractor(fits_in_32, 22)
		24: Reg	constructor(put_in_reg, [8], 1)
		25: bool	const_prim(false)
		26: Type	match_some(23)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::SubS, [])
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: MInst	make_variant(MInst::AluRRR, [33, 11, 34, 43, 13])
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [35])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [30, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Reg	constructor(put_in_reg, [8], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: MInst	make_variant(MInst::AluRRR, [27, 11, 28, 23, 13])
		30: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [29])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		22:	const_prim(I64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [30, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Reg	constructor(put_in_reg, [8], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: WritableReg	constructor(writable_zero_reg, [], 1)
		29: MInst	make_variant(MInst::AluRRR, [27, 11, 28, 23, 13])
		30: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [29])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		22:	const_prim(I32)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [36, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		22: Type	extractor(value_type, 8)
		23: Option(Type)	extractor(fits_in_32, 22)
		24: Reg	constructor(put_in_reg, [8], 1)
		25: bool	const_prim(false)
		26: Type	match_some(23)
		27: u8	constructor(ty_bits, [26], 0)
		28: u8	const_int(32, u8)
		33: ALUOp	make_variant(ALUOp::SubS, [])
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: MInst	make_variant(MInst::AluRRR, [33, 11, 34, 43, 13])
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [35])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Type	const_prim(I32)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [28, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		24: ALUOp	make_variant(ALUOp::AndS, [])
		26: WritableReg	constructor(writable_zero_reg, [], 2)
		27: MInst	make_variant(MInst::AluRRImmLogic, [24, 31, 26, 11, 13])
		28: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [27])
		30: Option(Type)	extractor(fits_in_64, 10)
		31: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I8)
		30:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Type	const_prim(I32)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [28, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		24: ALUOp	make_variant(ALUOp::AndS, [])
		26: WritableReg	constructor(writable_zero_reg, [], 2)
		27: MInst	make_variant(MInst::AluRRImmLogic, [24, 31, 26, 11, 13])
		28: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [27])
		30: Option(Type)	extractor(fits_in_32, 10)
		31: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I8)
		30:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1937
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((FloatCC, Value, Value))	extractor(fcmp, 12)
		14: (FloatCC, Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Type	extractor(value_type, 15)
		17: ScalarSize	constructor(scalar_size, [16], 2)
		18: Reg	constructor(put_in_reg, [15], 3)
		19: Value	match_tuple(14, 2)
		20: Reg	constructor(put_in_reg, [19], 4)
		22: FloatCC	match_tuple(14, 0)
		23: Cond	constructor(fp_cond_code, [22], 1)
		24: Type	match_tuple(4, 0)
		25: Value	match_tuple(7, 1)
		26: Value	match_tuple(7, 2)
		27: ValueRegs	constructor(lower_select, [33, 23, 24, 25, 26], 6)
		28: InstOutput	constructor(output, [27], 7)
		32: MInst	make_variant(MInst::FpuCmp, [17, 18, 20])
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [32])
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1924
		../../codegen/src/isa/aarch64/inst.isle line 3842
		../../codegen/src/isa/aarch64/inst.isle line 3846
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [31], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [29, 22, 23, 24, 25], 5)
		27: InstOutput	constructor(output, [26], 6)
		29: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		31: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1919
		../../codegen/src/isa/aarch64/inst.isle line 2816
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(resumable_trap, 0)
		4: TrapCode	match_some(3)
		8: MInst	make_variant(MInst::Udf, [4])
		9: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [8])
		11: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1914
		../../codegen/src/isa/aarch64/inst.isle line 2816
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(trap, 0)
		4: TrapCode	match_some(3)
		8: MInst	make_variant(MInst::Udf, [4])
		9: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [8])
		11: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1909
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((IntCC, Value, Value))	extractor(icmp, 0)
		4: (IntCC, Value, Value)	match_some(3)
		5: IntCC	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: Value	match_tuple(4, 2)
		8: Type	extractor(value_type, 6)
		9: Type	const_prim(I8)
		10: ValueRegs	constructor(lower_icmp_into_reg, [5, 6, 7, 8, 9], 1)
		11: InstOutput	constructor(output, [10], 2)
	]
	constraints = [
		3:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1903
		../../codegen/src/isa/aarch64/inst.isle line 3410
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: IntCC	match_some(11)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [31], 4)
		20: InstOutput	constructor(output, [19], 5)
		24: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op_swap, [14], 1)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1897
		../../codegen/src/isa/aarch64/inst.isle line 3415
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [40], 5)
		20: InstOutput	constructor(output, [19], 6)
		23: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		27: VecMisc2	make_variant(VecMisc2::Not, [])
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1891
		../../codegen/src/isa/aarch64/inst.isle line 3405
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: IntCC	match_tuple(9, 0)
		13: Option(IntCC)	extractor(icmp_zero_cond, 12)
		14: IntCC	match_some(13)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [31], 4)
		20: InstOutput	constructor(output, [19], 5)
		24: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op, [14], 1)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 3415
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [40], 5)
		20: InstOutput	constructor(output, [19], 6)
		23: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		27: VecMisc2	make_variant(VecMisc2::Not, [])
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1879
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	constructor(ty_vector_float, [9], 0)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Value	match_tuple(7, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: FloatCC	match_tuple(7, 0)
		15: Cond	constructor(fp_cond_code, [14], 3)
		16: Reg	constructor(vec_cmp, [11, 13, 9, 15], 4)
		19: ValueRegs	constructor(value_reg, [16], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1874
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(ty_scalar_float, 9)
		11: Type	match_some(10)
		12: ScalarSize	constructor(scalar_size, [11], 1)
		13: Reg	constructor(put_in_reg, [8], 2)
		14: Value	match_tuple(7, 2)
		15: Reg	constructor(put_in_reg, [14], 3)
		17: FloatCC	match_tuple(7, 0)
		18: Cond	constructor(fp_cond_code, [17], 5)
		20: ValueRegs	constructor(with_flags, [26, 32], 7)
		21: InstOutput	constructor(output, [20], 8)
		25: MInst	make_variant(MInst::FpuCmp, [12, 13, 15])
		26: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [25])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::CSet, [29, 18])
		31: Reg	constructor(writable_reg_to_reg, [29], 0)
		32: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [30, 31])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1868
		../../codegen/src/isa/aarch64/inst.isle line 3380
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: FloatCC	match_some(11)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [31], 4)
		20: InstOutput	constructor(output, [19], 5)
		24: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op_swap, [14], 1)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1862
		../../codegen/src/isa/aarch64/inst.isle line 3385
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [40], 5)
		20: InstOutput	constructor(output, [19], 6)
		23: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		27: VecMisc2	make_variant(VecMisc2::Not, [])
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 3375
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: FloatCC	match_tuple(9, 0)
		13: Option(FloatCC)	extractor(fcmp_zero_cond, 12)
		14: FloatCC	match_some(13)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [31], 4)
		20: InstOutput	constructor(output, [19], 5)
		24: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op, [14], 1)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1850
		../../codegen/src/isa/aarch64/inst.isle line 3385
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [40], 5)
		20: InstOutput	constructor(output, [19], 6)
		23: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		27: VecMisc2	make_variant(VecMisc2::Not, [])
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1844
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ireduce, 7)
		9: Value	match_some(8)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		15: ValueRegs	constructor(value_reg, [12], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1836
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(bitselect, 7)
		9: Type	match_some(6)
		10: (Value, Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 2)
		16: Reg	constructor(put_in_reg, [15], 3)
		23: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		24: VectorSize	constructor(vector_size, [9], 1)
		27: ValueRegs	constructor(value_reg, [36], 1)
		28: InstOutput	constructor(output, [27], 2)
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1830
		../../codegen/src/isa/aarch64/inst.isle line 2720
		../../codegen/src/isa/aarch64/inst.isle line 2738
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(bitselect, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: (Value, Value, Value)	match_some(6)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: Reg	constructor(put_in_reg, [12], 5)
		24: ALUOp	make_variant(ALUOp::And, [])
		29: ALUOp	make_variant(ALUOp::AndNot, [])
		34: ALUOp	make_variant(ALUOp::Orr, [])
		37: ValueRegs	constructor(value_reg, [59], 1)
		38: InstOutput	constructor(output, [37], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1825
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: VecMisc2	make_variant(VecMisc2::Cnt, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1817
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		16: u8	const_int(1, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		19: VectorSize	make_variant(VectorSize::Size8x16, [])
		22: u8	const_int(0, u8)
		23: ScalarSize	make_variant(ScalarSize::Size8, [])
		25: Type	const_prim(I64)
		26: ImmExtend	make_variant(ImmExtend::Zero, [])
		27: u64	const_int(0, u64)
		28: Reg	constructor(imm, [25, 26, 27], 9)
		29: ValueRegs	constructor(value_regs, [56, 28], 10)
		30: InstOutput	constructor(output, [29], 11)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
		45: VecMisc2	make_variant(VecMisc2::Cnt, [])
		49: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
		60: Type	const_prim(I8X16)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: Type	const_prim(I8X16)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1811
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		26: VecMisc2	make_variant(VecMisc2::Cnt, [])
		30: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		50: Type	const_prim(I8X16)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1805
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		26: VecMisc2	make_variant(VecMisc2::Cnt, [])
		30: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		50: Type	const_prim(I8X16)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 40
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1799
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		26: VecMisc2	make_variant(VecMisc2::Cnt, [])
		31: VecALUOp	make_variant(VecALUOp::Addp, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		52: Type	const_prim(I8X16)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1793
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size8, [])
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		25: VecMisc2	make_variant(VecMisc2::Cnt, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1771
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bmask, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: ValueRegs	constructor(lower_bmask, [7, 9, 10], 2)
		12: InstOutput	constructor(output, [11], 3)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1763
		../../codegen/src/isa/aarch64/inst.isle line 2795
		../../codegen/src/isa/aarch64/inst.isle line 2795
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		14: ValueRegs	constructor(put_in_regs, [9], 4)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		18: ValueRegs	constructor(value_regs, [33, 39], 7)
		19: InstOutput	constructor(output, [18], 8)
		22: BitOp	make_variant(BitOp::Rev64, [])
		26: BitOp	make_variant(BitOp::Rev64, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1760
		../../codegen/src/isa/aarch64/inst.isle line 2795
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: BitOp	make_variant(BitOp::Rev64, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1757
		../../codegen/src/isa/aarch64/inst.isle line 2792
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: BitOp	make_variant(BitOp::Rev32, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1754
		../../codegen/src/isa/aarch64/inst.isle line 2789
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I16)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: BitOp	make_variant(BitOp::Rev16, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1749
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(cls, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		14: BitOp	make_variant(BitOp::Cls, [])
		17: ValueRegs	constructor(value_reg, [24], 1)
		18: InstOutput	constructor(output, [17], 2)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1735
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2800
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 3)
		14: u8	const_int(63, u8)
		15: Imm12	constructor(u8_into_imm12, [14], 10)
		17: Cond	make_variant(Cond::Eq, [])
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 2)
		22: ImmShift	constructor(imm_shift_from_u8, [14], 7)
		25: Reg	constructor(zero_reg, [], 12)
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	const_int(0, u64)
		31: Reg	constructor(imm, [8, 29, 30], 16)
		32: ValueRegs	constructor(value_regs, [127, 31], 17)
		33: InstOutput	constructor(output, [32], 18)
		36: BitOp	make_variant(BitOp::Cls, [])
		40: OperandSize	make_variant(OperandSize::Size64, [])
		44: BitOp	make_variant(BitOp::Cls, [])
		49: ALUOp	make_variant(ALUOp::EorNot, [])
		54: ALUOp	make_variant(ALUOp::Lsr, [])
		60: ALUOp3	make_variant(ALUOp3::MAdd, [])
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::CSel, [66, 17, 120, 25])
		68: Reg	constructor(writable_reg_to_reg, [66], 0)
		69: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [67, 68])
		72: ValueRegs	constructor(with_flags, [92, 69], 1)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [72, 73], 2)
		78: ALUOp	make_variant(ALUOp::Add, [])
		83: Type	const_prim(I64)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: Reg	constructor(writable_reg_to_reg, [84], 0)
		89: ALUOp	make_variant(ALUOp::SubS, [])
		90: WritableReg	constructor(writable_zero_reg, [], 1)
		91: MInst	make_variant(MInst::AluRRImm12, [89, 40, 90, 85, 15])
		92: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [91])
		96: Type	const_prim(I64)
		97: WritableReg	constructor(temp_writable_reg, [96], 1)
		98: Reg	constructor(writable_reg_to_reg, [97], 0)
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: Reg	constructor(writable_reg_to_reg, [104], 0)
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		118: Type	const_prim(I64)
		119: WritableReg	constructor(temp_writable_reg, [118], 1)
		120: Reg	constructor(writable_reg_to_reg, [119], 0)
		125: Type	const_prim(I64)
		126: WritableReg	constructor(temp_writable_reg, [125], 1)
		127: Reg	constructor(writable_reg_to_reg, [126], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Cls, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		17:	const_prim(I64)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Cls, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		17:	const_prim(I32)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [9], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: BitOp	make_variant(BitOp::Cls, [])
		32: ALUOp	make_variant(ALUOp::Sub, [])
		35: ValueRegs	constructor(value_reg, [56], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Cls, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		17:	const_prim(I64)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Cls, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		17:	const_prim(I32)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [9], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: BitOp	make_variant(BitOp::Cls, [])
		32: ALUOp	make_variant(ALUOp::Sub, [])
		35: ValueRegs	constructor(value_reg, [56], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1715
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(ctz, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		15: BitOp	make_variant(BitOp::RBit, [])
		19: BitOp	make_variant(BitOp::Clz, [])
		22: ValueRegs	constructor(value_reg, [35], 1)
		23: InstOutput	constructor(output, [22], 2)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1709
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/lower.isle line 1691
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 4)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [10, 14], 2)
		17: ValueRegs	constructor(value_regs, [49, 55], 6)
		19: InstOutput	constructor(output, [43], 8)
		22: BitOp	make_variant(BitOp::RBit, [])
		26: BitOp	make_variant(BitOp::RBit, [])
		29: Type	const_prim(I64)
		30: usize	const_int(0, usize)
		31: Reg	constructor(value_regs_get, [17, 30], 3)
		33: usize	const_int(1, usize)
		34: Reg	constructor(value_regs_get, [17, 33], 1)
		36: u8	const_int(6, u8)
		37: ImmShift	constructor(imm_shift_from_u8, [36], 5)
		40: ImmExtend	make_variant(ImmExtend::Zero, [])
		41: u64	const_int(0, u64)
		42: Reg	constructor(imm, [29, 40, 41], 8)
		43: ValueRegs	constructor(value_regs, [101, 42], 9)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		58: BitOp	make_variant(BitOp::Clz, [])
		62: BitOp	make_variant(BitOp::Clz, [])
		67: ALUOp	make_variant(ALUOp::Lsr, [])
		73: ALUOp3	make_variant(ALUOp3::MAdd, [])
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: Reg	constructor(writable_reg_to_reg, [79], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: Reg	constructor(writable_reg_to_reg, [85], 0)
		91: Type	const_prim(I64)
		92: WritableReg	constructor(temp_writable_reg, [91], 1)
		93: Reg	constructor(writable_reg_to_reg, [92], 0)
		99: Type	const_prim(I64)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: Reg	constructor(writable_reg_to_reg, [100], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1706
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2709
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u64	const_int(32768, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [8, 12], 3)
		19: BitOp	make_variant(BitOp::RBit, [])
		24: ALUOp	make_variant(ALUOp::Orr, [])
		28: BitOp	make_variant(BitOp::Clz, [])
		31: ValueRegs	constructor(value_reg, [51], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1703
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2709
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u64	const_int(8388608, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [8, 12], 3)
		19: BitOp	make_variant(BitOp::RBit, [])
		24: ALUOp	make_variant(ALUOp::Orr, [])
		28: BitOp	make_variant(BitOp::Clz, [])
		31: ValueRegs	constructor(value_reg, [51], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1682
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(clz, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		14: BitOp	make_variant(BitOp::Clz, [])
		17: ValueRegs	constructor(value_reg, [24], 1)
		18: InstOutput	constructor(output, [17], 2)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1679
		../../codegen/src/isa/aarch64/lower.isle line 1691
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		11: InstOutput	constructor(output, [27], 3)
		13: Type	const_prim(I64)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 3)
		17: usize	const_int(1, usize)
		18: Reg	constructor(value_regs_get, [9, 17], 1)
		20: u8	const_int(6, u8)
		21: ImmShift	constructor(imm_shift_from_u8, [20], 5)
		24: ImmExtend	make_variant(ImmExtend::Zero, [])
		25: u64	const_int(0, u64)
		26: Reg	constructor(imm, [13, 24, 25], 8)
		27: ValueRegs	constructor(value_regs, [73, 26], 9)
		30: BitOp	make_variant(BitOp::Clz, [])
		34: BitOp	make_variant(BitOp::Clz, [])
		39: ALUOp	make_variant(ALUOp::Lsr, [])
		45: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Clz, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		17:	const_prim(I64)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Clz, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		17:	const_prim(I32)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [9], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: BitOp	make_variant(BitOp::Clz, [])
		32: ALUOp	make_variant(ALUOp::Sub, [])
		35: ValueRegs	constructor(value_reg, [56], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Clz, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		17:	const_prim(I64)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Reg	constructor(put_in_reg, [9], 1)
		21: BitOp	make_variant(BitOp::Clz, [])
		26: ALUOp	make_variant(ALUOp::Sub, [])
		29: ValueRegs	constructor(value_reg, [43], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		17:	const_prim(I32)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		17: Type	extractor(value_type, 9)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [9], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: BitOp	make_variant(BitOp::Clz, [])
		32: ALUOp	make_variant(ALUOp::Sub, [])
		35: ValueRegs	constructor(value_reg, [56], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1667
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bitrev, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		14: BitOp	make_variant(BitOp::RBit, [])
		17: ValueRegs	constructor(value_reg, [24], 1)
		18: InstOutput	constructor(output, [17], 2)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1661
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 4)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [10, 14], 2)
		17: ValueRegs	constructor(value_regs, [32, 38], 6)
		18: InstOutput	constructor(output, [17], 7)
		21: BitOp	make_variant(BitOp::RBit, [])
		25: BitOp	make_variant(BitOp::RBit, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1658
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u8	const_int(16, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		18: BitOp	make_variant(BitOp::RBit, [])
		23: ALUOp	make_variant(ALUOp::Lsr, [])
		26: ValueRegs	constructor(value_reg, [40], 1)
		27: InstOutput	constructor(output, [26], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1652
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u8	const_int(24, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		18: BitOp	make_variant(BitOp::RBit, [])
		23: ALUOp	make_variant(ALUOp::Lsr, [])
		26: ValueRegs	constructor(value_reg, [40], 1)
		27: InstOutput	constructor(output, [26], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 246, 281])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 246])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 291])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 291, 326])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_64, 33)
		239: OperandSize	make_variant(OperandSize::Size64, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_64, 64)
		284: OperandSize	make_variant(OperandSize::Size64, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 246, 281])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 246])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 291])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 291, 326])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_64, 33)
		239: OperandSize	make_variant(OperandSize::Size64, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_32, 64)
		284: OperandSize	make_variant(OperandSize::Size32, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 246, 281])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 246])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 291])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 291, 326])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_32, 33)
		239: OperandSize	make_variant(OperandSize::Size32, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_64, 64)
		284: OperandSize	make_variant(OperandSize::Size64, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 246, 281])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 246])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 291])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 291, 326])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_32, 33)
		239: OperandSize	make_variant(OperandSize::Size32, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_32, 64)
		284: OperandSize	make_variant(OperandSize::Size32, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 294])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 294, 329])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 294])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 294, 329])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 294])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 294, 329])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsl, [])
		180: Type	const_prim(I64)
		181: WritableReg	constructor(temp_writable_reg, [180], 1)
		182: MInst	make_variant(MInst::CSel, [181, 68, 69, 294])
		183: Reg	constructor(writable_reg_to_reg, [181], 0)
		184: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [182, 183])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::Lsr, [])
		198: ALUOp	make_variant(ALUOp::OrrNot, [])
		203: ALUOp	make_variant(ALUOp::Lsr, [])
		208: ALUOp	make_variant(ALUOp::Orr, [])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 294, 329])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(184, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		184:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 294])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 294, 329])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 294])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 294, 329])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 294])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 294, 329])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 249, 284])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 249])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 294])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 294, 329])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 252, 287])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 252])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 297])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 297, 332])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_64, 33)
		245: OperandSize	make_variant(OperandSize::Size64, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_64, 64)
		290: OperandSize	make_variant(OperandSize::Size64, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 252, 287])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 252])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 297])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 297, 332])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_64, 33)
		245: OperandSize	make_variant(OperandSize::Size64, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_32, 64)
		290: OperandSize	make_variant(OperandSize::Size32, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 252, 287])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 252])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 297])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 297, 332])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_32, 33)
		245: OperandSize	make_variant(OperandSize::Size32, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_64, 64)
		290: OperandSize	make_variant(OperandSize::Size64, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 8)
		27: Reg	constructor(value_regs_get, [87, 25], 9)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: usize	const_int(1, usize)
		39: Reg	constructor(value_regs_get, [11, 38], 2)
		41: usize	const_int(0, usize)
		42: Reg	constructor(value_regs_get, [11, 41], 1)
		44: u8	const_int(1, u8)
		45: ImmShift	constructor(imm_shift_from_u8, [44], 7)
		47: Type	const_prim(I32)
		48: Reg	constructor(zero_reg, [], 5)
		53: Reg	constructor(zero_reg, [], 14)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: Reg	constructor(zero_reg, [], 13)
		70: usize	const_int(0, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 1)
		74: usize	const_int(1, usize)
		75: Reg	constructor(value_regs_get, [11, 74], 2)
		77: u8	const_int(1, u8)
		78: ImmShift	constructor(imm_shift_from_u8, [77], 7)
		80: Type	const_prim(I32)
		81: Reg	constructor(zero_reg, [], 5)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsr, [])
		114: ALUOp	make_variant(ALUOp::Lsr, [])
		119: ALUOp	make_variant(ALUOp::Lsl, [])
		124: ALUOp	make_variant(ALUOp::OrrNot, [])
		129: ALUOp	make_variant(ALUOp::Lsl, [])
		134: ALUOp	make_variant(ALUOp::Orr, [])
		139: Type	const_prim(I64)
		140: WritableReg	constructor(temp_writable_reg, [139], 1)
		141: MInst	make_variant(MInst::CSel, [140, 37, 252, 287])
		142: Reg	constructor(writable_reg_to_reg, [140], 0)
		143: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [141, 142])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 53, 252])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(143, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsl, [])
		183: Type	const_prim(I64)
		184: WritableReg	constructor(temp_writable_reg, [183], 1)
		185: MInst	make_variant(MInst::CSel, [184, 68, 69, 297])
		186: Reg	constructor(writable_reg_to_reg, [184], 0)
		187: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [185, 186])
		191: ALUOp	make_variant(ALUOp::Lsl, [])
		196: ALUOp	make_variant(ALUOp::Lsr, [])
		201: ALUOp	make_variant(ALUOp::OrrNot, [])
		206: ALUOp	make_variant(ALUOp::Lsr, [])
		211: ALUOp	make_variant(ALUOp::Orr, [])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 297, 332])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(187, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_32, 33)
		245: OperandSize	make_variant(OperandSize::Size32, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_32, 64)
		290: OperandSize	make_variant(OperandSize::Size32, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		143:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		187:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		24: ALUOp	make_variant(ALUOp::RotR, [])
		27: ValueRegs	constructor(value_reg, [35], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1583
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		24: ALUOp	make_variant(ALUOp::RotR, [])
		27: ValueRegs	constructor(value_reg, [35], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		23: Type	extractor(value_type, 17)
		24: Reg	constructor(put_in_reg, [17], 1)
		28: Type	const_prim(I32)
		29: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		34: ValueRegs	constructor(value_reg, [71], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: ALUOp	make_variant(ALUOp::Lsl, [])
		44: ALUOp	make_variant(ALUOp::Lsr, [])
		49: ALUOp	make_variant(ALUOp::Orr, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: Reg	constructor(writable_reg_to_reg, [63], 0)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		23:	const_prim(I64)
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		23: Type	extractor(value_type, 17)
		24: Reg	constructor(put_in_reg, [17], 1)
		28: Type	const_prim(I32)
		29: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		34: ValueRegs	constructor(value_reg, [71], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: ALUOp	make_variant(ALUOp::Lsl, [])
		44: ALUOp	make_variant(ALUOp::Lsr, [])
		49: ALUOp	make_variant(ALUOp::Orr, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: Reg	constructor(writable_reg_to_reg, [63], 0)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		23:	const_prim(I32)
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		23: Type	extractor(value_type, 17)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [17], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(32, u8)
		34: Type	const_prim(I32)
		35: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		40: ValueRegs	constructor(value_reg, [84], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		52: ALUOp	make_variant(ALUOp::Lsl, [])
		57: ALUOp	make_variant(ALUOp::Lsr, [])
		62: ALUOp	make_variant(ALUOp::Orr, [])
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: Reg	constructor(writable_reg_to_reg, [76], 0)
		82: Type	const_prim(I64)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: Reg	constructor(writable_reg_to_reg, [83], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1574
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		21: ALUOp	make_variant(ALUOp::RotR, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1570
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I32)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		21: ALUOp	make_variant(ALUOp::RotR, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		25: Type	const_prim(I32)
		26: Reg	constructor(zero_reg, [], 5)
		27: ImmLogic	constructor(rotr_mask, [9], 1)
		29: u8	constructor(ty_bits, [9], 0)
		30: Imm12	constructor(u8_into_imm12, [29], 3)
		37: ValueRegs	constructor(value_reg, [110], 1)
		38: InstOutput	constructor(output, [37], 2)
		42: ALUOp	make_variant(ALUOp::And, [])
		47: ALUOp	make_variant(ALUOp::Sub, [])
		52: ALUOp	make_variant(ALUOp::Sub, [])
		57: ALUOp	make_variant(ALUOp::Lsl, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Orr, [])
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: Reg	constructor(writable_reg_to_reg, [74], 0)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: Reg	constructor(writable_reg_to_reg, [88], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: Reg	constructor(writable_reg_to_reg, [95], 0)
		101: Type	const_prim(I64)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: Reg	constructor(writable_reg_to_reg, [102], 0)
		108: Type	const_prim(I64)
		109: WritableReg	constructor(temp_writable_reg, [108], 1)
		110: Reg	constructor(writable_reg_to_reg, [109], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		25: Type	const_prim(I32)
		26: Reg	constructor(zero_reg, [], 5)
		27: ImmLogic	constructor(rotr_mask, [9], 1)
		29: u8	constructor(ty_bits, [9], 0)
		30: Imm12	constructor(u8_into_imm12, [29], 3)
		37: ValueRegs	constructor(value_reg, [110], 1)
		38: InstOutput	constructor(output, [37], 2)
		42: ALUOp	make_variant(ALUOp::And, [])
		47: ALUOp	make_variant(ALUOp::Sub, [])
		52: ALUOp	make_variant(ALUOp::Sub, [])
		57: ALUOp	make_variant(ALUOp::Lsl, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Orr, [])
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: Reg	constructor(writable_reg_to_reg, [74], 0)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: Reg	constructor(writable_reg_to_reg, [88], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: Reg	constructor(writable_reg_to_reg, [95], 0)
		101: Type	const_prim(I64)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: Reg	constructor(writable_reg_to_reg, [102], 0)
		108: Type	const_prim(I64)
		109: WritableReg	constructor(temp_writable_reg, [108], 1)
		110: Reg	constructor(writable_reg_to_reg, [109], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I32)
	]
	result = 38
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(32, u8)
		31: Type	const_prim(I32)
		32: Reg	constructor(zero_reg, [], 5)
		33: ImmLogic	constructor(rotr_mask, [9], 1)
		35: u8	constructor(ty_bits, [9], 0)
		36: Imm12	constructor(u8_into_imm12, [35], 3)
		43: ValueRegs	constructor(value_reg, [123], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		55: ALUOp	make_variant(ALUOp::And, [])
		60: ALUOp	make_variant(ALUOp::Sub, [])
		65: ALUOp	make_variant(ALUOp::Sub, [])
		70: ALUOp	make_variant(ALUOp::Lsl, [])
		75: ALUOp	make_variant(ALUOp::Lsr, [])
		80: ALUOp	make_variant(ALUOp::Orr, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: Reg	constructor(writable_reg_to_reg, [87], 0)
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: Reg	constructor(writable_reg_to_reg, [94], 0)
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: Reg	constructor(writable_reg_to_reg, [101], 0)
		107: Type	const_prim(I64)
		108: WritableReg	constructor(temp_writable_reg, [107], 1)
		109: Reg	constructor(writable_reg_to_reg, [108], 0)
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: Reg	constructor(writable_reg_to_reg, [115], 0)
		121: Type	const_prim(I64)
		122: WritableReg	constructor(temp_writable_reg, [121], 1)
		123: Reg	constructor(writable_reg_to_reg, [122], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
	]
	result = 44
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 246])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 246, 281])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 291, 326])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 291])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_64, 33)
		239: OperandSize	make_variant(OperandSize::Size64, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_64, 64)
		284: OperandSize	make_variant(OperandSize::Size64, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 246])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 246, 281])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 291, 326])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 291])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_64, 33)
		239: OperandSize	make_variant(OperandSize::Size64, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_32, 64)
		284: OperandSize	make_variant(OperandSize::Size32, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 246])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 246, 281])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 291, 326])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 291])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_32, 33)
		239: OperandSize	make_variant(OperandSize::Size32, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_64, 64)
		284: OperandSize	make_variant(OperandSize::Size64, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [229, 236], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 222], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 239, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 246])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 246, 281])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 284, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 291, 326])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 291])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [220, 221])
		227: Type	const_prim(I64)
		228: WritableReg	constructor(temp_writable_reg, [227], 1)
		229: Reg	constructor(writable_reg_to_reg, [228], 0)
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		238: Option(Type)	extractor(fits_in_32, 33)
		239: OperandSize	make_variant(OperandSize::Size32, [])
		244: Type	const_prim(I64)
		245: WritableReg	constructor(temp_writable_reg, [244], 1)
		246: Reg	constructor(writable_reg_to_reg, [245], 0)
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		283: Option(Type)	extractor(fits_in_32, 64)
		284: OperandSize	make_variant(OperandSize::Size32, [])
		289: Type	const_prim(I64)
		290: WritableReg	constructor(temp_writable_reg, [289], 1)
		291: Reg	constructor(writable_reg_to_reg, [290], 0)
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		217:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		238:	some
		283:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 294, 329])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 294])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 294, 329])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 294])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 294, 329])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 294])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 156], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [171, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [154, 155])
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
		167: ALUOp	make_variant(ALUOp::AndS, [])
		169: WritableReg	constructor(writable_zero_reg, [], 2)
		170: MInst	make_variant(MInst::AluRRImmLogic, [167, 287, 169, 163, 66])
		171: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [170])
		175: ALUOp	make_variant(ALUOp::Lsr, [])
		180: ALUOp	make_variant(ALUOp::Lsr, [])
		185: ALUOp	make_variant(ALUOp::Lsl, [])
		190: ALUOp	make_variant(ALUOp::OrrNot, [])
		195: ALUOp	make_variant(ALUOp::Lsl, [])
		200: ALUOp	make_variant(ALUOp::Orr, [])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 68, 294, 329])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 68, 84, 294])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		220: MInst	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		221: MInst	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: Reg	match_variant(209, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		223: Reg	match_variant(217, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: ValueRegs	constructor(value_regs, [222, 223], 1)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [220, 221, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		151:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		209:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		217:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 294, 329])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 294])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 294, 329])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 294])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_64, 33)
		242: OperandSize	make_variant(OperandSize::Size64, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 294, 329])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 294])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_64, 64)
		287: OperandSize	make_variant(OperandSize::Size64, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [232, 239], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 225], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 242, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 249])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 249, 284])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 287, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 294, 329])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 294])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [223, 224])
		230: Type	const_prim(I64)
		231: WritableReg	constructor(temp_writable_reg, [230], 1)
		232: Reg	constructor(writable_reg_to_reg, [231], 0)
		237: Type	const_prim(I64)
		238: WritableReg	constructor(temp_writable_reg, [237], 1)
		239: Reg	constructor(writable_reg_to_reg, [238], 0)
		241: Option(Type)	extractor(fits_in_32, 33)
		242: OperandSize	make_variant(OperandSize::Size32, [])
		247: Type	const_prim(I64)
		248: WritableReg	constructor(temp_writable_reg, [247], 1)
		249: Reg	constructor(writable_reg_to_reg, [248], 0)
		254: Type	const_prim(I64)
		255: WritableReg	constructor(temp_writable_reg, [254], 1)
		256: Reg	constructor(writable_reg_to_reg, [255], 0)
		261: Type	const_prim(I64)
		262: WritableReg	constructor(temp_writable_reg, [261], 1)
		263: Reg	constructor(writable_reg_to_reg, [262], 0)
		268: Type	const_prim(I64)
		269: WritableReg	constructor(temp_writable_reg, [268], 1)
		270: Reg	constructor(writable_reg_to_reg, [269], 0)
		275: Type	const_prim(I64)
		276: WritableReg	constructor(temp_writable_reg, [275], 1)
		277: Reg	constructor(writable_reg_to_reg, [276], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: Reg	constructor(writable_reg_to_reg, [283], 0)
		286: Option(Type)	extractor(fits_in_32, 64)
		287: OperandSize	make_variant(OperandSize::Size32, [])
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: Reg	constructor(writable_reg_to_reg, [293], 0)
		299: Type	const_prim(I64)
		300: WritableReg	constructor(temp_writable_reg, [299], 1)
		301: Reg	constructor(writable_reg_to_reg, [300], 0)
		306: Type	const_prim(I64)
		307: WritableReg	constructor(temp_writable_reg, [306], 1)
		308: Reg	constructor(writable_reg_to_reg, [307], 0)
		313: Type	const_prim(I64)
		314: WritableReg	constructor(temp_writable_reg, [313], 1)
		315: Reg	constructor(writable_reg_to_reg, [314], 0)
		320: Type	const_prim(I64)
		321: WritableReg	constructor(temp_writable_reg, [320], 1)
		322: Reg	constructor(writable_reg_to_reg, [321], 0)
		327: Type	const_prim(I64)
		328: WritableReg	constructor(temp_writable_reg, [327], 1)
		329: Reg	constructor(writable_reg_to_reg, [328], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		220:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		241:	some
		286:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 252])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 252, 287])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 297, 332])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 297])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_64, 33)
		245: OperandSize	make_variant(OperandSize::Size64, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_64, 64)
		290: OperandSize	make_variant(OperandSize::Size64, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 252])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 252, 287])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 297, 332])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 297])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_64, 33)
		245: OperandSize	make_variant(OperandSize::Size64, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_32, 64)
		290: OperandSize	make_variant(OperandSize::Size32, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 252])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 252, 287])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 297, 332])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 297])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_32, 33)
		245: OperandSize	make_variant(OperandSize::Size32, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_64, 64)
		290: OperandSize	make_variant(OperandSize::Size64, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [56, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [87, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [56, 25], 11)
		27: Reg	constructor(value_regs_get, [87, 25], 12)
		29: ValueRegs	constructor(value_regs, [235, 242], 14)
		30: InstOutput	constructor(output, [29], 15)
		33: Type	const_prim(I64)
		34: u64	const_int(64, u64)
		35: ImmLogic	constructor(u64_into_imm_logic, [33, 34], 11)
		37: Cond	make_variant(Cond::Ne, [])
		38: Reg	constructor(zero_reg, [], 13)
		39: usize	const_int(0, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 1)
		43: usize	const_int(1, usize)
		44: Reg	constructor(value_regs_get, [11, 43], 2)
		46: u8	const_int(1, u8)
		47: ImmShift	constructor(imm_shift_from_u8, [46], 7)
		49: Type	const_prim(I32)
		50: Reg	constructor(zero_reg, [], 5)
		56: ValueRegs	constructor(with_flags, [105, 159], 17)
		60: ALUOp	make_variant(ALUOp::Sub, [])
		64: Type	const_prim(I64)
		65: u64	const_int(64, u64)
		66: ImmLogic	constructor(u64_into_imm_logic, [64, 65], 11)
		68: Cond	make_variant(Cond::Ne, [])
		69: usize	const_int(1, usize)
		70: Reg	constructor(value_regs_get, [11, 69], 2)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [11, 72], 1)
		75: u8	const_int(1, u8)
		76: ImmShift	constructor(imm_shift_from_u8, [75], 7)
		78: Type	const_prim(I32)
		79: Reg	constructor(zero_reg, [], 5)
		84: Reg	constructor(zero_reg, [], 14)
		87: ValueRegs	constructor(with_flags, [174, 228], 17)
		91: ALUOp	make_variant(ALUOp::Orr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		101: ALUOp	make_variant(ALUOp::AndS, [])
		103: WritableReg	constructor(writable_zero_reg, [], 2)
		104: MInst	make_variant(MInst::AluRRImmLogic, [101, 245, 103, 15, 35])
		105: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [104])
		109: ALUOp	make_variant(ALUOp::Lsl, [])
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: MInst	make_variant(MInst::CSel, [115, 37, 38, 252])
		117: Reg	constructor(writable_reg_to_reg, [115], 0)
		118: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [116, 117])
		122: ALUOp	make_variant(ALUOp::Lsl, [])
		127: ALUOp	make_variant(ALUOp::Lsr, [])
		132: ALUOp	make_variant(ALUOp::OrrNot, [])
		137: ALUOp	make_variant(ALUOp::Lsr, [])
		142: ALUOp	make_variant(ALUOp::Orr, [])
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: MInst	make_variant(MInst::CSel, [148, 37, 252, 287])
		150: Reg	constructor(writable_reg_to_reg, [148], 0)
		151: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [149, 150])
		154: MInst	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		155: MInst	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: Reg	match_variant(118, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		157: Reg	match_variant(151, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: ValueRegs	constructor(value_regs, [156, 157], 1)
		159: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [154, 155, 158])
		164: Type	const_prim(I64)
		165: WritableReg	constructor(temp_writable_reg, [164], 1)
		166: Reg	constructor(writable_reg_to_reg, [165], 0)
		170: ALUOp	make_variant(ALUOp::AndS, [])
		172: WritableReg	constructor(writable_zero_reg, [], 2)
		173: MInst	make_variant(MInst::AluRRImmLogic, [170, 290, 172, 166, 66])
		174: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [173])
		178: ALUOp	make_variant(ALUOp::Lsr, [])
		183: ALUOp	make_variant(ALUOp::Lsr, [])
		188: ALUOp	make_variant(ALUOp::Lsl, [])
		193: ALUOp	make_variant(ALUOp::OrrNot, [])
		198: ALUOp	make_variant(ALUOp::Lsl, [])
		203: ALUOp	make_variant(ALUOp::Orr, [])
		208: Type	const_prim(I64)
		209: WritableReg	constructor(temp_writable_reg, [208], 1)
		210: MInst	make_variant(MInst::CSel, [209, 68, 297, 332])
		211: Reg	constructor(writable_reg_to_reg, [209], 0)
		212: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [210, 211])
		216: Type	const_prim(I64)
		217: WritableReg	constructor(temp_writable_reg, [216], 1)
		218: MInst	make_variant(MInst::CSel, [217, 68, 84, 297])
		219: Reg	constructor(writable_reg_to_reg, [217], 0)
		220: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [218, 219])
		223: MInst	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		224: MInst	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: Reg	match_variant(212, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		226: Reg	match_variant(220, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: ValueRegs	constructor(value_regs, [225, 226], 1)
		228: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [223, 224, 227])
		233: Type	const_prim(I64)
		234: WritableReg	constructor(temp_writable_reg, [233], 1)
		235: Reg	constructor(writable_reg_to_reg, [234], 0)
		240: Type	const_prim(I64)
		241: WritableReg	constructor(temp_writable_reg, [240], 1)
		242: Reg	constructor(writable_reg_to_reg, [241], 0)
		244: Option(Type)	extractor(fits_in_32, 33)
		245: OperandSize	make_variant(OperandSize::Size32, [])
		250: Type	const_prim(I64)
		251: WritableReg	constructor(temp_writable_reg, [250], 1)
		252: Reg	constructor(writable_reg_to_reg, [251], 0)
		257: Type	const_prim(I64)
		258: WritableReg	constructor(temp_writable_reg, [257], 1)
		259: Reg	constructor(writable_reg_to_reg, [258], 0)
		264: Type	const_prim(I64)
		265: WritableReg	constructor(temp_writable_reg, [264], 1)
		266: Reg	constructor(writable_reg_to_reg, [265], 0)
		271: Type	const_prim(I64)
		272: WritableReg	constructor(temp_writable_reg, [271], 1)
		273: Reg	constructor(writable_reg_to_reg, [272], 0)
		278: Type	const_prim(I64)
		279: WritableReg	constructor(temp_writable_reg, [278], 1)
		280: Reg	constructor(writable_reg_to_reg, [279], 0)
		285: Type	const_prim(I64)
		286: WritableReg	constructor(temp_writable_reg, [285], 1)
		287: Reg	constructor(writable_reg_to_reg, [286], 0)
		289: Option(Type)	extractor(fits_in_32, 64)
		290: OperandSize	make_variant(OperandSize::Size32, [])
		295: Type	const_prim(I64)
		296: WritableReg	constructor(temp_writable_reg, [295], 1)
		297: Reg	constructor(writable_reg_to_reg, [296], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: Reg	constructor(writable_reg_to_reg, [303], 0)
		309: Type	const_prim(I64)
		310: WritableReg	constructor(temp_writable_reg, [309], 1)
		311: Reg	constructor(writable_reg_to_reg, [310], 0)
		316: Type	const_prim(I64)
		317: WritableReg	constructor(temp_writable_reg, [316], 1)
		318: Reg	constructor(writable_reg_to_reg, [317], 0)
		323: Type	const_prim(I64)
		324: WritableReg	constructor(temp_writable_reg, [323], 1)
		325: Reg	constructor(writable_reg_to_reg, [324], 0)
		330: Type	const_prim(I64)
		331: WritableReg	constructor(temp_writable_reg, [330], 1)
		332: Reg	constructor(writable_reg_to_reg, [331], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		118:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		151:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		212:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		220:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		244:	some
		289:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1543
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		25: ALUOp	make_variant(ALUOp::RotR, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1538
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		25: ALUOp	make_variant(ALUOp::RotR, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1532
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 5)
		12: Reg	constructor(zero_reg, [], 3)
		13: Value	match_tuple(9, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 1)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 2)
		23: ALUOp	make_variant(ALUOp::Sub, [])
		28: ALUOp	make_variant(ALUOp::RotR, [])
		31: ValueRegs	constructor(value_reg, [46], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1526
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I32)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 5)
		12: Reg	constructor(zero_reg, [], 3)
		13: Value	match_tuple(9, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 1)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 2)
		23: ALUOp	make_variant(ALUOp::Sub, [])
		28: ALUOp	make_variant(ALUOp::RotR, [])
		31: ValueRegs	constructor(value_reg, [46], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		24: Type	extractor(value_type, 17)
		25: Reg	constructor(put_in_reg, [17], 1)
		29: Type	const_prim(I32)
		30: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		35: ValueRegs	constructor(value_reg, [72], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: ALUOp	make_variant(ALUOp::Lsl, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		50: ALUOp	make_variant(ALUOp::Orr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	const_prim(I64)
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		24: Type	extractor(value_type, 17)
		25: Reg	constructor(put_in_reg, [17], 1)
		29: Type	const_prim(I32)
		30: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		35: ValueRegs	constructor(value_reg, [72], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: ALUOp	make_variant(ALUOp::Lsl, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		50: ALUOp	make_variant(ALUOp::Orr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	const_prim(I32)
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		24: Type	extractor(value_type, 17)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [17], 1)
		27: bool	const_prim(false)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(32, u8)
		35: Type	const_prim(I32)
		36: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		41: ValueRegs	constructor(value_reg, [85], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ALUOp	make_variant(ALUOp::Lsl, [])
		58: ALUOp	make_variant(ALUOp::Lsr, [])
		63: ALUOp	make_variant(ALUOp::Orr, [])
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
		83: Type	const_prim(I64)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: Reg	constructor(writable_reg_to_reg, [84], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Type	const_prim(I32)
		14: Reg	constructor(zero_reg, [], 3)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 1)
		17: usize	const_int(0, usize)
		18: Reg	constructor(value_regs_get, [16, 17], 2)
		23: Type	extractor(value_type, 11)
		24: Reg	constructor(put_in_reg, [11], 1)
		28: ALUOp	make_variant(ALUOp::Sub, [])
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		35: ImmLogic	constructor(rotr_mask, [9], 1)
		37: u8	constructor(ty_bits, [9], 0)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		45: ValueRegs	constructor(value_reg, [125], 1)
		46: InstOutput	constructor(output, [45], 2)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::And, [])
		62: ALUOp	make_variant(ALUOp::Sub, [])
		67: ALUOp	make_variant(ALUOp::Sub, [])
		72: ALUOp	make_variant(ALUOp::Lsl, [])
		77: ALUOp	make_variant(ALUOp::Lsr, [])
		82: ALUOp	make_variant(ALUOp::Orr, [])
		88: Type	const_prim(I64)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: Reg	constructor(writable_reg_to_reg, [89], 0)
		95: Type	const_prim(I64)
		96: WritableReg	constructor(temp_writable_reg, [95], 1)
		97: Reg	constructor(writable_reg_to_reg, [96], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: Reg	constructor(writable_reg_to_reg, [103], 0)
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		23:	const_prim(I64)
	]
	result = 46
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Type	const_prim(I32)
		14: Reg	constructor(zero_reg, [], 3)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 1)
		17: usize	const_int(0, usize)
		18: Reg	constructor(value_regs_get, [16, 17], 2)
		23: Type	extractor(value_type, 11)
		24: Reg	constructor(put_in_reg, [11], 1)
		28: ALUOp	make_variant(ALUOp::Sub, [])
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		35: ImmLogic	constructor(rotr_mask, [9], 1)
		37: u8	constructor(ty_bits, [9], 0)
		38: Imm12	constructor(u8_into_imm12, [37], 3)
		45: ValueRegs	constructor(value_reg, [125], 1)
		46: InstOutput	constructor(output, [45], 2)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::And, [])
		62: ALUOp	make_variant(ALUOp::Sub, [])
		67: ALUOp	make_variant(ALUOp::Sub, [])
		72: ALUOp	make_variant(ALUOp::Lsl, [])
		77: ALUOp	make_variant(ALUOp::Lsr, [])
		82: ALUOp	make_variant(ALUOp::Orr, [])
		88: Type	const_prim(I64)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: Reg	constructor(writable_reg_to_reg, [89], 0)
		95: Type	const_prim(I64)
		96: WritableReg	constructor(temp_writable_reg, [95], 1)
		97: Reg	constructor(writable_reg_to_reg, [96], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: Reg	constructor(writable_reg_to_reg, [103], 0)
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		23:	const_prim(I32)
	]
	result = 46
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Type	const_prim(I32)
		14: Reg	constructor(zero_reg, [], 3)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 1)
		17: usize	const_int(0, usize)
		18: Reg	constructor(value_regs_get, [16, 17], 2)
		23: Type	extractor(value_type, 11)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [11], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(32, u8)
		34: ALUOp	make_variant(ALUOp::Sub, [])
		39: Type	const_prim(I32)
		40: Reg	constructor(zero_reg, [], 5)
		41: ImmLogic	constructor(rotr_mask, [9], 1)
		43: u8	constructor(ty_bits, [9], 0)
		44: Imm12	constructor(u8_into_imm12, [43], 3)
		51: ValueRegs	constructor(value_reg, [138], 1)
		52: InstOutput	constructor(output, [51], 2)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		70: ALUOp	make_variant(ALUOp::And, [])
		75: ALUOp	make_variant(ALUOp::Sub, [])
		80: ALUOp	make_variant(ALUOp::Sub, [])
		85: ALUOp	make_variant(ALUOp::Lsl, [])
		90: ALUOp	make_variant(ALUOp::Lsr, [])
		95: ALUOp	make_variant(ALUOp::Orr, [])
		101: Type	const_prim(I64)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: Reg	constructor(writable_reg_to_reg, [102], 0)
		108: Type	const_prim(I64)
		109: WritableReg	constructor(temp_writable_reg, [108], 1)
		110: Reg	constructor(writable_reg_to_reg, [109], 0)
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: Reg	constructor(writable_reg_to_reg, [116], 0)
		122: Type	const_prim(I64)
		123: WritableReg	constructor(temp_writable_reg, [122], 1)
		124: Reg	constructor(writable_reg_to_reg, [123], 0)
		129: Type	const_prim(I64)
		130: WritableReg	constructor(temp_writable_reg, [129], 1)
		131: Reg	constructor(writable_reg_to_reg, [130], 0)
		136: Type	const_prim(I64)
		137: WritableReg	constructor(temp_writable_reg, [136], 1)
		138: Reg	constructor(writable_reg_to_reg, [137], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	some
	]
	result = 52
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1471
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		21: ValueRegs	constructor(put_in_regs, [18], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: Imm64	match_some(13)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: VectorSize	constructor(vector_size, [16], 2)
		26: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1464
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/isa/aarch64/inst.isle line 2745
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 8)
		12: Type	const_prim(I64)
		13: Reg	constructor(zero_reg, [], 5)
		14: Type	const_prim(I32)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(6)
		18: ImmLogic	constructor(shift_mask, [17], 3)
		21: VectorSize	constructor(vector_size, [17], 1)
		28: ALUOp	make_variant(ALUOp::And, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: VecALUOp	make_variant(VecALUOp::Sshl, [])
		46: ValueRegs	constructor(value_reg, [68], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I8X16)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 47
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [44], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 13)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: u8	const_int(63, u8)
		40: ImmShift	constructor(imm_shift_from_u8, [39], 10)
		44: ValueRegs	constructor(with_flags, [52, 108], 18)
		48: ALUOp	make_variant(ALUOp::AndS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [48, 111, 50, 14, 21])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		56: ALUOp	make_variant(ALUOp::Asr, [])
		61: ALUOp	make_variant(ALUOp::Lsr, [])
		66: ALUOp	make_variant(ALUOp::Lsl, [])
		71: ALUOp	make_variant(ALUOp::OrrNot, [])
		76: ALUOp	make_variant(ALUOp::Lsl, [])
		81: ALUOp	make_variant(ALUOp::Orr, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::CSel, [87, 23, 118, 153])
		89: Reg	constructor(writable_reg_to_reg, [87], 0)
		90: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [88, 89])
		94: ALUOp	make_variant(ALUOp::Asr, [])
		99: Type	const_prim(I64)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: MInst	make_variant(MInst::CSel, [100, 23, 160, 118])
		102: Reg	constructor(writable_reg_to_reg, [100], 0)
		103: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [101, 102])
		106: MInst	match_variant(90, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		107: MInst	match_variant(103, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		108: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [106, 107])
		110: Option(Type)	extractor(fits_in_64, 19)
		111: OperandSize	make_variant(OperandSize::Size64, [])
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
		144: Type	const_prim(I64)
		145: WritableReg	constructor(temp_writable_reg, [144], 1)
		146: Reg	constructor(writable_reg_to_reg, [145], 0)
		151: Type	const_prim(I64)
		152: WritableReg	constructor(temp_writable_reg, [151], 1)
		153: Reg	constructor(writable_reg_to_reg, [152], 0)
		158: Type	const_prim(I64)
		159: WritableReg	constructor(temp_writable_reg, [158], 1)
		160: Reg	constructor(writable_reg_to_reg, [159], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		90:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		103:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		110:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [44], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 13)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: u8	const_int(63, u8)
		40: ImmShift	constructor(imm_shift_from_u8, [39], 10)
		44: ValueRegs	constructor(with_flags, [52, 108], 18)
		48: ALUOp	make_variant(ALUOp::AndS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [48, 111, 50, 14, 21])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		56: ALUOp	make_variant(ALUOp::Asr, [])
		61: ALUOp	make_variant(ALUOp::Lsr, [])
		66: ALUOp	make_variant(ALUOp::Lsl, [])
		71: ALUOp	make_variant(ALUOp::OrrNot, [])
		76: ALUOp	make_variant(ALUOp::Lsl, [])
		81: ALUOp	make_variant(ALUOp::Orr, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::CSel, [87, 23, 118, 153])
		89: Reg	constructor(writable_reg_to_reg, [87], 0)
		90: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [88, 89])
		94: ALUOp	make_variant(ALUOp::Asr, [])
		99: Type	const_prim(I64)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: MInst	make_variant(MInst::CSel, [100, 23, 160, 118])
		102: Reg	constructor(writable_reg_to_reg, [100], 0)
		103: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [101, 102])
		106: MInst	match_variant(90, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		107: MInst	match_variant(103, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		108: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [106, 107])
		110: Option(Type)	extractor(fits_in_32, 19)
		111: OperandSize	make_variant(OperandSize::Size32, [])
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
		144: Type	const_prim(I64)
		145: WritableReg	constructor(temp_writable_reg, [144], 1)
		146: Reg	constructor(writable_reg_to_reg, [145], 0)
		151: Type	const_prim(I64)
		152: WritableReg	constructor(temp_writable_reg, [151], 1)
		153: Reg	constructor(writable_reg_to_reg, [152], 0)
		158: Type	const_prim(I64)
		159: WritableReg	constructor(temp_writable_reg, [158], 1)
		160: Reg	constructor(writable_reg_to_reg, [159], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		90:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		103:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		110:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [44], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 13)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: u8	const_int(63, u8)
		40: ImmShift	constructor(imm_shift_from_u8, [39], 10)
		44: ValueRegs	constructor(with_flags, [52, 111], 18)
		48: ALUOp	make_variant(ALUOp::AndS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [48, 114, 50, 14, 21])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		56: ALUOp	make_variant(ALUOp::Asr, [])
		61: ALUOp	make_variant(ALUOp::Lsr, [])
		66: ALUOp	make_variant(ALUOp::Lsl, [])
		71: ALUOp	make_variant(ALUOp::OrrNot, [])
		76: ALUOp	make_variant(ALUOp::Lsl, [])
		81: ALUOp	make_variant(ALUOp::Orr, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::CSel, [87, 23, 121, 156])
		89: Reg	constructor(writable_reg_to_reg, [87], 0)
		90: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [88, 89])
		94: ALUOp	make_variant(ALUOp::Asr, [])
		99: Type	const_prim(I64)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: MInst	make_variant(MInst::CSel, [100, 23, 163, 121])
		102: Reg	constructor(writable_reg_to_reg, [100], 0)
		103: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [101, 102])
		106: MInst	match_variant(90, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		107: MInst	match_variant(103, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		108: Reg	match_variant(90, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		109: Reg	match_variant(103, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		110: ValueRegs	constructor(value_regs, [108, 109], 1)
		111: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [106, 107, 110])
		113: Option(Type)	extractor(fits_in_64, 19)
		114: OperandSize	make_variant(OperandSize::Size64, [])
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: Reg	constructor(writable_reg_to_reg, [134], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: Reg	constructor(writable_reg_to_reg, [141], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: Reg	constructor(writable_reg_to_reg, [148], 0)
		154: Type	const_prim(I64)
		155: WritableReg	constructor(temp_writable_reg, [154], 1)
		156: Reg	constructor(writable_reg_to_reg, [155], 0)
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		90:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		103:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		113:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [44], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 13)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: u8	const_int(63, u8)
		40: ImmShift	constructor(imm_shift_from_u8, [39], 10)
		44: ValueRegs	constructor(with_flags, [52, 111], 18)
		48: ALUOp	make_variant(ALUOp::AndS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [48, 114, 50, 14, 21])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		56: ALUOp	make_variant(ALUOp::Asr, [])
		61: ALUOp	make_variant(ALUOp::Lsr, [])
		66: ALUOp	make_variant(ALUOp::Lsl, [])
		71: ALUOp	make_variant(ALUOp::OrrNot, [])
		76: ALUOp	make_variant(ALUOp::Lsl, [])
		81: ALUOp	make_variant(ALUOp::Orr, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::CSel, [87, 23, 121, 156])
		89: Reg	constructor(writable_reg_to_reg, [87], 0)
		90: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [88, 89])
		94: ALUOp	make_variant(ALUOp::Asr, [])
		99: Type	const_prim(I64)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: MInst	make_variant(MInst::CSel, [100, 23, 163, 121])
		102: Reg	constructor(writable_reg_to_reg, [100], 0)
		103: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [101, 102])
		106: MInst	match_variant(90, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		107: MInst	match_variant(103, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		108: Reg	match_variant(90, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		109: Reg	match_variant(103, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		110: ValueRegs	constructor(value_regs, [108, 109], 1)
		111: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [106, 107, 110])
		113: Option(Type)	extractor(fits_in_32, 19)
		114: OperandSize	make_variant(OperandSize::Size32, [])
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: Reg	constructor(writable_reg_to_reg, [134], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: Reg	constructor(writable_reg_to_reg, [141], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: Reg	constructor(writable_reg_to_reg, [148], 0)
		154: Type	const_prim(I64)
		155: WritableReg	constructor(temp_writable_reg, [154], 1)
		156: Reg	constructor(writable_reg_to_reg, [155], 0)
		161: Type	const_prim(I64)
		162: WritableReg	constructor(temp_writable_reg, [161], 1)
		163: Reg	constructor(writable_reg_to_reg, [162], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		90:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		103:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		113:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1451
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: ALUOp	make_variant(ALUOp::Asr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 18, 13], 2)
		17: Type	extractor(value_type, 11)
		18: Reg	constructor(put_in_reg, [11], 1)
		20: ValueRegs	constructor(value_reg, [14], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		17:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1451
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: ALUOp	make_variant(ALUOp::Asr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 34, 13], 2)
		17: Type	extractor(value_type, 11)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [11], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(64, u8)
		26: ValueRegs	constructor(value_reg, [14], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		18:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 19, 14], 2)
		18: Type	extractor(value_type, 12)
		19: Reg	constructor(put_in_reg, [12], 1)
		21: ValueRegs	constructor(value_reg, [15], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 19, 14], 2)
		18: Type	extractor(value_type, 12)
		19: Reg	constructor(put_in_reg, [12], 1)
		21: ValueRegs	constructor(value_reg, [15], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I32)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 35, 14], 2)
		18: Type	extractor(value_type, 12)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [12], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		27: ValueRegs	constructor(value_reg, [15], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1413
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		21: ValueRegs	constructor(put_in_regs, [18], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1411
		../../codegen/src/isa/aarch64/inst.isle line 2757
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: Imm64	match_some(13)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: VectorSize	constructor(vector_size, [16], 2)
		26: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1406
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/isa/aarch64/inst.isle line 2749
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 8)
		12: Type	const_prim(I64)
		13: Reg	constructor(zero_reg, [], 5)
		14: Type	const_prim(I32)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(6)
		18: ImmLogic	constructor(shift_mask, [17], 3)
		21: VectorSize	constructor(vector_size, [17], 1)
		28: ALUOp	make_variant(ALUOp::And, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: VecALUOp	make_variant(VecALUOp::Ushl, [])
		46: ValueRegs	constructor(value_reg, [68], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I8X16)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 47
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: Reg	constructor(zero_reg, [], 14)
		42: ValueRegs	constructor(with_flags, [50, 101], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 104, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsr, [])
		59: ALUOp	make_variant(ALUOp::Lsr, [])
		64: ALUOp	make_variant(ALUOp::Lsl, [])
		69: ALUOp	make_variant(ALUOp::OrrNot, [])
		74: ALUOp	make_variant(ALUOp::Lsl, [])
		79: ALUOp	make_variant(ALUOp::Orr, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::CSel, [85, 23, 111, 146])
		87: Reg	constructor(writable_reg_to_reg, [85], 0)
		88: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [86, 87])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 39, 111])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(88, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [99, 100])
		103: Option(Type)	extractor(fits_in_64, 19)
		104: OperandSize	make_variant(OperandSize::Size64, [])
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
		144: Type	const_prim(I64)
		145: WritableReg	constructor(temp_writable_reg, [144], 1)
		146: Reg	constructor(writable_reg_to_reg, [145], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		88:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		96:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		103:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: Reg	constructor(zero_reg, [], 14)
		42: ValueRegs	constructor(with_flags, [50, 101], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 104, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsr, [])
		59: ALUOp	make_variant(ALUOp::Lsr, [])
		64: ALUOp	make_variant(ALUOp::Lsl, [])
		69: ALUOp	make_variant(ALUOp::OrrNot, [])
		74: ALUOp	make_variant(ALUOp::Lsl, [])
		79: ALUOp	make_variant(ALUOp::Orr, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::CSel, [85, 23, 111, 146])
		87: Reg	constructor(writable_reg_to_reg, [85], 0)
		88: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [86, 87])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 39, 111])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(88, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [99, 100])
		103: Option(Type)	extractor(fits_in_32, 19)
		104: OperandSize	make_variant(OperandSize::Size32, [])
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
		144: Type	const_prim(I64)
		145: WritableReg	constructor(temp_writable_reg, [144], 1)
		146: Reg	constructor(writable_reg_to_reg, [145], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		88:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		96:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		103:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: Reg	constructor(zero_reg, [], 14)
		42: ValueRegs	constructor(with_flags, [50, 104], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 107, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsr, [])
		59: ALUOp	make_variant(ALUOp::Lsr, [])
		64: ALUOp	make_variant(ALUOp::Lsl, [])
		69: ALUOp	make_variant(ALUOp::OrrNot, [])
		74: ALUOp	make_variant(ALUOp::Lsl, [])
		79: ALUOp	make_variant(ALUOp::Orr, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::CSel, [85, 23, 114, 149])
		87: Reg	constructor(writable_reg_to_reg, [85], 0)
		88: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [86, 87])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 39, 114])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(88, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: Reg	match_variant(88, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		102: Reg	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: ValueRegs	constructor(value_regs, [101, 102], 1)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [99, 100, 103])
		106: Option(Type)	extractor(fits_in_64, 19)
		107: OperandSize	make_variant(OperandSize::Size64, [])
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: Reg	constructor(writable_reg_to_reg, [113], 0)
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: Reg	constructor(writable_reg_to_reg, [134], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: Reg	constructor(writable_reg_to_reg, [141], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: Reg	constructor(writable_reg_to_reg, [148], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		88:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		96:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		106:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [10, 24], 2)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [10, 27], 1)
		30: u8	const_int(1, u8)
		31: ImmShift	constructor(imm_shift_from_u8, [30], 7)
		33: Type	const_prim(I32)
		34: Reg	constructor(zero_reg, [], 5)
		39: Reg	constructor(zero_reg, [], 14)
		42: ValueRegs	constructor(with_flags, [50, 104], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 107, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsr, [])
		59: ALUOp	make_variant(ALUOp::Lsr, [])
		64: ALUOp	make_variant(ALUOp::Lsl, [])
		69: ALUOp	make_variant(ALUOp::OrrNot, [])
		74: ALUOp	make_variant(ALUOp::Lsl, [])
		79: ALUOp	make_variant(ALUOp::Orr, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::CSel, [85, 23, 114, 149])
		87: Reg	constructor(writable_reg_to_reg, [85], 0)
		88: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [86, 87])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 39, 114])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(88, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: Reg	match_variant(88, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		102: Reg	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: ValueRegs	constructor(value_regs, [101, 102], 1)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [99, 100, 103])
		106: Option(Type)	extractor(fits_in_32, 19)
		107: OperandSize	make_variant(OperandSize::Size32, [])
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: Reg	constructor(writable_reg_to_reg, [113], 0)
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: Reg	constructor(writable_reg_to_reg, [134], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: Reg	constructor(writable_reg_to_reg, [141], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: Reg	constructor(writable_reg_to_reg, [148], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		88:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		96:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		106:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1394
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: ALUOp	make_variant(ALUOp::Lsr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 18, 13], 2)
		17: Type	extractor(value_type, 11)
		18: Reg	constructor(put_in_reg, [11], 1)
		20: ValueRegs	constructor(value_reg, [14], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		17:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1394
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: ALUOp	make_variant(ALUOp::Lsr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 34, 13], 2)
		17: Type	extractor(value_type, 11)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [11], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(64, u8)
		26: ValueRegs	constructor(value_reg, [14], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		18:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 19, 14], 2)
		18: Type	extractor(value_type, 12)
		19: Reg	constructor(put_in_reg, [12], 1)
		21: ValueRegs	constructor(value_reg, [15], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 19, 14], 2)
		18: Type	extractor(value_type, 12)
		19: Reg	constructor(put_in_reg, [12], 1)
		21: ValueRegs	constructor(value_reg, [15], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I32)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 35, 14], 2)
		18: Type	extractor(value_type, 12)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [12], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		27: ValueRegs	constructor(value_reg, [15], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/inst.isle line 2753
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: Imm64	match_some(13)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: VectorSize	constructor(vector_size, [16], 2)
		26: VecShiftImmOp	make_variant(VecShiftImmOp::Shl, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1337
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/isa/aarch64/inst.isle line 2745
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 6)
		12: Type	const_prim(I32)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ImmLogic	constructor(shift_mask, [15], 3)
		18: VectorSize	constructor(vector_size, [15], 1)
		25: ALUOp	make_variant(ALUOp::And, [])
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		35: VecALUOp	make_variant(VecALUOp::Sshl, [])
		38: ValueRegs	constructor(value_reg, [53], 1)
		39: InstOutput	constructor(output, [38], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I8X16)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 39
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: Reg	constructor(zero_reg, [], 13)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 1)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [10, 29], 2)
		32: u8	const_int(1, u8)
		33: ImmShift	constructor(imm_shift_from_u8, [32], 7)
		35: Type	const_prim(I32)
		36: Reg	constructor(zero_reg, [], 5)
		42: ValueRegs	constructor(with_flags, [50, 101], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 104, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsl, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::CSel, [60, 23, 24, 111])
		62: Reg	constructor(writable_reg_to_reg, [60], 0)
		63: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [61, 62])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::Lsr, [])
		77: ALUOp	make_variant(ALUOp::OrrNot, [])
		82: ALUOp	make_variant(ALUOp::Lsr, [])
		87: ALUOp	make_variant(ALUOp::Orr, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 111, 146])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(63, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [99, 100])
		103: Option(Type)	extractor(fits_in_64, 19)
		104: OperandSize	make_variant(OperandSize::Size64, [])
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
		144: Type	const_prim(I64)
		145: WritableReg	constructor(temp_writable_reg, [144], 1)
		146: Reg	constructor(writable_reg_to_reg, [145], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		63:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		96:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		103:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: Reg	constructor(zero_reg, [], 13)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 1)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [10, 29], 2)
		32: u8	const_int(1, u8)
		33: ImmShift	constructor(imm_shift_from_u8, [32], 7)
		35: Type	const_prim(I32)
		36: Reg	constructor(zero_reg, [], 5)
		42: ValueRegs	constructor(with_flags, [50, 101], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 104, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsl, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::CSel, [60, 23, 24, 111])
		62: Reg	constructor(writable_reg_to_reg, [60], 0)
		63: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [61, 62])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::Lsr, [])
		77: ALUOp	make_variant(ALUOp::OrrNot, [])
		82: ALUOp	make_variant(ALUOp::Lsr, [])
		87: ALUOp	make_variant(ALUOp::Orr, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 111, 146])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(63, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [99, 100])
		103: Option(Type)	extractor(fits_in_32, 19)
		104: OperandSize	make_variant(OperandSize::Size32, [])
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
		144: Type	const_prim(I64)
		145: WritableReg	constructor(temp_writable_reg, [144], 1)
		146: Reg	constructor(writable_reg_to_reg, [145], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		63:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		96:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		103:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: Reg	constructor(zero_reg, [], 13)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 1)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [10, 29], 2)
		32: u8	const_int(1, u8)
		33: ImmShift	constructor(imm_shift_from_u8, [32], 7)
		35: Type	const_prim(I32)
		36: Reg	constructor(zero_reg, [], 5)
		42: ValueRegs	constructor(with_flags, [50, 104], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 107, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsl, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::CSel, [60, 23, 24, 114])
		62: Reg	constructor(writable_reg_to_reg, [60], 0)
		63: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [61, 62])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::Lsr, [])
		77: ALUOp	make_variant(ALUOp::OrrNot, [])
		82: ALUOp	make_variant(ALUOp::Lsr, [])
		87: ALUOp	make_variant(ALUOp::Orr, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 114, 149])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(63, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: Reg	match_variant(63, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		102: Reg	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: ValueRegs	constructor(value_regs, [101, 102], 1)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [99, 100, 103])
		106: Option(Type)	extractor(fits_in_64, 19)
		107: OperandSize	make_variant(OperandSize::Size64, [])
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: Reg	constructor(writable_reg_to_reg, [113], 0)
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: Reg	constructor(writable_reg_to_reg, [134], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: Reg	constructor(writable_reg_to_reg, [141], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: Reg	constructor(writable_reg_to_reg, [148], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		63:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		96:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		106:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [42], 5)
		19: Type	const_prim(I64)
		20: u64	const_int(64, u64)
		21: ImmLogic	constructor(u64_into_imm_logic, [19, 20], 11)
		23: Cond	make_variant(Cond::Ne, [])
		24: Reg	constructor(zero_reg, [], 13)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 1)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [10, 29], 2)
		32: u8	const_int(1, u8)
		33: ImmShift	constructor(imm_shift_from_u8, [32], 7)
		35: Type	const_prim(I32)
		36: Reg	constructor(zero_reg, [], 5)
		42: ValueRegs	constructor(with_flags, [50, 104], 17)
		46: ALUOp	make_variant(ALUOp::AndS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 2)
		49: MInst	make_variant(MInst::AluRRImmLogic, [46, 107, 48, 14, 21])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: ALUOp	make_variant(ALUOp::Lsl, [])
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: MInst	make_variant(MInst::CSel, [60, 23, 24, 114])
		62: Reg	constructor(writable_reg_to_reg, [60], 0)
		63: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [61, 62])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::Lsr, [])
		77: ALUOp	make_variant(ALUOp::OrrNot, [])
		82: ALUOp	make_variant(ALUOp::Lsr, [])
		87: ALUOp	make_variant(ALUOp::Orr, [])
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::CSel, [93, 23, 114, 149])
		95: Reg	constructor(writable_reg_to_reg, [93], 0)
		96: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [94, 95])
		99: MInst	match_variant(63, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		100: MInst	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: Reg	match_variant(63, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		102: Reg	match_variant(96, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: ValueRegs	constructor(value_regs, [101, 102], 1)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [99, 100, 103])
		106: Option(Type)	extractor(fits_in_32, 19)
		107: OperandSize	make_variant(OperandSize::Size32, [])
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: Reg	constructor(writable_reg_to_reg, [113], 0)
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: Reg	constructor(writable_reg_to_reg, [134], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: Reg	constructor(writable_reg_to_reg, [141], 0)
		147: Type	const_prim(I64)
		148: WritableReg	constructor(temp_writable_reg, [147], 1)
		149: Reg	constructor(writable_reg_to_reg, [148], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		63:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		96:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		106:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1303
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: ALUOp	make_variant(ALUOp::Lsl, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 12, 13], 2)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: ALUOp	make_variant(ALUOp::Lsl, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 13, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1294
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1293
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1281
		../../codegen/src/isa/aarch64/inst.isle line 2733
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::Eor, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1279
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: ALUOp	make_variant(ALUOp::Eor, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [29], 2)
		19: ValueRegs	constructor(put_in_regs, [11], 1)
		20: usize	const_int(0, usize)
		21: Reg	constructor(value_regs_get, [19, 20], 2)
		22: ValueRegs	constructor(put_in_regs, [12], 4)
		23: Reg	constructor(value_regs_get, [22, 20], 5)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [19, 25], 3)
		27: Reg	constructor(value_regs_get, [22, 25], 6)
		29: ValueRegs	constructor(value_regs, [36, 43], 9)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1276
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: ALUOp	make_variant(ALUOp::Eor, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1272
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1271
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1259
		../../codegen/src/isa/aarch64/inst.isle line 2715
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::Orr, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1257
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: ALUOp	make_variant(ALUOp::Orr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [29], 2)
		19: ValueRegs	constructor(put_in_regs, [11], 1)
		20: usize	const_int(0, usize)
		21: Reg	constructor(value_regs_get, [19, 20], 2)
		22: ValueRegs	constructor(put_in_regs, [12], 4)
		23: Reg	constructor(value_regs_get, [22, 20], 5)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [19, 25], 3)
		27: Reg	constructor(value_regs_get, [22, 25], 6)
		29: ValueRegs	constructor(value_regs, [36, 43], 9)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1254
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: ALUOp	make_variant(ALUOp::Orr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1249
		../../codegen/src/isa/aarch64/inst.isle line 2741
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		25: VecALUOp	make_variant(VecALUOp::Bic, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1247
		../../codegen/src/isa/aarch64/inst.isle line 2741
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		25: VecALUOp	make_variant(VecALUOp::Bic, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1245
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1244
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1232
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::And, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1230
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: ALUOp	make_variant(ALUOp::And, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [29], 2)
		19: ValueRegs	constructor(put_in_regs, [11], 1)
		20: usize	const_int(0, usize)
		21: Reg	constructor(value_regs_get, [19, 20], 2)
		22: ValueRegs	constructor(put_in_regs, [12], 4)
		23: Reg	constructor(value_regs_get, [22, 20], 5)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [19, 25], 3)
		27: Reg	constructor(value_regs_get, [22, 25], 6)
		29: ValueRegs	constructor(value_regs, [36, 43], 9)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1227
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: ALUOp	make_variant(ALUOp::And, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1223
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Value))	extractor(bxor, 10)
		12: ALUOp	make_variant(ALUOp::EorNot, [])
		13: Type	const_prim(I64)
		14: (Value, Value)	match_some(11)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		18: InstOutput	constructor(output, [33], 2)
		23: ValueRegs	constructor(put_in_regs, [15], 1)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 2)
		26: ValueRegs	constructor(put_in_regs, [16], 4)
		27: Reg	constructor(value_regs_get, [26, 24], 5)
		29: usize	const_int(1, usize)
		30: Reg	constructor(value_regs_get, [23, 29], 3)
		31: Reg	constructor(value_regs_get, [26, 29], 6)
		33: ValueRegs	constructor(value_regs, [40, 47], 9)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option((Value, Value))	extractor(ishl, 25)
		27: (Value, Value)	match_some(26)
		28: Value	match_tuple(27, 1)
		29: Option(Inst)	extractor(def_inst, 28)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [14, 32], 0)
		34: Reg	constructor(put_in_reg, [16], 1)
		35: Value	match_tuple(27, 0)
		36: Reg	constructor(put_in_reg, [35], 2)
		37: ShiftOpAndAmt	match_some(33)
		40: ValueRegs	constructor(value_reg, [49], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		24:	some
		26:	some
		29:	some
		31:	some
		33:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		24: Option(Inst)	extractor(def_inst, 17)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(ImmLogic)	constructor(imm_logic_from_imm64, [14, 27], 0)
		29: Reg	constructor(put_in_reg, [16], 1)
		30: ImmLogic	match_some(28)
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		24:	some
		26:	some
		28:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		24: Reg	constructor(put_in_reg, [16], 1)
		25: Reg	constructor(put_in_reg, [17], 2)
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1217
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		17: VecMisc2	make_variant(VecMisc2::Not, [])
		20: ValueRegs	constructor(value_reg, [27], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1208
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Type	const_prim(I64)
		9: Reg	constructor(zero_reg, [], 4)
		10: Value	match_some(7)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		15: Reg	constructor(zero_reg, [], 6)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [11, 16], 3)
		19: ValueRegs	constructor(value_regs, [37, 44], 8)
		20: InstOutput	constructor(output, [19], 9)
		24: ALUOp	make_variant(ALUOp::OrrNot, [])
		29: ALUOp	make_variant(ALUOp::OrrNot, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 2701
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(ishl, 11)
		13: (Value, Value)	match_some(12)
		14: Value	match_tuple(13, 1)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: Option(Imm64)	extractor(iconst, 16)
		18: Type	match_some(6)
		19: Imm64	match_some(17)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [18, 19], 0)
		21: Reg	constructor(zero_reg, [], 1)
		22: Value	match_tuple(13, 0)
		23: Reg	constructor(put_in_reg, [22], 2)
		24: ShiftOpAndAmt	match_some(20)
		31: ALUOp	make_variant(ALUOp::OrrNot, [])
		34: ValueRegs	constructor(value_reg, [43], 1)
		35: InstOutput	constructor(output, [34], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		17:	some
		20:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1197
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Type	match_some(6)
		10: Reg	constructor(zero_reg, [], 1)
		11: Value	match_some(8)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: ALUOp	make_variant(ALUOp::OrrNot, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1181
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Reg	constructor(put_in_reg, [13], 1)
		16: Uimm8	match_tuple(12, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Type	const_prim(I64)
		21: u8	const_int(63, u8)
		22: ImmShift	constructor(imm_shift_from_u8, [21], 3)
		24: ValueRegs	constructor(value_regs, [31, 43], 5)
		25: InstOutput	constructor(output, [24], 6)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		35: ALUOp	make_variant(ALUOp::Asr, [])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		14:	const_prim(I64X2)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1170
		../../codegen/src/isa/aarch64/inst.isle line 3008
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: Uimm8	match_tuple(12, 1)
		18: u8	extractor(u8_from_uimm8, 17)
		19: VectorSize	constructor(vector_size, [14], 2)
		20: Type	const_prim(I64)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [36, 48], 7)
		27: InstOutput	constructor(output, [26], 8)
		29: OperandSize	make_variant(OperandSize::Size64, [])
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ALUOp	make_variant(ALUOp::Asr, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
		20:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1170
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: Uimm8	match_tuple(12, 1)
		18: u8	extractor(u8_from_uimm8, 17)
		19: VectorSize	constructor(vector_size, [14], 2)
		20: Type	const_prim(I64)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [37, 49], 7)
		27: InstOutput	constructor(output, [26], 8)
		29: Option(Type)	extractor(fits_in_32, 20)
		30: OperandSize	make_variant(OperandSize::Size32, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		41: ALUOp	make_variant(ALUOp::Asr, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
		29:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1160
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 2)
		14: ValueRegs	constructor(value_regs, [18, 30], 4)
		15: InstOutput	constructor(output, [14], 5)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		22: ALUOp	make_variant(ALUOp::Asr, [])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		17:	const_prim(I64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1160
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 2)
		14: ValueRegs	constructor(value_regs, [36, 43], 4)
		15: InstOutput	constructor(output, [14], 5)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(64, u8)
		28: ALUOp	make_variant(ALUOp::Asr, [])
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		18:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1151
		../../codegen/src/isa/aarch64/inst.isle line 3008
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_tuple(13, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: VectorSize	constructor(vector_size, [18], 2)
		20: Type	match_some(6)
		25: OperandSize	make_variant(OperandSize::Size64, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		20:	const_prim(I64)
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1151
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_tuple(13, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: VectorSize	constructor(vector_size, [18], 2)
		20: Type	match_some(6)
		25: Option(Type)	extractor(fits_in_32, 20)
		26: OperandSize	make_variant(OperandSize::Size32, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		25:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1146
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(true)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1137
		../../codegen/src/isa/aarch64/inst.isle line 2299
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Uimm8	match_tuple(12, 1)
		16: u8	extractor(u8_from_uimm8, 15)
		17: Type	extractor(value_type, 13)
		18: ScalarSize	constructor(lane_size, [17], 2)
		20: Type	const_prim(I64)
		21: ImmExtend	make_variant(ImmExtend::Zero, [])
		22: u64	const_int(0, u64)
		23: Reg	constructor(imm, [20, 21, 22], 4)
		24: ValueRegs	constructor(value_regs, [31, 23], 5)
		25: InstOutput	constructor(output, [24], 6)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
		../../codegen/src/isa/aarch64/inst.isle line 2997
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [18, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		17:	const_prim(I64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [31, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(64, u8)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		18:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1125
		../../codegen/src/isa/aarch64/inst.isle line 3040
		../../codegen/src/isa/aarch64/inst.isle line 2347
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((MemFlags, Value))	extractor(atomic_load, 11)
		13: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		14: Type	extractor(value_type, 9)
		15: (MemFlags, Value)	match_some(12)
		16: MemFlags	match_tuple(15, 0)
		17: Inst	match_some(13)
		22: Option((MemFlags, Value))	extractor(atomic_load, 17)
		23: (MemFlags, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Reg	constructor(put_in_reg, [24], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		13:	some
		22:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1118
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_tuple(13, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: ScalarSize	constructor(lane_size, [18], 2)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1113
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(false)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1106
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umax, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [11], 4)
		18: Reg	constructor(put_in_reg, [13], 5)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		33: VectorSize	constructor(vector_size, [8], 1)
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1103
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Umax, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1100
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smax, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [11], 4)
		18: Reg	constructor(put_in_reg, [13], 5)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		33: VectorSize	constructor(vector_size, [8], 1)
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1097
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Smax, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1094
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umin, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [13], 4)
		18: Reg	constructor(put_in_reg, [11], 5)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		33: VectorSize	constructor(vector_size, [8], 1)
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1091
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Umin, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1088
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smin, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [13], 4)
		18: Reg	constructor(put_in_reg, [11], 5)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		32: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		33: VectorSize	constructor(vector_size, [8], 1)
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1085
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Smin, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_64, 24)
		38: OperandSize	make_variant(OperandSize::Size64, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_32, 24)
		38: OperandSize	make_variant(OperandSize::Size32, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_64, 24)
		34: OperandSize	make_variant(OperandSize::Size64, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_32, 24)
		34: OperandSize	make_variant(OperandSize::Size32, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_64, 24)
		38: OperandSize	make_variant(OperandSize::Size64, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_32, 24)
		38: OperandSize	make_variant(OperandSize::Size32, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_64, 24)
		34: OperandSize	make_variant(OperandSize::Size64, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_32, 24)
		34: OperandSize	make_variant(OperandSize::Size32, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_64, 24)
		38: OperandSize	make_variant(OperandSize::Size64, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_32, 24)
		38: OperandSize	make_variant(OperandSize::Size32, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_64, 24)
		34: OperandSize	make_variant(OperandSize::Size64, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_32, 24)
		34: OperandSize	make_variant(OperandSize::Size32, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_64, 24)
		38: OperandSize	make_variant(OperandSize::Size64, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [35], 2)
		23: Option(Type)	extractor(fits_in_16, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: u8	constructor(ty_bits, [24], 0)
		28: u8	const_int(32, u8)
		30: Reg	constructor(put_in_reg, [15], 3)
		35: ValueRegs	constructor(value_reg, [72], 9)
		37: Option(Type)	extractor(fits_in_32, 24)
		38: OperandSize	make_variant(OperandSize::Size32, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRR, [56, 38, 57, 45, 52])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: MInst	make_variant(MInst::CSel, [64, 11, 45, 52])
		66: Reg	constructor(writable_reg_to_reg, [64], 0)
		67: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [65, 66])
		70: ValueRegs	constructor(with_flags, [59, 67], 1)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [70, 71], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		37:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_64, 24)
		34: OperandSize	make_variant(OperandSize::Size64, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [31], 2)
		23: Option(Type)	extractor(fits_in_64, 10)
		24: Type	match_some(23)
		26: Reg	constructor(put_in_reg, [14], 1)
		27: Reg	constructor(put_in_reg, [15], 2)
		31: ValueRegs	constructor(value_reg, [54], 7)
		33: Option(Type)	extractor(fits_in_32, 24)
		34: OperandSize	make_variant(OperandSize::Size32, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRR, [38, 34, 39, 26, 27])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSel, [46, 11, 26, 27])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [41, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		23:	some
		33:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		22: Option(Inst)	extractor(def_inst, 13)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(u64)	extractor(nonzero_u64_from_imm64, 25)
		27: Type	extractor(value_type, 13)
		28: ImmExtend	make_variant(ImmExtend::Sign, [])
		29: u64	match_some(26)
		30: Reg	constructor(imm, [27, 28, 29], 1)
		34: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [59], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		22:	some
		24:	some
		26:	some
	]
	result = 44
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		27: ALUOp	make_variant(ALUOp::SDiv, [])
		33: ALUOp3	make_variant(ALUOp3::MSub, [])
		36: ValueRegs	constructor(value_reg, [56], 1)
		37: InstOutput	constructor(output, [36], 2)
		39: Type	extractor(value_type, 13)
		40: Reg	constructor(put_in_reg, [13], 1)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		39:	const_prim(I64)
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		27: ALUOp	make_variant(ALUOp::SDiv, [])
		33: ALUOp3	make_variant(ALUOp3::MSub, [])
		36: ValueRegs	constructor(value_reg, [62], 1)
		37: InstOutput	constructor(output, [36], 2)
		39: Type	extractor(value_type, 13)
		40: Option(Type)	extractor(fits_in_32, 39)
		41: Reg	constructor(put_in_reg, [13], 1)
		42: bool	const_prim(true)
		43: Type	match_some(40)
		44: u8	constructor(ty_bits, [43], 0)
		45: u8	const_int(64, u8)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		40:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(true)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		28: Option(Inst)	extractor(def_inst, 13)
		29: Inst	match_some(28)
		30: Option(Imm64)	extractor(iconst, 29)
		31: Imm64	match_some(30)
		32: Option(u64)	extractor(nonzero_u64_from_imm64, 31)
		33: Type	extractor(value_type, 13)
		34: ImmExtend	make_variant(ImmExtend::Sign, [])
		35: u64	match_some(32)
		36: Reg	constructor(imm, [33, 34, 35], 1)
		40: ALUOp	make_variant(ALUOp::SDiv, [])
		46: ALUOp3	make_variant(ALUOp3::MSub, [])
		49: ValueRegs	constructor(value_reg, [72], 1)
		50: InstOutput	constructor(output, [49], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		28:	some
		30:	some
		32:	some
	]
	result = 50
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(true)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::SDiv, [])
		39: ALUOp3	make_variant(ALUOp3::MSub, [])
		42: ValueRegs	constructor(value_reg, [69], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: Type	extractor(value_type, 13)
		53: Reg	constructor(put_in_reg, [13], 1)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		52:	const_prim(I64)
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(true)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::SDiv, [])
		39: ALUOp3	make_variant(ALUOp3::MSub, [])
		42: ValueRegs	constructor(value_reg, [75], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: Type	extractor(value_type, 13)
		53: Option(Type)	extractor(fits_in_32, 52)
		54: Reg	constructor(put_in_reg, [13], 1)
		55: bool	const_prim(true)
		56: Type	match_some(53)
		57: u8	constructor(ty_bits, [56], 0)
		58: u8	const_int(64, u8)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: Reg	constructor(writable_reg_to_reg, [74], 0)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		53:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		22: Option(Inst)	extractor(def_inst, 13)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(u64)	extractor(nonzero_u64_from_imm64, 25)
		27: Type	extractor(value_type, 13)
		28: ImmExtend	make_variant(ImmExtend::Zero, [])
		29: u64	match_some(26)
		30: Reg	constructor(imm, [27, 28, 29], 1)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [59], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		22:	some
		24:	some
		26:	some
	]
	result = 44
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		27: ALUOp	make_variant(ALUOp::UDiv, [])
		33: ALUOp3	make_variant(ALUOp3::MSub, [])
		36: ValueRegs	constructor(value_reg, [56], 1)
		37: InstOutput	constructor(output, [36], 2)
		39: Type	extractor(value_type, 13)
		40: Reg	constructor(put_in_reg, [13], 1)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		39:	const_prim(I64)
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		27: ALUOp	make_variant(ALUOp::UDiv, [])
		33: ALUOp3	make_variant(ALUOp3::MSub, [])
		36: ValueRegs	constructor(value_reg, [62], 1)
		37: InstOutput	constructor(output, [36], 2)
		39: Type	extractor(value_type, 13)
		40: Option(Type)	extractor(fits_in_32, 39)
		41: Reg	constructor(put_in_reg, [13], 1)
		42: bool	const_prim(false)
		43: Type	match_some(40)
		44: u8	constructor(ty_bits, [43], 0)
		45: u8	const_int(64, u8)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		40:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		28: Option(Inst)	extractor(def_inst, 13)
		29: Inst	match_some(28)
		30: Option(Imm64)	extractor(iconst, 29)
		31: Imm64	match_some(30)
		32: Option(u64)	extractor(nonzero_u64_from_imm64, 31)
		33: Type	extractor(value_type, 13)
		34: ImmExtend	make_variant(ImmExtend::Zero, [])
		35: u64	match_some(32)
		36: Reg	constructor(imm, [33, 34, 35], 1)
		40: ALUOp	make_variant(ALUOp::UDiv, [])
		46: ALUOp3	make_variant(ALUOp3::MSub, [])
		49: ValueRegs	constructor(value_reg, [72], 1)
		50: InstOutput	constructor(output, [49], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		28:	some
		30:	some
		32:	some
	]
	result = 50
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		39: ALUOp3	make_variant(ALUOp3::MSub, [])
		42: ValueRegs	constructor(value_reg, [69], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: Type	extractor(value_type, 13)
		53: Reg	constructor(put_in_reg, [13], 1)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		52:	const_prim(I64)
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		39: ALUOp3	make_variant(ALUOp3::MSub, [])
		42: ValueRegs	constructor(value_reg, [75], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		52: Type	extractor(value_type, 13)
		53: Option(Type)	extractor(fits_in_32, 52)
		54: Reg	constructor(put_in_reg, [13], 1)
		55: bool	const_prim(false)
		56: Type	match_some(53)
		57: u8	constructor(ty_bits, [56], 0)
		58: u8	const_int(64, u8)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: Reg	constructor(writable_reg_to_reg, [74], 0)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		53:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Type	const_prim(I64)
		18: Value	match_tuple(9, 0)
		20: ImmExtend	make_variant(ImmExtend::Sign, [])
		21: u64	match_some(16)
		22: Reg	constructor(imm, [14, 20, 21], 2)
		26: Type	extractor(value_type, 18)
		27: Reg	constructor(put_in_reg, [18], 1)
		31: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		26:	const_prim(I64)
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Type	const_prim(I64)
		18: Value	match_tuple(9, 0)
		20: ImmExtend	make_variant(ImmExtend::Sign, [])
		21: u64	match_some(16)
		22: Reg	constructor(imm, [14, 20, 21], 2)
		26: Type	extractor(value_type, 18)
		27: Option(Type)	extractor(fits_in_32, 26)
		28: Reg	constructor(put_in_reg, [18], 1)
		29: bool	const_prim(true)
		30: Type	match_some(27)
		31: u8	constructor(ty_bits, [30], 0)
		32: u8	const_int(64, u8)
		37: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ValueRegs	constructor(value_reg, [55], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		27:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		20: Type	extractor(value_type, 12)
		21: Reg	constructor(put_in_reg, [12], 1)
		23: Option(Inst)	extractor(def_inst, 14)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(u64)	extractor(nonzero_u64_from_imm64, 26)
		28: Type	extractor(value_type, 14)
		29: ImmExtend	make_variant(ImmExtend::Sign, [])
		30: u64	match_some(27)
		31: Reg	constructor(imm, [28, 29, 30], 1)
		38: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ValueRegs	constructor(value_reg, [49], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		23:	some
		25:	some
		27:	some
	]
	result = 42
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		20: Type	extractor(value_type, 12)
		21: Reg	constructor(put_in_reg, [12], 1)
		31: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ValueRegs	constructor(value_reg, [46], 1)
		35: InstOutput	constructor(output, [34], 2)
		37: Type	extractor(value_type, 14)
		38: Reg	constructor(put_in_reg, [14], 1)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		37:	const_prim(I64)
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		20: Type	extractor(value_type, 12)
		21: Reg	constructor(put_in_reg, [12], 1)
		31: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ValueRegs	constructor(value_reg, [52], 1)
		35: InstOutput	constructor(output, [34], 2)
		37: Type	extractor(value_type, 14)
		38: Option(Type)	extractor(fits_in_32, 37)
		39: Reg	constructor(put_in_reg, [14], 1)
		40: bool	const_prim(true)
		41: Type	match_some(38)
		42: u8	constructor(ty_bits, [41], 0)
		43: u8	const_int(64, u8)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		38:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		20: Type	extractor(value_type, 12)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [12], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		29: Option(Inst)	extractor(def_inst, 14)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(u64)	extractor(nonzero_u64_from_imm64, 32)
		34: Type	extractor(value_type, 14)
		35: ImmExtend	make_variant(ImmExtend::Sign, [])
		36: u64	match_some(33)
		37: Reg	constructor(imm, [34, 35, 36], 1)
		44: ALUOp	make_variant(ALUOp::SDiv, [])
		47: ValueRegs	constructor(value_reg, [62], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		29:	some
		31:	some
		33:	some
	]
	result = 48
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		20: Type	extractor(value_type, 12)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [12], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		37: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ValueRegs	constructor(value_reg, [59], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: Type	extractor(value_type, 14)
		51: Reg	constructor(put_in_reg, [14], 1)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		50:	const_prim(I64)
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		20: Type	extractor(value_type, 12)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [12], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		37: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ValueRegs	constructor(value_reg, [65], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: Type	extractor(value_type, 14)
		51: Option(Type)	extractor(fits_in_32, 50)
		52: Reg	constructor(put_in_reg, [14], 1)
		53: bool	const_prim(true)
		54: Type	match_some(51)
		55: u8	constructor(ty_bits, [54], 0)
		56: u8	const_int(64, u8)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		51:	some
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Type	extractor(value_type, 11)
		19: Reg	constructor(put_in_reg, [11], 1)
		21: Option(Inst)	extractor(def_inst, 13)
		22: Inst	match_some(21)
		23: Option(Imm64)	extractor(iconst, 22)
		24: Imm64	match_some(23)
		25: Option(u64)	extractor(nonzero_u64_from_imm64, 24)
		26: Type	extractor(value_type, 13)
		27: ImmExtend	make_variant(ImmExtend::Zero, [])
		28: u64	match_some(25)
		29: Reg	constructor(imm, [26, 27, 28], 1)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		36: ValueRegs	constructor(value_reg, [44], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I64)
		21:	some
		23:	some
		25:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Type	extractor(value_type, 11)
		19: Reg	constructor(put_in_reg, [11], 1)
		26: ALUOp	make_variant(ALUOp::UDiv, [])
		29: ValueRegs	constructor(value_reg, [41], 1)
		30: InstOutput	constructor(output, [29], 2)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I64)
		32:	const_prim(I64)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Type	extractor(value_type, 11)
		19: Reg	constructor(put_in_reg, [11], 1)
		26: ALUOp	make_variant(ALUOp::UDiv, [])
		29: ValueRegs	constructor(value_reg, [47], 1)
		30: InstOutput	constructor(output, [29], 2)
		32: Type	extractor(value_type, 13)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [13], 1)
		35: bool	const_prim(false)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(64, u8)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		18:	const_prim(I64)
		33:	some
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Type	extractor(value_type, 11)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [11], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		27: Option(Inst)	extractor(def_inst, 13)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(u64)	extractor(nonzero_u64_from_imm64, 30)
		32: Type	extractor(value_type, 13)
		33: ImmExtend	make_variant(ImmExtend::Zero, [])
		34: u64	match_some(31)
		35: Reg	constructor(imm, [32, 33, 34], 1)
		39: ALUOp	make_variant(ALUOp::UDiv, [])
		42: ValueRegs	constructor(value_reg, [57], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	some
		27:	some
		29:	some
		31:	some
	]
	result = 43
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Type	extractor(value_type, 11)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [11], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		32: ALUOp	make_variant(ALUOp::UDiv, [])
		35: ValueRegs	constructor(value_reg, [54], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: Type	extractor(value_type, 13)
		46: Reg	constructor(put_in_reg, [13], 1)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	some
		45:	const_prim(I64)
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Type	extractor(value_type, 11)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [11], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		32: ALUOp	make_variant(ALUOp::UDiv, [])
		35: ValueRegs	constructor(value_reg, [60], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: Type	extractor(value_type, 13)
		46: Option(Type)	extractor(fits_in_32, 45)
		47: Reg	constructor(put_in_reg, [13], 1)
		48: bool	const_prim(false)
		49: Type	match_some(46)
		50: u8	constructor(ty_bits, [49], 0)
		51: u8	const_int(64, u8)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	some
		46:	some
	]
	result = 36
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [54], 7)
		22: InstOutput	constructor(output, [21], 8)
		24: Type	extractor(value_type, 11)
		25: Reg	constructor(put_in_reg, [11], 1)
		27: Type	extractor(value_type, 13)
		28: Reg	constructor(put_in_reg, [13], 1)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::Lsr, [])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
		27:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [67], 7)
		22: InstOutput	constructor(output, [21], 8)
		24: Type	extractor(value_type, 11)
		25: Reg	constructor(put_in_reg, [11], 1)
		27: Type	extractor(value_type, 13)
		28: Option(Type)	extractor(fits_in_32, 27)
		29: Reg	constructor(put_in_reg, [13], 1)
		30: bool	const_prim(false)
		31: Type	match_some(28)
		32: u8	constructor(ty_bits, [31], 0)
		33: u8	const_int(64, u8)
		39: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::Lsr, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
		28:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [67], 7)
		22: InstOutput	constructor(output, [21], 8)
		24: Type	extractor(value_type, 11)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [11], 1)
		27: bool	const_prim(false)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(64, u8)
		33: Type	extractor(value_type, 13)
		34: Reg	constructor(put_in_reg, [13], 1)
		39: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::Lsr, [])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
		33:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [80], 7)
		22: InstOutput	constructor(output, [21], 8)
		24: Type	extractor(value_type, 11)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [11], 1)
		27: bool	const_prim(false)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(64, u8)
		33: Type	extractor(value_type, 13)
		34: Option(Type)	extractor(fits_in_32, 33)
		35: Reg	constructor(put_in_reg, [13], 1)
		36: bool	const_prim(false)
		37: Type	match_some(34)
		38: u8	constructor(ty_bits, [37], 0)
		39: u8	const_int(64, u8)
		45: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::Lsr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: Reg	constructor(writable_reg_to_reg, [79], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
		34:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 949
		../../codegen/src/isa/aarch64/inst.isle line 2520
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umulhi, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		19: ALUOp	make_variant(ALUOp::UMulH, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		23: Type	extractor(value_type, 11)
		24: Reg	constructor(put_in_reg, [11], 1)
		26: Type	extractor(value_type, 13)
		27: Reg	constructor(put_in_reg, [13], 1)
		32: ALUOp3	make_variant(ALUOp3::MAdd, [])
		37: ALUOp	make_variant(ALUOp::Asr, [])
		40: ValueRegs	constructor(value_reg, [56], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		23:	const_prim(I64)
		26:	const_prim(I64)
	]
	result = 41
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		23: Type	extractor(value_type, 11)
		24: Reg	constructor(put_in_reg, [11], 1)
		26: Type	extractor(value_type, 13)
		27: Option(Type)	extractor(fits_in_32, 26)
		28: Reg	constructor(put_in_reg, [13], 1)
		29: bool	const_prim(true)
		30: Type	match_some(27)
		31: u8	constructor(ty_bits, [30], 0)
		32: u8	const_int(64, u8)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::Asr, [])
		46: ValueRegs	constructor(value_reg, [69], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		23:	const_prim(I64)
		27:	some
	]
	result = 47
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		23: Type	extractor(value_type, 11)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [11], 1)
		26: bool	const_prim(true)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(64, u8)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		43: ALUOp	make_variant(ALUOp::Asr, [])
		46: ValueRegs	constructor(value_reg, [69], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	some
		32:	const_prim(I64)
	]
	result = 47
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		23: Type	extractor(value_type, 11)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [11], 1)
		26: bool	const_prim(true)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(64, u8)
		32: Type	extractor(value_type, 13)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [13], 1)
		35: bool	const_prim(true)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(64, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp	make_variant(ALUOp::Asr, [])
		52: ValueRegs	constructor(value_reg, [82], 1)
		53: InstOutput	constructor(output, [52], 2)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
		73: Type	const_prim(I64)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: Reg	constructor(writable_reg_to_reg, [74], 0)
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	some
		33:	some
	]
	result = 53
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 937
		../../codegen/src/isa/aarch64/inst.isle line 2524
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smulhi, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		19: ALUOp	make_variant(ALUOp::SMulH, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 930
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 924
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 918
		../../codegen/src/isa/aarch64/inst.isle line 2656
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 912
		../../codegen/src/isa/aarch64/inst.isle line 2656
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I32X4)
		16:	some
		18:	some
		20:	const_prim(I32X4)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 906
		../../codegen/src/isa/aarch64/inst.isle line 2652
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 900
		../../codegen/src/isa/aarch64/inst.isle line 2652
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 894
		../../codegen/src/isa/aarch64/inst.isle line 2648
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 888
		../../codegen/src/isa/aarch64/inst.isle line 2648
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I16X8)
		16:	some
		18:	some
		20:	const_prim(I16X8)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 882
		../../codegen/src/isa/aarch64/inst.isle line 2644
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 876
		../../codegen/src/isa/aarch64/inst.isle line 2644
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 870
		../../codegen/src/isa/aarch64/inst.isle line 2640
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 864
		../../codegen/src/isa/aarch64/inst.isle line 2640
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		29: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		32: ValueRegs	constructor(value_reg, [40], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I8X16)
		16:	some
		18:	some
		20:	const_prim(I8X16)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 825
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/isa/aarch64/inst.isle line 2528
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/isa/aarch64/inst.isle line 2618
		../../codegen/src/isa/aarch64/inst.isle line 2548
		../../codegen/src/isa/aarch64/inst.isle line 2548
		../../codegen/src/isa/aarch64/inst.isle line 2636
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2223
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Value	match_tuple(8, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		17: bool	const_prim(false)
		19: ScalarSize	make_variant(ScalarSize::Size32, [])
		26: VecMisc2	make_variant(VecMisc2::Rev64, [])
		31: VecALUOp	make_variant(VecALUOp::Mul, [])
		36: VecALUOp	make_variant(VecALUOp::Addp, [])
		40: VecRRLongOp	make_variant(VecRRLongOp::Shll32, [])
		44: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		48: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		54: VecRRRLongModOp	make_variant(VecRRRLongModOp::Umlal32, [])
		57: ValueRegs	constructor(value_reg, [104], 1)
		58: InstOutput	constructor(output, [57], 2)
		62: Type	const_prim(I8X16)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: Reg	constructor(writable_reg_to_reg, [63], 0)
		69: Type	const_prim(I8X16)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		76: Type	const_prim(I8X16)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
		82: Type	const_prim(I8X16)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: Reg	constructor(writable_reg_to_reg, [83], 0)
		88: Type	const_prim(I8X16)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: Reg	constructor(writable_reg_to_reg, [89], 0)
		94: Type	const_prim(I8X16)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: Reg	constructor(writable_reg_to_reg, [95], 0)
		102: Type	const_prim(I8X16)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: Reg	constructor(writable_reg_to_reg, [103], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 58
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 793
		../../codegen/src/isa/aarch64/inst.isle line 2528
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option(())	extractor(not_i64x2, 9)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [9], 3)
		22: VecALUOp	make_variant(VecALUOp::Mul, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 765
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2520
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		17: Reg	constructor(zero_reg, [], 10)
		19: usize	const_int(1, usize)
		20: Reg	constructor(value_regs_get, [11, 19], 3)
		21: Reg	constructor(value_regs_get, [15, 19], 6)
		25: ValueRegs	constructor(value_regs, [57, 80], 12)
		26: InstOutput	constructor(output, [25], 13)
		31: ALUOp3	make_variant(ALUOp3::MAdd, [])
		36: ALUOp	make_variant(ALUOp::UMulH, [])
		42: ALUOp3	make_variant(ALUOp3::MAdd, [])
		48: ALUOp3	make_variant(ALUOp3::MAdd, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: Reg	constructor(writable_reg_to_reg, [79], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 761
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(zero_reg, [], 3)
		22: ALUOp3	make_variant(ALUOp3::MAdd, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 755
		../../codegen/src/isa/aarch64/inst.isle line 2532
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		17: VecMisc2	make_variant(VecMisc2::Neg, [])
		20: ValueRegs	constructor(value_reg, [27], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [30], 4)
		13: Type	const_prim(I64)
		14: ImmExtend	make_variant(ImmExtend::Zero, [])
		15: u64	const_int(0, u64)
		16: Reg	constructor(imm, [13, 14, 15], 1)
		17: Reg	constructor(imm, [13, 14, 15], 2)
		18: ValueRegs	constructor(value_regs, [16, 17], 3)
		21: Type	const_prim(I64)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [18, 22], 1)
		24: Reg	constructor(value_regs_get, [10, 22], 3)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [18, 26], 2)
		28: Reg	constructor(value_regs_get, [10, 26], 4)
		30: ValueRegs	constructor(with_flags, [40, 50], 7)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::AluRRR, [34, 53, 37, 23, 24])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [38, 39])
		44: ALUOp	make_variant(ALUOp::Sbc, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::AluRRR, [44, 56, 47, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
		52: Option(Type)	extractor(fits_in_64, 21)
		53: OperandSize	make_variant(OperandSize::Size64, [])
		55: Option(Type)	extractor(fits_in_64, 21)
		56: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		52:	some
		55:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [30], 4)
		13: Type	const_prim(I64)
		14: ImmExtend	make_variant(ImmExtend::Zero, [])
		15: u64	const_int(0, u64)
		16: Reg	constructor(imm, [13, 14, 15], 1)
		17: Reg	constructor(imm, [13, 14, 15], 2)
		18: ValueRegs	constructor(value_regs, [16, 17], 3)
		21: Type	const_prim(I64)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [18, 22], 1)
		24: Reg	constructor(value_regs_get, [10, 22], 3)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [18, 26], 2)
		28: Reg	constructor(value_regs_get, [10, 26], 4)
		30: ValueRegs	constructor(with_flags, [40, 50], 7)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::AluRRR, [34, 53, 37, 23, 24])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [38, 39])
		44: ALUOp	make_variant(ALUOp::Sbc, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::AluRRR, [44, 56, 47, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
		52: Option(Type)	extractor(fits_in_64, 21)
		53: OperandSize	make_variant(OperandSize::Size64, [])
		55: Option(Type)	extractor(fits_in_32, 21)
		56: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		52:	some
		55:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [30], 4)
		13: Type	const_prim(I64)
		14: ImmExtend	make_variant(ImmExtend::Zero, [])
		15: u64	const_int(0, u64)
		16: Reg	constructor(imm, [13, 14, 15], 1)
		17: Reg	constructor(imm, [13, 14, 15], 2)
		18: ValueRegs	constructor(value_regs, [16, 17], 3)
		21: Type	const_prim(I64)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [18, 22], 1)
		24: Reg	constructor(value_regs_get, [10, 22], 3)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [18, 26], 2)
		28: Reg	constructor(value_regs_get, [10, 26], 4)
		30: ValueRegs	constructor(with_flags, [40, 50], 7)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::AluRRR, [34, 53, 37, 23, 24])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [38, 39])
		44: ALUOp	make_variant(ALUOp::Sbc, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::AluRRR, [44, 56, 47, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
		52: Option(Type)	extractor(fits_in_32, 21)
		53: OperandSize	make_variant(OperandSize::Size32, [])
		55: Option(Type)	extractor(fits_in_64, 21)
		56: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		52:	some
		55:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [30], 4)
		13: Type	const_prim(I64)
		14: ImmExtend	make_variant(ImmExtend::Zero, [])
		15: u64	const_int(0, u64)
		16: Reg	constructor(imm, [13, 14, 15], 1)
		17: Reg	constructor(imm, [13, 14, 15], 2)
		18: ValueRegs	constructor(value_regs, [16, 17], 3)
		21: Type	const_prim(I64)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [18, 22], 1)
		24: Reg	constructor(value_regs_get, [10, 22], 3)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [18, 26], 2)
		28: Reg	constructor(value_regs_get, [10, 26], 4)
		30: ValueRegs	constructor(with_flags, [40, 50], 7)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::AluRRR, [34, 53, 37, 23, 24])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [38, 39])
		44: ALUOp	make_variant(ALUOp::Sbc, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::AluRRR, [44, 56, 47, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
		52: Option(Type)	extractor(fits_in_32, 21)
		53: OperandSize	make_variant(OperandSize::Size32, [])
		55: Option(Type)	extractor(fits_in_32, 21)
		56: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		52:	some
		55:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 747
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Type	match_some(6)
		10: Reg	constructor(zero_reg, [], 1)
		11: Value	match_some(8)
		12: Reg	constructor(put_in_reg, [11], 2)
		18: ALUOp	make_variant(ALUOp::Sub, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 741
		../../codegen/src/isa/aarch64/inst.isle line 2516
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::Sqsub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 736
		../../codegen/src/isa/aarch64/inst.isle line 2512
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::Uqsub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 731
		../../codegen/src/isa/aarch64/inst.isle line 2508
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::Sqadd, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 726
		../../codegen/src/isa/aarch64/inst.isle line 2504
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		21: VecALUOp	make_variant(VecALUOp::Uqadd, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [26], 4)
		17: Type	const_prim(I64)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 1)
		20: Reg	constructor(value_regs_get, [12, 18], 3)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Reg	constructor(value_regs_get, [12, 22], 4)
		26: ValueRegs	constructor(with_flags, [36, 46], 7)
		30: ALUOp	make_variant(ALUOp::SubS, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::AluRRR, [30, 49, 33, 19, 20])
		35: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [34, 35])
		40: ALUOp	make_variant(ALUOp::Sbc, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::AluRRR, [40, 52, 43, 23, 24])
		45: Reg	constructor(writable_reg_to_reg, [43], 0)
		46: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [44, 45])
		48: Option(Type)	extractor(fits_in_64, 17)
		49: OperandSize	make_variant(OperandSize::Size64, [])
		51: Option(Type)	extractor(fits_in_64, 17)
		52: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		48:	some
		51:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [26], 4)
		17: Type	const_prim(I64)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 1)
		20: Reg	constructor(value_regs_get, [12, 18], 3)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Reg	constructor(value_regs_get, [12, 22], 4)
		26: ValueRegs	constructor(with_flags, [36, 46], 7)
		30: ALUOp	make_variant(ALUOp::SubS, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::AluRRR, [30, 49, 33, 19, 20])
		35: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [34, 35])
		40: ALUOp	make_variant(ALUOp::Sbc, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::AluRRR, [40, 52, 43, 23, 24])
		45: Reg	constructor(writable_reg_to_reg, [43], 0)
		46: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [44, 45])
		48: Option(Type)	extractor(fits_in_64, 17)
		49: OperandSize	make_variant(OperandSize::Size64, [])
		51: Option(Type)	extractor(fits_in_32, 17)
		52: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		48:	some
		51:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [26], 4)
		17: Type	const_prim(I64)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 1)
		20: Reg	constructor(value_regs_get, [12, 18], 3)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Reg	constructor(value_regs_get, [12, 22], 4)
		26: ValueRegs	constructor(with_flags, [36, 46], 7)
		30: ALUOp	make_variant(ALUOp::SubS, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::AluRRR, [30, 49, 33, 19, 20])
		35: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [34, 35])
		40: ALUOp	make_variant(ALUOp::Sbc, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::AluRRR, [40, 52, 43, 23, 24])
		45: Reg	constructor(writable_reg_to_reg, [43], 0)
		46: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [44, 45])
		48: Option(Type)	extractor(fits_in_32, 17)
		49: OperandSize	make_variant(OperandSize::Size32, [])
		51: Option(Type)	extractor(fits_in_64, 17)
		52: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		48:	some
		51:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [26], 4)
		17: Type	const_prim(I64)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 1)
		20: Reg	constructor(value_regs_get, [12, 18], 3)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [10, 22], 2)
		24: Reg	constructor(value_regs_get, [12, 22], 4)
		26: ValueRegs	constructor(with_flags, [36, 46], 7)
		30: ALUOp	make_variant(ALUOp::SubS, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::AluRRR, [30, 49, 33, 19, 20])
		35: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [34, 35])
		40: ALUOp	make_variant(ALUOp::Sbc, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::AluRRR, [40, 52, 43, 23, 24])
		45: Reg	constructor(writable_reg_to_reg, [43], 0)
		46: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [44, 45])
		48: Option(Type)	extractor(fits_in_32, 17)
		49: OperandSize	make_variant(OperandSize::Size32, [])
		51: Option(Type)	extractor(fits_in_32, 17)
		52: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		48:	some
		51:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 717
		../../codegen/src/isa/aarch64/inst.isle line 2464
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		20: VecALUOp	make_variant(VecALUOp::Sub, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 711
		../../codegen/src/isa/aarch64/inst.isle line 2461
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 706
		../../codegen/src/isa/aarch64/inst.isle line 2458
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2035
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: ExtendedValue	match_some(11)
		21: ALUOp	make_variant(ALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [40], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Reg	constructor(put_extended_in_reg, [15], 1)
		31: ExtendOp	constructor(get_extended_op, [15], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 700
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	constructor(imm12_from_negated_value, [10], 0)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 695
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		21: ALUOp	make_variant(ALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 691
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		20: ALUOp	make_variant(ALUOp::Sub, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 683
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 677
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 674
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 671
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 668
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 663
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 660
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 657
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		17: ValueRegs	constructor(value_reg, [14], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 654
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 651
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 648
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 643
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::I64ToF64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 640
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::I64ToF32, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		16:	const_prim(I64)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		16:	const_prim(I32)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		16: Type	extractor(value_type, 8)
		17: Option(Type)	extractor(fits_in_32, 16)
		18: Reg	constructor(put_in_reg, [8], 1)
		19: bool	const_prim(true)
		20: Type	match_some(17)
		21: u8	constructor(ty_bits, [20], 0)
		22: u8	const_int(32, u8)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		16:	const_prim(I64)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		16:	const_prim(I32)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		16: Type	extractor(value_type, 8)
		17: Option(Type)	extractor(fits_in_32, 16)
		18: Reg	constructor(put_in_reg, [8], 1)
		19: bool	const_prim(true)
		20: Type	match_some(17)
		21: u8	constructor(ty_bits, [20], 0)
		22: u8	const_int(32, u8)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 631
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 628
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 623
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::U64ToF64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 620
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::U64ToF32, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		16:	const_prim(I64)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		16:	const_prim(I32)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		16: Type	extractor(value_type, 8)
		17: Option(Type)	extractor(fits_in_32, 16)
		18: Reg	constructor(put_in_reg, [8], 1)
		19: bool	const_prim(false)
		20: Type	match_some(17)
		21: u8	constructor(ty_bits, [20], 0)
		22: u8	const_int(32, u8)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		16:	const_prim(I64)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		16: Type	extractor(value_type, 8)
		17: Reg	constructor(put_in_reg, [8], 1)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		16:	const_prim(I32)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		16: Type	extractor(value_type, 8)
		17: Option(Type)	extractor(fits_in_32, 16)
		18: Reg	constructor(put_in_reg, [8], 1)
		19: bool	const_prim(false)
		20: Type	match_some(17)
		21: u8	constructor(ty_bits, [20], 0)
		22: u8	const_int(32, u8)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 611
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 608
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 603
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		22: ScalarSize	constructor(scalar_size, [13], 1)
		24: u8	constructor(ty_bits, [13], 0)
		25: u8	constructor(ty_bits, [14], 0)
		26: Reg	constructor(min_fp_value, [12, 24, 25], 3)
		27: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 44, 26], 4)
		28: Reg	constructor(max_fp_value, [12, 24, 25], 5)
		32: ValueRegs	constructor(value_reg, [61], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Cond	make_variant(Cond::Vs, [])
		38: CondBrKind	constructor(cond_br_cond, [37], 2)
		39: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		40: MInst	make_variant(MInst::TrapIf, [38, 39])
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [40, 11])
		42: ValueRegs	constructor(with_flags, [66, 41], 3)
		43: usize	const_int(0, usize)
		44: Reg	constructor(value_regs_get, [42, 43], 4)
		49: Cond	make_variant(Cond::Ge, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 2)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [52, 27])
		54: ValueRegs	constructor(with_flags, [71, 53], 3)
		55: usize	const_int(0, usize)
		56: Reg	constructor(value_regs_get, [54, 55], 4)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		65: MInst	make_variant(MInst::FpuCmp, [22, 11, 11])
		66: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [65])
		70: MInst	make_variant(MInst::FpuCmp, [22, 27, 28])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 600
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		23: ScalarSize	constructor(scalar_size, [14], 1)
		25: u8	constructor(ty_bits, [14], 0)
		26: u8	constructor(ty_bits, [15], 0)
		27: Reg	constructor(min_fp_value, [13, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [13, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 12])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 12, 12])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 597
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		22: ScalarSize	constructor(scalar_size, [13], 1)
		24: u8	constructor(ty_bits, [13], 0)
		25: u8	constructor(ty_bits, [14], 0)
		26: Reg	constructor(min_fp_value, [12, 24, 25], 3)
		27: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 44, 26], 4)
		28: Reg	constructor(max_fp_value, [12, 24, 25], 5)
		32: ValueRegs	constructor(value_reg, [61], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Cond	make_variant(Cond::Vs, [])
		38: CondBrKind	constructor(cond_br_cond, [37], 2)
		39: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		40: MInst	make_variant(MInst::TrapIf, [38, 39])
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [40, 11])
		42: ValueRegs	constructor(with_flags, [66, 41], 3)
		43: usize	const_int(0, usize)
		44: Reg	constructor(value_regs_get, [42, 43], 4)
		49: Cond	make_variant(Cond::Ge, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 2)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [52, 27])
		54: ValueRegs	constructor(with_flags, [71, 53], 3)
		55: usize	const_int(0, usize)
		56: Reg	constructor(value_regs_get, [54, 55], 4)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		65: MInst	make_variant(MInst::FpuCmp, [22, 11, 11])
		66: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [65])
		70: MInst	make_variant(MInst::FpuCmp, [22, 27, 28])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 594
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		23: ScalarSize	constructor(scalar_size, [14], 1)
		25: u8	constructor(ty_bits, [14], 0)
		26: u8	constructor(ty_bits, [15], 0)
		27: Reg	constructor(min_fp_value, [13, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [13, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 12])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 12, 12])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 589
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		22: ScalarSize	constructor(scalar_size, [13], 1)
		24: u8	constructor(ty_bits, [13], 0)
		25: u8	constructor(ty_bits, [14], 0)
		26: Reg	constructor(min_fp_value, [12, 24, 25], 3)
		27: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 44, 26], 4)
		28: Reg	constructor(max_fp_value, [12, 24, 25], 5)
		32: ValueRegs	constructor(value_reg, [61], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Cond	make_variant(Cond::Vs, [])
		38: CondBrKind	constructor(cond_br_cond, [37], 2)
		39: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		40: MInst	make_variant(MInst::TrapIf, [38, 39])
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [40, 11])
		42: ValueRegs	constructor(with_flags, [66, 41], 3)
		43: usize	const_int(0, usize)
		44: Reg	constructor(value_regs_get, [42, 43], 4)
		49: Cond	make_variant(Cond::Ge, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 2)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [52, 27])
		54: ValueRegs	constructor(with_flags, [71, 53], 3)
		55: usize	const_int(0, usize)
		56: Reg	constructor(value_regs_get, [54, 55], 4)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		65: MInst	make_variant(MInst::FpuCmp, [22, 11, 11])
		66: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [65])
		70: MInst	make_variant(MInst::FpuCmp, [22, 27, 28])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 586
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		23: ScalarSize	constructor(scalar_size, [14], 1)
		25: u8	constructor(ty_bits, [14], 0)
		26: u8	constructor(ty_bits, [15], 0)
		27: Reg	constructor(min_fp_value, [13, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [13, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 12])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 12, 12])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 583
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		22: ScalarSize	constructor(scalar_size, [13], 1)
		24: u8	constructor(ty_bits, [13], 0)
		25: u8	constructor(ty_bits, [14], 0)
		26: Reg	constructor(min_fp_value, [12, 24, 25], 3)
		27: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 44, 26], 4)
		28: Reg	constructor(max_fp_value, [12, 24, 25], 5)
		32: ValueRegs	constructor(value_reg, [61], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Cond	make_variant(Cond::Vs, [])
		38: CondBrKind	constructor(cond_br_cond, [37], 2)
		39: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		40: MInst	make_variant(MInst::TrapIf, [38, 39])
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [40, 11])
		42: ValueRegs	constructor(with_flags, [66, 41], 3)
		43: usize	const_int(0, usize)
		44: Reg	constructor(value_regs_get, [42, 43], 4)
		49: Cond	make_variant(Cond::Ge, [])
		50: CondBrKind	constructor(cond_br_cond, [49], 2)
		51: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		52: MInst	make_variant(MInst::TrapIf, [50, 51])
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [52, 27])
		54: ValueRegs	constructor(with_flags, [71, 53], 3)
		55: usize	const_int(0, usize)
		56: Reg	constructor(value_regs_get, [54, 55], 4)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		65: MInst	make_variant(MInst::FpuCmp, [22, 11, 11])
		66: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [65])
		70: MInst	make_variant(MInst::FpuCmp, [22, 27, 28])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 580
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		23: ScalarSize	constructor(scalar_size, [14], 1)
		25: u8	constructor(ty_bits, [14], 0)
		26: u8	constructor(ty_bits, [15], 0)
		27: Reg	constructor(min_fp_value, [13, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [13, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 12])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 12, 12])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3559
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		18: Option((u32, u32))	extractor(multi_lane, 12)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		18:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3554
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		18: Option(Type)	extractor(ty_scalar_float, 12)
		19: Type	const_prim(F64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		18:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 520
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: VecALUModOp	make_variant(VecALUModOp::Fmla, [])
		10: (Value, Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: Value	match_tuple(10, 2)
		14: VectorSize	constructor(vector_size, [5], 1)
		15: Reg	constructor(lower_fmla, [9, 11, 12, 13, 14], 2)
		18: ValueRegs	constructor(value_reg, [15], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 516
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: FPUOp3	make_variant(FPUOp3::MAdd, [])
		10: Type	match_some(6)
		11: ScalarSize	constructor(scalar_size, [10], 1)
		12: (Value, Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Value	match_tuple(12, 2)
		18: Reg	constructor(put_in_reg, [17], 4)
		26: Type	const_prim(F64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 511
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Nearest64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 508
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Nearest32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 505
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(nearest, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintn, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 500
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Zero64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 497
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Zero32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 494
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(trunc, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintz, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 489
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Minus64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 486
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Minus32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 483
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(floor, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintm, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 478
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Plus64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 475
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Plus32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: Type	const_prim(F64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 472
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ceil, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintp, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 467
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fdemote, 6)
		8: FPUOp1	make_variant(FPUOp1::Cvt64To32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 462
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fpromote, 6)
		8: FPUOp1	make_variant(FPUOp1::Cvt32To64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 457
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: FPUOp1	make_variant(FPUOp1::Abs, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		19: Type	const_prim(F64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 454
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: VecMisc2	make_variant(VecMisc2::Fabs, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 449
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: FPUOp1	make_variant(FPUOp1::Neg, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		19: Type	const_prim(F64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 446
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: VecMisc2	make_variant(VecMisc2::Fneg, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 441
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: FPUOp1	make_variant(FPUOp1::Sqrt, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		19: Type	const_prim(F64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 438
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: VecMisc2	make_variant(VecMisc2::Fsqrt, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 433
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: FPUOp2	make_variant(FPUOp2::Max, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 430
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmax, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 425
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: FPUOp2	make_variant(FPUOp2::Min, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 422
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmin, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 417
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: FPUOp2	make_variant(FPUOp2::Div, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 414
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 409
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: FPUOp2	make_variant(FPUOp2::Mul, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 406
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmul, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 401
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: FPUOp2	make_variant(FPUOp2::Sub, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 398
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: VecALUOp	make_variant(VecALUOp::Fsub, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 393
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Add, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		23: Type	const_prim(F64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 390
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fadd, 7)
		9: VecALUOp	make_variant(VecALUOp::Fadd, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 385
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sqmul_round_sat, 7)
		9: VecALUOp	make_variant(VecALUOp::Sqrdmulh, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(avg_round, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(lane_fits_in_32, 7)
		9: VecALUOp	make_variant(VecALUOp::Urhadd, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 371
		../../codegen/src/isa/aarch64/inst.isle line 2715
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2757
		../../codegen/src/isa/aarch64/inst.isle line 2757
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(avg_round, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 3)
		13: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: u64	const_int(1, u64)
		16: Reg	constructor(splat_const, [15, 13], 1)
		18: Reg	constructor(put_in_reg, [9], 6)
		19: u8	const_int(1, u8)
		21: Reg	constructor(put_in_reg, [11], 8)
		29: VecALUOp	make_variant(VecALUOp::Orr, [])
		34: VecALUOp	make_variant(VecALUOp::And, [])
		39: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		44: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		49: VecALUOp	make_variant(VecALUOp::Add, [])
		54: VecALUOp	make_variant(VecALUOp::Add, [])
		57: ValueRegs	constructor(value_reg, [100], 1)
		58: InstOutput	constructor(output, [57], 2)
		63: Type	const_prim(I8X16)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I8X16)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		77: Type	const_prim(I8X16)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
		84: Type	const_prim(I8X16)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: Reg	constructor(writable_reg_to_reg, [85], 0)
		91: Type	const_prim(I8X16)
		92: WritableReg	constructor(temp_writable_reg, [91], 1)
		93: Reg	constructor(writable_reg_to_reg, [92], 0)
		98: Type	const_prim(I8X16)
		99: WritableReg	constructor(temp_writable_reg, [98], 1)
		100: Reg	constructor(writable_reg_to_reg, [99], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 58
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [43, 58], 10)
		23: InstOutput	constructor(output, [22], 11)
		27: ALUOp	make_variant(ALUOp::Asr, [])
		32: ALUOp	make_variant(ALUOp::Eor, [])
		37: ALUOp	make_variant(ALUOp::SubS, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 75, 40, 72, 65])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		47: ALUOp	make_variant(ALUOp::Eor, [])
		52: ALUOp	make_variant(ALUOp::Sbc, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::AluRRR, [52, 85, 55, 82, 65])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [56, 57])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		74: Option(Type)	extractor(fits_in_64, 8)
		75: OperandSize	make_variant(OperandSize::Size64, [])
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
		84: Option(Type)	extractor(fits_in_64, 8)
		85: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		74:	some
		84:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [43, 58], 10)
		23: InstOutput	constructor(output, [22], 11)
		27: ALUOp	make_variant(ALUOp::Asr, [])
		32: ALUOp	make_variant(ALUOp::Eor, [])
		37: ALUOp	make_variant(ALUOp::SubS, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 75, 40, 72, 65])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		47: ALUOp	make_variant(ALUOp::Eor, [])
		52: ALUOp	make_variant(ALUOp::Sbc, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::AluRRR, [52, 85, 55, 82, 65])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [56, 57])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		74: Option(Type)	extractor(fits_in_64, 8)
		75: OperandSize	make_variant(OperandSize::Size64, [])
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
		84: Option(Type)	extractor(fits_in_32, 8)
		85: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		74:	some
		84:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [43, 58], 10)
		23: InstOutput	constructor(output, [22], 11)
		27: ALUOp	make_variant(ALUOp::Asr, [])
		32: ALUOp	make_variant(ALUOp::Eor, [])
		37: ALUOp	make_variant(ALUOp::SubS, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 75, 40, 72, 65])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		47: ALUOp	make_variant(ALUOp::Eor, [])
		52: ALUOp	make_variant(ALUOp::Sbc, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::AluRRR, [52, 85, 55, 82, 65])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [56, 57])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		74: Option(Type)	extractor(fits_in_32, 8)
		75: OperandSize	make_variant(OperandSize::Size32, [])
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
		84: Option(Type)	extractor(fits_in_64, 8)
		85: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		74:	some
		84:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [43, 58], 10)
		23: InstOutput	constructor(output, [22], 11)
		27: ALUOp	make_variant(ALUOp::Asr, [])
		32: ALUOp	make_variant(ALUOp::Eor, [])
		37: ALUOp	make_variant(ALUOp::SubS, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 75, 40, 72, 65])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		47: ALUOp	make_variant(ALUOp::Eor, [])
		52: ALUOp	make_variant(ALUOp::Sbc, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::AluRRR, [52, 85, 55, 82, 65])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [56, 57])
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		74: Option(Type)	extractor(fits_in_32, 8)
		75: OperandSize	make_variant(OperandSize::Size32, [])
		80: Type	const_prim(I64)
		81: WritableReg	constructor(temp_writable_reg, [80], 1)
		82: Reg	constructor(writable_reg_to_reg, [81], 0)
		84: Option(Type)	extractor(fits_in_32, 8)
		85: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		74:	some
		84:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_some(6)
		15: Type	extractor(value_type, 10)
		16: Reg	constructor(put_in_reg, [10], 1)
		19: u8	const_int(0, u8)
		20: Imm12	constructor(u8_into_imm12, [19], 1)
		22: Cond	make_variant(Cond::Gt, [])
		24: ValueRegs	constructor(with_flags, [36, 44], 4)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 5)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: ALUOp	make_variant(ALUOp::SubS, [])
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: MInst	make_variant(MInst::AluRRImm12, [33, 9, 34, 16, 20])
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [35])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::CSNeg, [41, 22, 16, 16])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 43])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		15:	const_prim(I64)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_some(6)
		15: Type	extractor(value_type, 10)
		16: Reg	constructor(put_in_reg, [10], 1)
		19: u8	const_int(0, u8)
		20: Imm12	constructor(u8_into_imm12, [19], 1)
		22: Cond	make_variant(Cond::Gt, [])
		24: ValueRegs	constructor(with_flags, [36, 44], 4)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 5)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: ALUOp	make_variant(ALUOp::SubS, [])
		34: WritableReg	constructor(writable_zero_reg, [], 1)
		35: MInst	make_variant(MInst::AluRRImm12, [33, 9, 34, 16, 20])
		36: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [35])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::CSNeg, [41, 22, 16, 16])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 43])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		15:	const_prim(I32)
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_some(6)
		15: Type	extractor(value_type, 10)
		16: Option(Type)	extractor(fits_in_32, 15)
		17: Reg	constructor(put_in_reg, [10], 1)
		18: bool	const_prim(true)
		19: Type	match_some(16)
		20: u8	constructor(ty_bits, [19], 0)
		21: u8	const_int(32, u8)
		25: u8	const_int(0, u8)
		26: Imm12	constructor(u8_into_imm12, [25], 1)
		28: Cond	make_variant(Cond::Gt, [])
		30: ValueRegs	constructor(with_flags, [49, 57], 4)
		31: usize	const_int(0, usize)
		32: Reg	constructor(value_regs_get, [30, 31], 5)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
		46: ALUOp	make_variant(ALUOp::SubS, [])
		47: WritableReg	constructor(writable_zero_reg, [], 1)
		48: MInst	make_variant(MInst::AluRRImm12, [46, 9, 47, 42, 26])
		49: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [48])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSNeg, [54, 28, 42, 42])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		16:	some
	]
	result = 35
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 345
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: OperandSize	make_variant(OperandSize::Size64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		15: u8	const_int(0, u8)
		16: Imm12	constructor(u8_into_imm12, [15], 1)
		18: Cond	make_variant(Cond::Gt, [])
		20: ValueRegs	constructor(with_flags, [32, 40], 4)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 5)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: ALUOp	make_variant(ALUOp::SubS, [])
		30: WritableReg	constructor(writable_zero_reg, [], 1)
		31: MInst	make_variant(MInst::AluRRImm12, [29, 8, 30, 10, 16])
		32: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [31])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::CSNeg, [37, 18, 10, 10])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [38, 39])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 342
		../../codegen/src/isa/aarch64/inst.isle line 2603
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(iabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		16: VecMisc2	make_variant(VecMisc2::Abs, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 337
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd_pairwise, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		13: VectorSize	constructor(vector_size, [12], 3)
		19: VecALUOp	make_variant(VecALUOp::Addp, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 334
		../../codegen/src/isa/aarch64/inst.isle line 2632
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		23: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp16, [])
		26: ValueRegs	constructor(value_reg, [32], 1)
		27: InstOutput	constructor(output, [26], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 2629
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		23: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp8, [])
		26: ValueRegs	constructor(value_reg, [32], 1)
		27: InstOutput	constructor(output, [26], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 326
		../../codegen/src/isa/aarch64/inst.isle line 2626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		23: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp16, [])
		26: ValueRegs	constructor(value_reg, [32], 1)
		27: InstOutput	constructor(output, [26], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 322
		../../codegen/src/isa/aarch64/inst.isle line 2623
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		23: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp8, [])
		26: ValueRegs	constructor(value_reg, [32], 1)
		27: InstOutput	constructor(output, [26], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 3806
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2124
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [39, 26], 4)
		11: InstOutput	constructor(output, [10], 5)
		14: Option(Type)	constructor(ty_vec64, [6], 0)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: u8	const_int(0, u8)
		17: ScalarSize	make_variant(ScalarSize::Size64, [])
		19: Imm12	constructor(u8_into_imm12, [16], 2)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::CSet, [23, 8])
		25: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [24, 25])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ALUOp	make_variant(ALUOp::SubS, [])
		37: WritableReg	constructor(writable_zero_reg, [], 1)
		38: MInst	make_variant(MInst::AluRRImm12, [36, 15, 37, 32, 19])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
	]
	constraints = [
		3:	some
		14:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 3802
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2124
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [49, 29], 4)
		11: InstOutput	constructor(output, [10], 5)
		14: Option(Type)	extractor(ty_vec128, 6)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: VecALUOp	make_variant(VecALUOp::Umaxp, [])
		17: VectorSize	make_variant(VectorSize::Size32x4, [])
		19: u8	const_int(0, u8)
		20: ScalarSize	make_variant(ScalarSize::Size64, [])
		22: Imm12	constructor(u8_into_imm12, [19], 3)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::CSet, [26, 8])
		28: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [27, 28])
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
		46: ALUOp	make_variant(ALUOp::SubS, [])
		47: WritableReg	constructor(writable_zero_reg, [], 1)
		48: MInst	make_variant(MInst::AluRRImm12, [46, 15, 47, 42, 22])
		49: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [48])
	]
	constraints = [
		3:	some
		14:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 306
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Type	match_some(6)
		8: Option(Type)	constructor(not_vec32x2, [7], 0)
		9: OperandSize	make_variant(OperandSize::Size64, [])
		10: VecLanesOp	make_variant(VecLanesOp::Uminv, [])
		11: Reg	constructor(put_in_reg, [4], 1)
		12: VectorSize	constructor(vector_size, [7], 2)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Imm12	constructor(u8_into_imm12, [14], 5)
		19: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(with_flags, [41, 47], 8)
		22: InstOutput	constructor(output, [21], 9)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: ALUOp	make_variant(ALUOp::SubS, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: MInst	make_variant(MInst::AluRRImm12, [38, 9, 39, 34, 17])
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [40])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::CSet, [44, 19])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [45, 46])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 289
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2018
		../../codegen/src/isa/aarch64/inst.isle line 2422
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Reg	constructor(zero_reg, [], 3)
		12: Reg	constructor(put_in_reg, [4], 1)
		13: u8	const_int(0, u8)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: u64	const_int(32, u64)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: UImm5	constructor(u8_into_uimm5, [13], 5)
		20: bool	const_prim(false)
		21: bool	const_prim(true)
		22: NZCV	constructor(nzcv, [20, 21, 20, 20], 6)
		23: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(with_flags, [43, 55], 8)
		26: InstOutput	constructor(output, [25], 9)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		37: Type	const_prim(I64)
		38: Option(ShiftOpAndAmt)	constructor(lshr_from_u64, [37, 16], 0)
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: ShiftOpAndAmt	match_some(38)
		42: MInst	make_variant(MInst::AluRRRShift, [39, 10, 40, 11, 32, 41])
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [42])
		49: MInst	make_variant(MInst::CCmpImm, [18, 32, 19, 22, 23])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::CSet, [51, 23])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ValueRegs	constructor(value_reg, [53], 2)
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [49, 52, 54])
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		9:	const_int(2)
		38:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 283
		../../codegen/src/isa/aarch64/inst.isle line 3415
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: Reg	constructor(put_in_reg, [4], 1)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Cond	make_variant(Cond::Eq, [])
		18: ValueRegs	constructor(with_flags, [33, 39], 6)
		19: InstOutput	constructor(output, [18], 7)
		22: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		27: VecALUOp	make_variant(VecALUOp::Addp, [])
		32: MInst	make_variant(MInst::FpuCmp, [10, 52, 52])
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [32])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::CSet, [36, 16])
		38: Reg	constructor(writable_reg_to_reg, [36], 0)
		39: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [37, 38])
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
		50: Type	const_prim(I8X16)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		9:	const_int(2)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: Type	extractor(value_type, 4)
		13: Reg	constructor(put_in_reg, [4], 1)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		12:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: Type	extractor(value_type, 4)
		13: Reg	constructor(put_in_reg, [4], 1)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		12:	const_prim(I32)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: Type	extractor(value_type, 4)
		13: Option(Type)	extractor(fits_in_32, 12)
		14: Reg	constructor(put_in_reg, [4], 1)
		15: bool	const_prim(false)
		16: Type	match_some(13)
		17: u8	constructor(ty_bits, [16], 0)
		18: u8	const_int(32, u8)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		13:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 266
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: Type	const_prim(I8X16)
		13: WritableReg	constructor(temp_writable_reg, [12], 1)
		14: Reg	constructor(writable_reg_to_reg, [13], 0)
		16: ValueRegs	constructor(value_reg, [14], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 263
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		15: Type	const_prim(F32X4)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64X2)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 260
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		15: Type	const_prim(F32X4)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32X4)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 255
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iconcat, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: ValueRegs	constructor(value_regs, [10, 12], 3)
		14: InstOutput	constructor(output, [13], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 246
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(isplit, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: ValueRegs	constructor(put_in_regs, [4], 1)
		7: usize	const_int(0, usize)
		8: Reg	constructor(value_regs_get, [6, 7], 2)
		9: ValueRegs	constructor(value_reg, [8], 3)
		10: usize	const_int(1, usize)
		11: Reg	constructor(value_regs_get, [6, 10], 4)
		12: ValueRegs	constructor(value_reg, [11], 5)
		13: InstOutput	constructor(output_pair, [9, 12], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 241
		../../codegen/src/isa/aarch64/inst.isle line 2156
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(swizzle, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 235
		../../codegen/src/isa/aarch64/inst.isle line 2169
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Immediate))	extractor(shuffle, 5)
		7: (Value, Value, Immediate)	match_some(6)
		8: Immediate	match_tuple(7, 2)
		9: Option(u128)	extractor(u128_from_immediate, 8)
		10: Value	match_tuple(7, 0)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Value	match_tuple(7, 1)
		13: Reg	constructor(put_in_reg, [12], 3)
		14: u128	match_some(9)
		15: Reg	constructor(constant_f128, [14], 1)
		16: Type	match_tuple(4, 0)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 232
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: VecMisc2	make_variant(VecMisc2::Rev64, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(14673614102390417578512422760905835780)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 230
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: VecMisc2	make_variant(VecMisc2::Rev64, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(12004814239757670119517129289737963270)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 228
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: VecMisc2	make_variant(VecMisc2::Rev64, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(10680758337341567148842519922299176455)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 226
		../../codegen/src/isa/aarch64/inst.isle line 2540
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: VecMisc2	make_variant(VecMisc2::Rev32, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(17342576855639742879858139805557719810)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 224
		../../codegen/src/isa/aarch64/inst.isle line 2540
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: VecMisc2	make_variant(VecMisc2::Rev32, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(16018520953223639909183530438118932995)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 222
		../../codegen/src/isa/aarch64/inst.isle line 2536
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: VecMisc2	make_variant(VecMisc2::Rev16, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(18687320815856387368178823909286805505)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 212
		../../codegen/src/isa/aarch64/inst.isle line 4192
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		18: VecALUOp	make_variant(VecALUOp::Trn2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909301208165426529540)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 210
		../../codegen/src/isa/aarch64/inst.isle line 4188
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		18: VecALUOp	make_variant(VecALUOp::Trn1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664569647092737326704519438008576)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 208
		../../codegen/src/isa/aarch64/inst.isle line 4192
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: VecALUOp	make_variant(VecALUOp::Trn2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142128814346332279593629287318274)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 206
		../../codegen/src/isa/aarch64/inst.isle line 4188
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: VecALUOp	make_variant(VecALUOp::Trn1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693260819630515246292341806293057792)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 204
		../../codegen/src/isa/aarch64/inst.isle line 4192
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		18: VecALUOp	make_variant(VecALUOp::Trn2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284541550424544734358823780242100481)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 202
		../../codegen/src/isa/aarch64/inst.isle line 4188
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		18: VecALUOp	make_variant(VecALUOp::Trn1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(39950100895832629191365197868744970240)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 194
		../../codegen/src/isa/aarch64/inst.isle line 4184
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		18: VecALUOp	make_variant(VecALUOp::Zip2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909590568856778836232)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 192
		../../codegen/src/isa/aarch64/inst.isle line 4180
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		18: VecALUOp	make_variant(VecALUOp::Zip1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901951279430565641561564801794304)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 190
		../../codegen/src/isa/aarch64/inst.isle line 4184
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: VecALUOp	make_variant(VecALUOp::Zip2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142129435743685477327603181816072)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 188
		../../codegen/src/isa/aarch64/inst.isle line 4180
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: VecALUOp	make_variant(VecALUOp::Zip1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686616892700419341528320311204774144)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 186
		../../codegen/src/isa/aarch64/inst.isle line 4184
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		18: VecALUOp	make_variant(VecALUOp::Zip2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284561912683712994304547342093195272)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 184
		../../codegen/src/isa/aarch64/inst.isle line 4180
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		18: VecALUOp	make_variant(VecALUOp::Zip1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30609036675948388650355540050116153344)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 179
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427191743139026172726477975062792)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 177
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901955007814682223719185998020864)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 175
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427190500344320355979912890680580)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 173
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664572132682148381476266902159616)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 171
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362386467224802506860000736977486594)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 169
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693505158040971420872748913983226112)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 167
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41357194091136896220700492464948314881)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 165
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		18: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		21: ValueRegs	constructor(value_reg, [29], 1)
		22: InstOutput	constructor(output, [21], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(40022753436544980677706866553451184640)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 152
		../../codegen/src/isa/aarch64/inst.isle line 2340
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(vec_extract_imm4_from_immediate, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Value	match_tuple(4, 1)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: u8	match_some(6)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 133
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup64_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size64x2, [])
		10: u8	match_some(6)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 131
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup32_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u8	match_some(6)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 129
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup16_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u8	match_some(6)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 127
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup8_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u8	match_some(6)
		16: Type	const_prim(I8X16)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [33, 43], 9)
		23: InstOutput	constructor(output, [22], 10)
		27: ALUOp	make_variant(ALUOp::AddS, [])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::AluRRR, [27, 46, 30, 13, 16])
		32: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [31, 32])
		37: ALUOp	make_variant(ALUOp::Adc, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 49, 40, 19, 20])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [41, 42])
		45: Option(Type)	extractor(fits_in_64, 8)
		46: OperandSize	make_variant(OperandSize::Size64, [])
		48: Option(Type)	extractor(fits_in_64, 8)
		49: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		45:	some
		48:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [33, 43], 9)
		23: InstOutput	constructor(output, [22], 10)
		27: ALUOp	make_variant(ALUOp::AddS, [])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::AluRRR, [27, 46, 30, 13, 16])
		32: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [31, 32])
		37: ALUOp	make_variant(ALUOp::Adc, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 49, 40, 19, 20])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [41, 42])
		45: Option(Type)	extractor(fits_in_64, 8)
		46: OperandSize	make_variant(OperandSize::Size64, [])
		48: Option(Type)	extractor(fits_in_32, 8)
		49: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		45:	some
		48:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [33, 43], 9)
		23: InstOutput	constructor(output, [22], 10)
		27: ALUOp	make_variant(ALUOp::AddS, [])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::AluRRR, [27, 46, 30, 13, 16])
		32: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [31, 32])
		37: ALUOp	make_variant(ALUOp::Adc, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 49, 40, 19, 20])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [41, 42])
		45: Option(Type)	extractor(fits_in_32, 8)
		46: OperandSize	make_variant(OperandSize::Size32, [])
		48: Option(Type)	extractor(fits_in_64, 8)
		49: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		45:	some
		48:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [33, 43], 9)
		23: InstOutput	constructor(output, [22], 10)
		27: ALUOp	make_variant(ALUOp::AddS, [])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::AluRRR, [27, 46, 30, 13, 16])
		32: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [31, 32])
		37: ALUOp	make_variant(ALUOp::Adc, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [37, 49, 40, 19, 20])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [41, 42])
		45: Option(Type)	extractor(fits_in_32, 8)
		46: OperandSize	make_variant(OperandSize::Size32, [])
		48: Option(Type)	extractor(fits_in_32, 8)
		49: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		45:	some
		48:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 100
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		20: VecALUOp	make_variant(VecALUOp::Add, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 95
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: Type	match_some(6)
		15: (Value, Value)	match_some(13)
		16: Value	match_tuple(15, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_tuple(15, 1)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Value	match_tuple(9, 0)
		21: Reg	constructor(put_in_reg, [20], 3)
		28: ALUOp3	make_variant(ALUOp3::MSub, [])
		31: ValueRegs	constructor(value_reg, [40], 1)
		32: InstOutput	constructor(output, [31], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 91
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: Type	match_some(6)
		15: (Value, Value)	match_some(13)
		16: Value	match_tuple(15, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_tuple(15, 1)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Value	match_tuple(9, 1)
		21: Reg	constructor(put_in_reg, [20], 3)
		28: ALUOp3	make_variant(ALUOp3::MAdd, [])
		31: ValueRegs	constructor(value_reg, [40], 1)
		32: InstOutput	constructor(output, [31], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 88
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: Type	match_some(6)
		15: (Value, Value)	match_some(13)
		16: Value	match_tuple(15, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_tuple(15, 1)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Value	match_tuple(9, 0)
		21: Reg	constructor(put_in_reg, [20], 3)
		28: ALUOp3	make_variant(ALUOp3::MAdd, [])
		31: ValueRegs	constructor(value_reg, [40], 1)
		32: InstOutput	constructor(output, [31], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 82
		../../codegen/src/isa/aarch64/inst.isle line 2444
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 1)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		33: ALUOp	make_variant(ALUOp::Add, [])
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 77
		../../codegen/src/isa/aarch64/inst.isle line 2444
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		33: ALUOp	make_variant(ALUOp::Add, [])
		36: ValueRegs	constructor(value_reg, [45], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 37
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 72
		../../codegen/src/isa/aarch64/inst.isle line 2438
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2035
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: ExtendedValue	match_some(11)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [40], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Reg	constructor(put_extended_in_reg, [15], 1)
		31: ExtendOp	constructor(get_extended_op, [15], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 69
		../../codegen/src/isa/aarch64/inst.isle line 2438
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2035
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: ExtendedValue	match_some(11)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [40], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Reg	constructor(put_extended_in_reg, [15], 1)
		31: ExtendOp	constructor(get_extended_op, [15], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 63
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Imm12)	constructor(imm12_from_negated_value, [10], 0)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		21: ALUOp	make_variant(ALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 59
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	constructor(imm12_from_negated_value, [10], 0)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		21: ALUOp	make_variant(ALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 54
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 51
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		20: ALUOp	make_variant(ALUOp::Add, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 39
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(nop, 0)
		4: Reg	constructor(invalid_reg, [], 1)
		7: ValueRegs	constructor(value_reg, [4], 1)
		8: InstOutput	constructor(output, [7], 2)
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 34
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee64)	extractor(f64const, 0)
		4: Ieee64	match_some(3)
		5: u64	extractor(u64_from_ieee64, 4)
		6: Reg	constructor(constant_f64, [5], 1)
		9: ValueRegs	constructor(value_reg, [6], 1)
		10: InstOutput	constructor(output, [9], 2)
	]
	constraints = [
		3:	some
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3249
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2271
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		9: Type	const_prim(I32)
		10: ImmExtend	make_variant(ImmExtend::Zero, [])
		11: u64	constructor(u32_as_u64, [5], 0)
		12: Reg	constructor(imm, [9, 10, 11], 1)
		13: ScalarSize	make_variant(ScalarSize::Size32, [])
		16: ValueRegs	constructor(value_reg, [22], 1)
		17: InstOutput	constructor(output, [16], 2)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3246
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2278
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		9: u64	constructor(u32_as_u64, [5], 0)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(ASIMDFPModImm)	constructor(asimd_fp_mod_imm_from_u64, [9, 10], 0)
		12: ASIMDFPModImm	match_some(11)
		15: ValueRegs	constructor(value_reg, [21], 1)
		16: InstOutput	constructor(output, [15], 2)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
	]
	constraints = [
		3:	some
		11:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3242
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		9: ScalarSize	make_variant(ScalarSize::Size32, [])
		10: ASIMDMovModImm	constructor(asimd_mov_mod_imm_zero, [9], 1)
		11: bool	const_prim(false)
		12: VectorSize	make_variant(VectorSize::Size32x2, [])
		15: ValueRegs	constructor(value_reg, [22], 1)
		16: InstOutput	constructor(output, [15], 2)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 24
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(())	extractor(null, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: u64	const_int(0, u64)
		10: Reg	constructor(imm, [7, 8, 9], 1)
		13: ValueRegs	constructor(value_reg, [10], 1)
		14: InstOutput	constructor(output, [13], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 19
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Imm64)	extractor(iconst, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: Imm64	match_some(6)
		10: u64	extractor(u64_from_imm64, 9)
		11: Reg	constructor(imm, [7, 8, 10], 1)
		14: ValueRegs	constructor(value_reg, [11], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
}

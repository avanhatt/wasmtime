inline term: lower
expansions = 802
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 97
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_high, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(true)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		15: Option(InstOutput)	some(25)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 92
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_high, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(true)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		15: Option(InstOutput)	some(25)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 87
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Uimm8))	extractor(extract_vector, 0)
		4: (Value, Uimm8)	match_some(3)
		5: Uimm8	match_tuple(4, 1)
		6: Value	match_tuple(4, 0)
		7: Reg	constructor(put_in_reg, [6], 1)
		8: ValueRegs	constructor(value_reg, [7], 2)
		9: InstOutput	constructor(output, [8], 3)
		10: Option(InstOutput)	some(9)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 81
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(DynamicStackSlot)	extractor(dynamic_stack_addr, 0)
		4: Type	const_prim(I64)
		5: WritableReg	constructor(temp_writable_reg, [4], 1)
		6: Reg	constructor(writable_reg_to_reg, [5], 0)
		7: ValueRegs	constructor(value_reg, [6], 4)
		8: InstOutput	constructor(output, [7], 5)
		9: Option(InstOutput)	some(8)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 75
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/isa/aarch64/inst.isle line 2576
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		31: ValueRegs	constructor(value_reg, [45], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 71
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(37)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		33: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		36: ValueRegs	constructor(value_reg, [43], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 67
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		24: ValueRegs	constructor(value_reg, [31], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 61
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/isa/aarch64/inst.isle line 2568
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		31: ValueRegs	constructor(value_reg, [45], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 57
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(37)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		33: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		36: ValueRegs	constructor(value_reg, [43], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 53
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		24: ValueRegs	constructor(value_reg, [31], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/isa/aarch64/inst.isle line 2560
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		31: ValueRegs	constructor(value_reg, [45], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 43
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(37)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		33: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		36: ValueRegs	constructor(value_reg, [43], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 39
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		24: ValueRegs	constructor(value_reg, [31], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 35
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmax, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmax, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [26], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 31
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmin, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmin, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [26], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 27
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fdiv, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [26], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 23
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmul, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmul, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [26], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 19
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fsub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fsub, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [26], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 15
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fadd, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		17: ValueRegs	constructor(value_reg, [26], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 11
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option((u32, u32))	extractor(dynamic_lane, 9)
		11: VecALUOp	make_variant(VecALUOp::Mul, [])
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: VectorSize	constructor(vector_size, [9], 3)
		19: ValueRegs	constructor(value_reg, [28], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 7
		../../codegen/src/isa/aarch64/inst.isle line 2464
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [30], 5)
		17: InstOutput	constructor(output, [16], 6)
		18: Option(InstOutput)	some(17)
		22: VecALUOp	make_variant(VecALUOp::Sub, [])
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 3
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [30], 5)
		17: InstOutput	constructor(output, [16], 6)
		18: Option(InstOutput)	some(17)
		22: VecALUOp	make_variant(VecALUOp::Add, [])
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2860
		../../codegen/src/isa/aarch64/inst.isle line 2223
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvpromote_low, 0)
		4: VecRRLongOp	make_variant(VecRRLongOp::Fcvtl32, [])
		5: Value	match_some(3)
		6: Reg	constructor(put_in_reg, [5], 1)
		7: bool	const_prim(false)
		10: Option(InstOutput)	some(19)
		14: Type	const_prim(I8X16)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: Reg	constructor(writable_reg_to_reg, [15], 0)
		18: ValueRegs	constructor(value_reg, [16], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 3822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		15: Option(InstOutput)	some(22)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::Macho)
		8:	some
		10:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2852
		../../codegen/src/isa/aarch64/inst.isle line 3815
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		15: Option(InstOutput)	some(22)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::ElfGd)
		8:	some
		10:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2839
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2524
		../../codegen/src/isa/aarch64/inst.isle line 2027
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		16: ValueRegs	constructor(value_reg, [69], 11)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		18: Reg	constructor(put_in_reg, [10], 5)
		19: Reg	constructor(put_in_reg, [12], 6)
		21: u64	const_int(63, u64)
		23: Cond	make_variant(Cond::Ne, [])
		26: ValueRegs	constructor(value_reg, [61], 12)
		27: InstOutput	constructor(output_pair, [16, 26], 13)
		28: Option(InstOutput)	some(27)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::SMulH, [])
		44: Type	const_prim(I64)
		45: Option(ShiftOpAndAmt)	constructor(ashr_from_u64, [44, 21], 0)
		46: ALUOp	make_variant(ALUOp::SubS, [])
		47: WritableReg	constructor(writable_zero_reg, [], 1)
		48: ShiftOpAndAmt	match_some(45)
		49: MInst	make_variant(MInst::AluRRRShift, [46, 17, 47, 76, 69, 48])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: MInst	make_variant(MInst::CSet, [53, 23])
		55: Reg	constructor(writable_reg_to_reg, [53], 0)
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 55])
		59: ValueRegs	constructor(with_flags, [50, 56], 1)
		60: usize	const_int(0, usize)
		61: Reg	constructor(value_regs_get, [59, 60], 2)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		45:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2825
		../../codegen/src/isa/aarch64/inst.isle line 2500
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: ValueRegs	constructor(value_reg, [57], 8)
		16: OperandSize	make_variant(OperandSize::Size64, [])
		17: ExtendOp	make_variant(ExtendOp::SXTW, [])
		19: Cond	make_variant(Cond::Ne, [])
		22: ValueRegs	constructor(value_reg, [49], 9)
		23: InstOutput	constructor(output_pair, [15, 22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp3	make_variant(ALUOp3::SMAddL, [])
		29: Type	const_prim(I32)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: MInst	make_variant(MInst::AluRRRExtend, [35, 16, 36, 57, 57, 17])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::CSet, [41, 19])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 43])
		47: ValueRegs	constructor(with_flags, [38, 44], 1)
		48: usize	const_int(0, usize)
		49: Reg	constructor(value_regs_get, [47, 48], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I32)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [13], 1)
		35: bool	const_prim(true)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		33:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I32)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [13], 1)
		35: bool	const_prim(true)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		33:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [11], 1)
		32: bool	const_prim(true)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 13)
		39: Reg	constructor(put_in_reg, [13], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [11], 1)
		32: bool	const_prim(true)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 13)
		39: Reg	constructor(put_in_reg, [13], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I32)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [92], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [70], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [11], 1)
		32: bool	const_prim(true)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 13)
		39: Option(Type)	extractor(fits_in_32, 38)
		40: Reg	constructor(put_in_reg, [13], 1)
		41: bool	const_prim(true)
		42: Type	match_some(39)
		43: u8	constructor(ty_bits, [42], 0)
		44: u8	const_int(32, u8)
		50: ALUOp3	make_variant(ALUOp3::MAdd, [])
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRRExtend, [56, 18, 57, 92, 92, 20])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::CSet, [62, 22])
		64: Reg	constructor(writable_reg_to_reg, [62], 0)
		65: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [63, 64])
		68: ValueRegs	constructor(with_flags, [59, 65], 1)
		69: usize	const_int(0, usize)
		70: Reg	constructor(value_regs_get, [68, 69], 2)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: Reg	constructor(writable_reg_to_reg, [76], 0)
		82: Type	const_prim(I64)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: Reg	constructor(writable_reg_to_reg, [83], 0)
		90: Type	const_prim(I64)
		91: WritableReg	constructor(temp_writable_reg, [90], 1)
		92: Reg	constructor(writable_reg_to_reg, [91], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		39:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2791
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2520
		../../codegen/src/isa/aarch64/inst.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2124
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		16: ValueRegs	constructor(value_reg, [62], 12)
		17: Reg	constructor(put_in_reg, [10], 5)
		18: Reg	constructor(put_in_reg, [12], 6)
		20: u8	const_int(0, u8)
		21: Imm12	constructor(u8_into_imm12, [20], 8)
		23: Cond	make_variant(Cond::Ne, [])
		26: ValueRegs	constructor(value_reg, [54], 13)
		27: InstOutput	constructor(output_pair, [16, 26], 14)
		28: Option(InstOutput)	some(27)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::UMulH, [])
		42: OperandSize	make_variant(OperandSize::Size64, [])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 23])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [47, 48])
		52: ValueRegs	constructor(with_flags, [76, 49], 1)
		53: usize	const_int(0, usize)
		54: Reg	constructor(value_regs_get, [52, 53], 2)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
		73: ALUOp	make_variant(ALUOp::SubS, [])
		74: WritableReg	constructor(writable_zero_reg, [], 1)
		75: MInst	make_variant(MInst::AluRRImm12, [73, 42, 74, 69, 21])
		76: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [75])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2496
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: ValueRegs	constructor(value_reg, [57], 8)
		16: OperandSize	make_variant(OperandSize::Size64, [])
		17: ExtendOp	make_variant(ExtendOp::UXTW, [])
		19: Cond	make_variant(Cond::Ne, [])
		22: ValueRegs	constructor(value_reg, [49], 9)
		23: InstOutput	constructor(output_pair, [15, 22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp3	make_variant(ALUOp3::UMAddL, [])
		29: Type	const_prim(I32)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: MInst	make_variant(MInst::AluRRRExtend, [35, 16, 36, 57, 57, 17])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::CSet, [41, 19])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 43])
		47: ValueRegs	constructor(with_flags, [38, 44], 1)
		48: usize	const_int(0, usize)
		49: Reg	constructor(value_regs_get, [47, 48], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		32:	const_prim(I32)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [13], 1)
		35: bool	const_prim(false)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I64)
		33:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [66], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [58], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Reg	constructor(put_in_reg, [13], 1)
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: WritableReg	constructor(writable_zero_reg, [], 1)
		46: MInst	make_variant(MInst::AluRRRExtend, [44, 18, 45, 66, 66, 20])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 22])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
		56: ValueRegs	constructor(with_flags, [47, 53], 1)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 2)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		32:	const_prim(I32)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Reg	constructor(put_in_reg, [11], 1)
		32: Type	extractor(value_type, 13)
		33: Option(Type)	extractor(fits_in_32, 32)
		34: Reg	constructor(put_in_reg, [13], 1)
		35: bool	const_prim(false)
		36: Type	match_some(33)
		37: u8	constructor(ty_bits, [36], 0)
		38: u8	const_int(32, u8)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		29:	const_prim(I32)
		33:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [11], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 13)
		39: Reg	constructor(put_in_reg, [13], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I64)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [79], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [64], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [11], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 13)
		39: Reg	constructor(put_in_reg, [13], 1)
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::SubS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 1)
		52: MInst	make_variant(MInst::AluRRRExtend, [50, 18, 51, 79, 79, 20])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 22])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		38:	const_prim(I32)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 4)
		17: ValueRegs	constructor(value_reg, [92], 9)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		20: ExtendOp	constructor(lower_extend_op, [9, 19], 1)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [70], 10)
		26: InstOutput	constructor(output_pair, [17, 25], 11)
		27: Option(InstOutput)	some(26)
		29: Type	extractor(value_type, 11)
		30: Option(Type)	extractor(fits_in_32, 29)
		31: Reg	constructor(put_in_reg, [11], 1)
		32: bool	const_prim(false)
		33: Type	match_some(30)
		34: u8	constructor(ty_bits, [33], 0)
		35: u8	const_int(32, u8)
		38: Type	extractor(value_type, 13)
		39: Option(Type)	extractor(fits_in_32, 38)
		40: Reg	constructor(put_in_reg, [13], 1)
		41: bool	const_prim(false)
		42: Type	match_some(39)
		43: u8	constructor(ty_bits, [42], 0)
		44: u8	const_int(32, u8)
		50: ALUOp3	make_variant(ALUOp3::MAdd, [])
		56: ALUOp	make_variant(ALUOp::SubS, [])
		57: WritableReg	constructor(writable_zero_reg, [], 1)
		58: MInst	make_variant(MInst::AluRRRExtend, [56, 18, 57, 92, 92, 20])
		59: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [58])
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::CSet, [62, 22])
		64: Reg	constructor(writable_reg_to_reg, [62], 0)
		65: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [63, 64])
		68: ValueRegs	constructor(with_flags, [59, 65], 1)
		69: usize	const_int(0, usize)
		70: Reg	constructor(value_regs_get, [68, 69], 2)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: Reg	constructor(writable_reg_to_reg, [76], 0)
		82: Type	const_prim(I64)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: Reg	constructor(writable_reg_to_reg, [83], 0)
		90: Type	const_prim(I64)
		91: WritableReg	constructor(temp_writable_reg, [90], 1)
		92: Reg	constructor(writable_reg_to_reg, [91], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		30:	some
		39:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2745
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_64, 9)
		52: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2745
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_32, 9)
		52: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(false)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(true)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2725
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Lo, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_64, 9)
		52: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2725
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Lo, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_32, 9)
		52: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(false)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(true)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_64, 9)
		52: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_32, 9)
		52: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(false)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(true)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_64, 21)
		70: OperandSize	make_variant(OperandSize::Size64, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_64, 21)
		73: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
		../../codegen/src/isa/aarch64/lower.isle line 2658
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2065
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/prelude_lower.isle line 168
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		15: Option(InstOutput)	some(67)
		21: Type	const_prim(I64)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: ValueRegs	constructor(put_in_regs, [10], 4)
		26: Reg	constructor(value_regs_get, [25, 23], 5)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [22, 28], 3)
		30: Reg	constructor(value_regs_get, [25, 28], 6)
		33: MultiReg	constructor(with_flags_chained, [44, 54, 60], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [11, 70, 41, 24, 26])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::AluRRR, [12, 73, 51, 29, 30])
		53: Reg	constructor(writable_reg_to_reg, [51], 0)
		54: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [52, 53])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: MInst	make_variant(MInst::CSet, [57, 13])
		59: Reg	constructor(writable_reg_to_reg, [57], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		62: Reg	match_variant(33, MultiReg::Three, a)
		63: Reg	match_variant(33, MultiReg::Three, b)
		64: ValueRegs	constructor(value_regs, [62, 63], 1)
		65: Reg	match_variant(33, MultiReg::Three, c)
		66: ValueRegs	constructor(value_reg, [65], 2)
		67: InstOutput	constructor(output_pair, [64, 66], 3)
		69: Option(Type)	extractor(fits_in_32, 21)
		70: OperandSize	make_variant(OperandSize::Size32, [])
		72: Option(Type)	extractor(fits_in_32, 21)
		73: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		33:	variant(MultiReg::Three)
		69:	some
		72:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2687
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uadd_overflow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Hs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_64, 9)
		52: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2687
		../../codegen/src/isa/aarch64/lower.isle line 2647
		../../codegen/src/isa/aarch64/inst.isle line 2057
		../../codegen/src/isa/aarch64/inst.isle line 2391
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uadd_overflow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Hs, [])
		16: Option(InstOutput)	some(33)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: Reg	constructor(put_in_reg, [12], 2)
		26: ValueRegs	constructor(with_flags, [43, 49], 5)
		27: usize	const_int(0, usize)
		28: Reg	constructor(value_regs_get, [26, 27], 6)
		29: ValueRegs	constructor(value_reg, [28], 7)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [26, 30], 8)
		32: ValueRegs	constructor(value_reg, [31], 9)
		33: InstOutput	constructor(output_pair, [29, 32], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::AluRRR, [13, 52, 40, 22, 23])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [41, 42])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::CSet, [46, 14])
		48: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [47, 48])
		51: Option(Type)	extractor(fits_in_32, 9)
		52: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		51:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2981
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2980
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2612
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(false)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Uext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2972
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2971
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Reg	constructor(put_in_reg, [11], 1)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		65:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
		../../codegen/src/isa/aarch64/lower.isle line 2618
		../../codegen/src/isa/aarch64/lower.isle line 2610
		../../codegen/src/isa/aarch64/inst.isle line 2035
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(33)
		23: Reg	constructor(put_in_reg, [12], 3)
		24: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		26: ValueRegs	constructor(value_reg, [44], 8)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [63], 9)
		33: InstOutput	constructor(output_pair, [26, 32], 10)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		49: ALUOp	make_variant(ALUOp::SubS, [])
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: MInst	make_variant(MInst::AluRRRExtend, [49, 27, 50, 44, 44, 24])
		52: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [51])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSet, [55, 29])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
		61: ValueRegs	constructor(with_flags, [52, 58], 1)
		62: usize	const_int(0, usize)
		63: Reg	constructor(value_regs_get, [61, 62], 2)
		65: Type	extractor(value_type, 11)
		66: Option(Type)	extractor(fits_in_32, 65)
		67: Reg	constructor(put_in_reg, [11], 1)
		68: bool	const_prim(true)
		69: Type	match_some(66)
		70: u8	constructor(ty_bits, [69], 0)
		71: u8	const_int(32, u8)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		13:	variant(ArgumentExtension::Sext)
		66:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2603
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 3033
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, TrapCode))	extractor(uadd_overflow_trap, 7)
		9: Type	match_some(6)
		10: (Value, Value, TrapCode)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		16: TrapCode	match_tuple(10, 2)
		19: Option(InstOutput)	some(39)
		23: ALUOp	make_variant(ALUOp::AddS, [])
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::AluRRR, [23, 42, 26, 12, 14])
		28: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [27, 28])
		32: Cond	make_variant(Cond::Hs, [])
		33: CondBrKind	constructor(cond_br_cond, [32], 1)
		34: MInst	make_variant(MInst::TrapIf, [33, 16])
		35: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect, [34])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		41: Option(Type)	extractor(fits_in_64, 9)
		42: OperandSize	make_variant(OperandSize::Size64, [])
		45: ValueRegs	constructor(with_flags, [29, 35], 1)
		46: usize	const_int(0, usize)
		47: Reg	constructor(value_regs_get, [45, 46], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		41:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2603
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 3033
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, TrapCode))	extractor(uadd_overflow_trap, 7)
		9: Type	match_some(6)
		10: (Value, Value, TrapCode)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		16: TrapCode	match_tuple(10, 2)
		19: Option(InstOutput)	some(39)
		23: ALUOp	make_variant(ALUOp::AddS, [])
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::AluRRR, [23, 42, 26, 12, 14])
		28: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [27, 28])
		32: Cond	make_variant(Cond::Hs, [])
		33: CondBrKind	constructor(cond_br_cond, [32], 1)
		34: MInst	make_variant(MInst::TrapIf, [33, 16])
		35: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect, [34])
		38: ValueRegs	constructor(value_reg, [47], 1)
		39: InstOutput	constructor(output, [38], 2)
		41: Option(Type)	extractor(fits_in_32, 9)
		42: OperandSize	make_variant(OperandSize::Size32, [])
		45: ValueRegs	constructor(with_flags, [29, 35], 1)
		46: usize	const_int(0, usize)
		47: Reg	constructor(value_regs_get, [45, 46], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		41:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2589
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2444
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Type	const_prim(I64)
		7: Reg	constructor(put_in_reg, [4], 3)
		8: u8	const_int(0, u8)
		9: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 7)
		14: Reg	constructor(put_in_reg, [4], 1)
		15: u8	const_int(1, u8)
		17: ImmShift	constructor(imm_shift_from_u8, [11], 5)
		19: u64	const_int(1, u64)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_u64, [6, 19], 0)
		21: ShiftOpAndAmt	match_some(20)
		24: Option(InstOutput)	some(55)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: ALUOp	make_variant(ALUOp::Lsr, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		51: ALUOp	make_variant(ALUOp::Add, [])
		54: ValueRegs	constructor(value_reg, [77], 1)
		55: InstOutput	constructor(output, [54], 2)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: Reg	constructor(writable_reg_to_reg, [76], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2576
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(31, u8)
		8: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u128	const_int(633825300187901677051779743745, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size32, [])
		18: Option(InstOutput)	some(41)
		22: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		27: VecALUOp	make_variant(VecALUOp::And, [])
		31: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		53: Type	const_prim(I8X16)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		59: Type	const_prim(I8X16)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2563
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(15, u8)
		8: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u128	const_int(664619068533544770747334646890102785, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size16, [])
		18: Option(InstOutput)	some(41)
		22: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		27: VecALUOp	make_variant(VecALUOp::And, [])
		31: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		53: Type	const_prim(I8X16)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		59: Type	const_prim(I8X16)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2539
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2340
		../../codegen/src/isa/aarch64/inst.isle line 2599
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(7, u8)
		8: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u128	const_int(-169808226154284360427508033573982305791, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		13: u8	const_int(8, u8)
		16: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: u8	const_int(0, u8)
		19: ScalarSize	make_variant(ScalarSize::Size16, [])
		22: Option(InstOutput)	some(56)
		26: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		31: VecALUOp	make_variant(VecALUOp::And, [])
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		42: VecALUOp	make_variant(VecALUOp::Zip1, [])
		46: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		55: ValueRegs	constructor(value_reg, [53], 1)
		56: InstOutput	constructor(output, [55], 2)
		61: Type	const_prim(I8X16)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		68: Type	const_prim(I8X16)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
		75: Type	const_prim(I8X16)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: Reg	constructor(writable_reg_to_reg, [76], 0)
		81: Type	const_prim(I8X16)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2525
		../../codegen/src/isa/aarch64/inst.isle line 3709
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((StackSlot, Offset32))	extractor(stack_addr, 0)
		4: (StackSlot, Offset32)	match_some(3)
		5: StackSlot	match_tuple(4, 0)
		6: Offset32	match_tuple(4, 1)
		9: Option(InstOutput)	some(17)
		12: Type	const_prim(I64)
		13: WritableReg	constructor(temp_writable_reg, [12], 1)
		14: Reg	constructor(writable_reg_to_reg, [13], 0)
		16: ValueRegs	constructor(value_reg, [14], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2518
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Uimm8	match_tuple(4, 2)
		12: u8	extractor(u8_from_uimm8, 11)
		13: u8	const_int(0, u8)
		14: Type	extractor(value_type, 8)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(29)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2513
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_int, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Uimm8	match_tuple(4, 2)
		12: u8	extractor(u8_from_uimm8, 11)
		13: Type	extractor(value_type, 8)
		14: VectorSize	constructor(vector_size, [13], 3)
		17: Option(InstOutput)	some(27)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2506
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Uimm8	match_tuple(9, 1)
		13: u8	extractor(u8_from_uimm8, 12)
		14: Type	extractor(value_type, 10)
		15: VectorSize	constructor(vector_size, [14], 2)
		18: Option(InstOutput)	some(27)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2501
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Uimm8	match_tuple(9, 1)
		13: u8	extractor(u8_from_uimm8, 12)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 2)
		18: Option(InstOutput)	some(27)
		22: Type	const_prim(I64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2498
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Uimm8	match_tuple(9, 1)
		11: u8	extractor(u8_from_uimm8, 10)
		12: Value	match_tuple(9, 0)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(put_in_regs, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_int(0)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2492
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value))	extractor(bitcast, 6)
		8: (MemFlags, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Type	extractor(value_type, 9)
		12: Option(InstOutput)	some(15)
		14: ValueRegs	constructor(put_in_regs, [9], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	const_prim(I128)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2488
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(put_in_regs, [10], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(I32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(I64)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(false)
		22:	const_prim(true)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 332
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(false)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 331
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R64)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 332
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(false)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 331
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3477
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/prelude.isle line 330
		../../codegen/src/prelude.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 3471
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		18: Option(InstOutput)	some(30)
		20: bool	const_prim(true)
		22: bool	const_prim(true)
		25: Type	const_prim(I32)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R32)
		6:	some
		8:	some
		11:	const_prim(R32)
		12:	some
		20:	const_prim(true)
		22:	const_prim(false)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(fits_in_64, 11)
		13: Type	match_some(12)
		14: Option(Type)	extractor(ty_float_or_vec, 13)
		15: Reg	constructor(put_in_reg, [10], 1)
		16: u8	const_int(0, u8)
		17: ScalarSize	constructor(scalar_size, [5], 2)
		20: Option(InstOutput)	some(29)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
		14:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2462
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		13: Reg	constructor(put_in_reg, [10], 1)
		14: ScalarSize	constructor(scalar_size, [11], 2)
		17: Option(InstOutput)	some(25)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2458
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_float_or_vec, 11)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(put_in_regs, [10], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3703
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3493
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(set_pinned_reg, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		8: Option(InstOutput)	some(13)
		10: PReg	constructor(preg_pinned, [], 1)
		13: InstOutput	constructor(output_none, [], 2)
		16: MInst	make_variant(MInst::MovToPReg, [10, 5])
		17: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [16])
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2449
		../../codegen/src/isa/aarch64/inst.isle line 3487
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_pinned_reg, 0)
		4: PReg	constructor(preg_pinned, [], 1)
		7: Option(InstOutput)	some(14)
		9: Type	const_prim(I64)
		10: WritableReg	constructor(temp_writable_reg, [9], 1)
		11: Reg	constructor(writable_reg_to_reg, [10], 0)
		13: ValueRegs	constructor(value_reg, [11], 1)
		14: InstOutput	constructor(output, [13], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(28)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore128, [14, 21, 13])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		28: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(28)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore64, [14, 21, 13])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		28: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore128, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2899
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(28)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore128, [14, 21, 13])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		28: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(42)
		21: Option(Inst)	extractor(def_inst, 9)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 11], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		39: MInst	make_variant(MInst::FpuStore64, [14, 35, 13])
		40: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [39])
		42: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(4, 0)
		14: Reg	constructor(put_in_reg, [5], 2)
		17: Option(InstOutput)	some(28)
		21: AMode	constructor(amode_no_more_iconst, [8, 9, 11], 1)
		25: MInst	make_variant(MInst::FpuStore64, [14, 21, 13])
		26: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [25])
		28: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3212
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		20: Option(InstOutput)	some(36)
		23: i64	constructor(i32_as_i64, [9], 0)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		27: SImm7Scaled	match_some(25)
		28: PairAMode	make_variant(PairAMode::SignedOffset, [26, 27])
		33: MInst	make_variant(MInst::StoreP64, [14, 17, 28, 11])
		34: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [33])
		36: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		25:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3200
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		20: Option(InstOutput)	some(37)
		23: i64	const_int(0, i64)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		28: SImm7Scaled	match_some(25)
		29: PairAMode	make_variant(PairAMode::SignedOffset, [26, 28])
		34: MInst	make_variant(MInst::StoreP64, [14, 17, 29, 11])
		35: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [34])
		37: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		9:	const_int(0)
		25:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3197
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		20: Option(InstOutput)	some(37)
		23: i64	const_int(0, i64)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		28: SImm7Scaled	match_some(25)
		29: PairAMode	make_variant(PairAMode::SignedOffset, [57, 28])
		34: MInst	make_variant(MInst::StoreP64, [14, 17, 29, 11])
		35: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [34])
		37: InstOutput	constructor(output_none, [], 2)
		40: i64	constructor(i32_as_i64, [9], 0)
		41: u64	constructor(i64_as_u64, [40], 0)
		42: Option(Imm12)	extractor(imm12_from_u64, 41)
		43: Type	const_prim(I64)
		44: Imm12	match_some(42)
		49: ALUOp	make_variant(ALUOp::Add, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		25:	some
		42:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2902
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3195
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(4, 0)
		12: ValueRegs	constructor(put_in_regs, [5], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: ValueRegs	constructor(put_in_regs, [5], 4)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 5)
		20: Option(InstOutput)	some(37)
		23: i64	const_int(0, i64)
		24: Type	const_prim(I64)
		25: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [23, 24], 0)
		26: Reg	constructor(put_in_reg, [7], 1)
		28: SImm7Scaled	match_some(25)
		29: PairAMode	make_variant(PairAMode::SignedOffset, [57, 28])
		34: MInst	make_variant(MInst::StoreP64, [14, 17, 29, 11])
		35: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [34])
		37: InstOutput	constructor(output_none, [], 2)
		40: Type	const_prim(I64)
		41: ImmExtend	make_variant(ImmExtend::Zero, [])
		42: i64	constructor(i32_as_i64, [9], 0)
		43: u64	constructor(i64_as_u64, [42], 0)
		44: Reg	constructor(imm, [40, 41, 43], 1)
		49: ALUOp	make_variant(ALUOp::Add, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
		25:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore64, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2896
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::FpuStore64, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2893
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore32, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2893
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::FpuStore32, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2893
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::FpuStore32, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(40)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store32, [12, 33, 10])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(40)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store32, [12, 33, 10])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(26)
		19: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		23: MInst	make_variant(MInst::Store32, [12, 19, 10])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(40)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store16, [12, 33, 10])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(40)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store16, [12, 33, 10])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(26)
		19: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		23: MInst	make_variant(MInst::Store16, [12, 19, 10])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(40)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 0)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 1)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store8, [12, 33, 10])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(40)
		19: Option(Inst)	extractor(def_inst, 6)
		20: Inst	match_some(19)
		21: Option((Value, Value))	extractor(iadd, 20)
		22: (Value, Value)	match_some(21)
		23: Value	match_tuple(22, 1)
		24: Option(Inst)	extractor(def_inst, 23)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(i32)	extractor(simm32, 27)
		29: i32	match_some(28)
		30: Option(i32)	constructor(s32_add_fallible, [29, 8], 0)
		31: Value	match_tuple(22, 0)
		32: i32	match_some(30)
		33: AMode	constructor(amode_no_more_iconst, [4, 31, 32], 1)
		37: MInst	make_variant(MInst::Store8, [12, 33, 10])
		38: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [37])
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		19:	some
		21:	some
		24:	some
		26:	some
		28:	some
		30:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		11: Value	match_tuple(5, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(26)
		19: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		23: MInst	make_variant(MInst::Store8, [12, 19, 10])
		24: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [23])
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store64, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store64, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2890
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store64, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store32, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store32, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2887
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store32, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store16, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store16, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2884
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store16, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 0)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 1)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store8, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 8)
		21: Inst	match_some(20)
		22: Option((Value, Value))	extractor(iadd, 21)
		23: (Value, Value)	match_some(22)
		24: Value	match_tuple(23, 1)
		25: Option(Inst)	extractor(def_inst, 24)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(i32)	extractor(simm32, 28)
		30: i32	match_some(29)
		31: Option(i32)	constructor(s32_add_fallible, [30, 10], 0)
		32: Value	match_tuple(23, 0)
		33: i32	match_some(31)
		34: AMode	constructor(amode_no_more_iconst, [7, 32, 33], 1)
		38: MInst	make_variant(MInst::Store8, [13, 34, 12])
		39: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [38])
		41: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
		20:	some
		22:	some
		25:	some
		27:	some
		29:	some
		31:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2881
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		12: MemFlags	match_tuple(4, 0)
		13: Reg	constructor(put_in_reg, [5], 2)
		16: Option(InstOutput)	some(27)
		20: AMode	constructor(amode_no_more_iconst, [7, 8, 10], 1)
		24: MInst	make_variant(MInst::Store8, [13, 20, 12])
		25: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [24])
		27: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(36)
		21: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(36)
		21: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(36)
		21: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(36)
		21: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(36)
		21: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(50)
		21: Option(Inst)	extractor(def_inst, 7)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 9], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [5, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		49: ValueRegs	constructor(value_reg, [47], 1)
		50: InstOutput	constructor(output, [49], 2)
	]
	constraints = [
		3:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		5: Type	const_prim(F64)
		6: (MemFlags, Value, Offset32)	match_some(3)
		7: Value	match_tuple(6, 1)
		8: Offset32	match_tuple(6, 2)
		9: i32	constructor(offset32_to_i32, [8], 0)
		11: MemFlags	match_tuple(6, 0)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(36)
		21: AMode	constructor(amode_no_more_iconst, [5, 7, 9], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2847
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2847
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2847
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(25)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(25)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2837
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2837
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2837
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(25)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(25)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2827
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2827
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2827
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(25)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 0)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 1)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(39)
		17: Option(Inst)	extractor(def_inst, 6)
		18: Inst	match_some(17)
		19: Option((Value, Value))	extractor(iadd, 18)
		20: (Value, Value)	match_some(19)
		21: Value	match_tuple(20, 1)
		22: Option(Inst)	extractor(def_inst, 21)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(i32)	extractor(simm32, 25)
		27: i32	match_some(26)
		28: Option(i32)	constructor(s32_add_fallible, [27, 8], 0)
		29: Value	match_tuple(20, 0)
		30: i32	match_some(28)
		31: AMode	constructor(amode_no_more_iconst, [4, 29, 30], 1)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		17:	some
		19:	some
		22:	some
		24:	some
		26:	some
		28:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(25)
		17: AMode	constructor(amode_no_more_iconst, [4, 6, 8], 1)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(30)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64X2)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(30)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64X2)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2867
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(30)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64X2)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 0)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 1)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(44)
		22: Option(Inst)	extractor(def_inst, 11)
		23: Inst	match_some(22)
		24: Option((Value, Value))	extractor(iadd, 23)
		25: (Value, Value)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Option(Inst)	extractor(def_inst, 26)
		28: Inst	match_some(27)
		29: Option(Imm64)	extractor(iconst, 28)
		30: Imm64	match_some(29)
		31: Option(i32)	extractor(simm32, 30)
		32: i32	match_some(31)
		33: Option(i32)	constructor(s32_add_fallible, [32, 13], 0)
		34: Value	match_tuple(25, 0)
		35: i32	match_some(33)
		36: AMode	constructor(amode_no_more_iconst, [9, 34, 35], 1)
		39: Type	const_prim(F64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		24:	some
		27:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(30)
		22: AMode	constructor(amode_no_more_iconst, [9, 11, 13], 1)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3212
		../../codegen/src/isa/aarch64/inst.isle line 2872
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [32], 3)
		16: Option(InstOutput)	some(15)
		19: i64	constructor(i32_as_i64, [11], 0)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		23: SImm7Scaled	match_some(21)
		24: PairAMode	make_variant(PairAMode::SignedOffset, [22, 23])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		30: WritableReg	constructor(temp_writable_reg, [27], 2)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
		32: ValueRegs	constructor(value_regs, [29, 31], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		21:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2872
		../../codegen/src/isa/aarch64/inst.isle line 3200
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [33], 3)
		16: Option(InstOutput)	some(15)
		19: i64	const_int(0, i64)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		24: SImm7Scaled	match_some(21)
		25: PairAMode	make_variant(PairAMode::SignedOffset, [22, 24])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		31: WritableReg	constructor(temp_writable_reg, [28], 2)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		33: ValueRegs	constructor(value_regs, [30, 32], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		11:	const_int(0)
		21:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2872
		../../codegen/src/isa/aarch64/inst.isle line 3197
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [33], 3)
		16: Option(InstOutput)	some(15)
		19: i64	const_int(0, i64)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		24: SImm7Scaled	match_some(21)
		25: PairAMode	make_variant(PairAMode::SignedOffset, [53, 24])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		31: WritableReg	constructor(temp_writable_reg, [28], 2)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		33: ValueRegs	constructor(value_regs, [30, 32], 4)
		36: i64	constructor(i32_as_i64, [11], 0)
		37: u64	constructor(i64_as_u64, [36], 0)
		38: Option(Imm12)	extractor(imm12_from_u64, 37)
		39: Type	const_prim(I64)
		40: Imm12	match_some(38)
		45: ALUOp	make_variant(ALUOp::Add, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		21:	some
		38:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
		../../codegen/src/isa/aarch64/inst.isle line 3207
		../../codegen/src/isa/aarch64/inst.isle line 2872
		../../codegen/src/isa/aarch64/inst.isle line 3195
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [33], 3)
		16: Option(InstOutput)	some(15)
		19: i64	const_int(0, i64)
		20: Type	const_prim(I64)
		21: Option(SImm7Scaled)	constructor(simm7_scaled_from_i64, [19, 20], 0)
		22: Reg	constructor(put_in_reg, [9], 1)
		24: SImm7Scaled	match_some(21)
		25: PairAMode	make_variant(PairAMode::SignedOffset, [53, 24])
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		31: WritableReg	constructor(temp_writable_reg, [28], 2)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		33: ValueRegs	constructor(value_regs, [30, 32], 4)
		36: Type	const_prim(I64)
		37: ImmExtend	make_variant(ImmExtend::Zero, [])
		38: i64	constructor(i32_as_i64, [11], 0)
		39: u64	constructor(i64_as_u64, [38], 0)
		40: Reg	constructor(imm, [36, 37, 39], 1)
		45: ALUOp	make_variant(ALUOp::Add, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		21:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2862
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2857
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2857
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(F64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2857
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2852
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2842
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2832
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
		../../codegen/src/isa/aarch64/inst.isle line 3133
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 0)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 1)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
		../../codegen/src/isa/aarch64/inst.isle line 3130
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(43)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Value, Value))	extractor(iadd, 22)
		24: (Value, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Option(Inst)	extractor(def_inst, 25)
		27: Inst	match_some(26)
		28: Option(Imm64)	extractor(iconst, 27)
		29: Imm64	match_some(28)
		30: Option(i32)	extractor(simm32, 29)
		31: i32	match_some(30)
		32: Option(i32)	constructor(s32_add_fallible, [31, 12], 0)
		33: Value	match_tuple(24, 0)
		34: i32	match_some(32)
		35: AMode	constructor(amode_no_more_iconst, [8, 33, 34], 1)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ValueRegs	constructor(value_reg, [40], 1)
		43: InstOutput	constructor(output, [42], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		21:	some
		23:	some
		26:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
		../../codegen/src/isa/aarch64/inst.isle line 3128
		../../codegen/src/isa/aarch64/inst.isle line 2822
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(29)
		21: AMode	constructor(amode_no_more_iconst, [8, 10, 12], 1)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2276
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(return_call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_return_call_indirect, [5, 6, 7], 1)
		9: Option(InstOutput)	some(8)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2273
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(return_call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_return_call, [7, 8, 9, 10], 1)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2268
		../../codegen/src/prelude_lower.isle line 1044
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(ValueSlice)	extractor(return, 0)
		4: ValueSlice	match_some(3)
		6: Option(InstOutput)	some(8)
		8: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2262
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_call_indirect, [5, 6, 7], 1)
		9: Option(InstOutput)	some(8)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2259
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_call, [7, 8, 9, 10], 1)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2254
		../../codegen/src/isa/aarch64/inst.isle line 3533
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3487
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		6: Option(InstOutput)	some(12)
		7: Option(Unit)	constructor(preserve_frame_pointers, [], 0)
		8: PReg	constructor(preg_link, [], 4)
		11: ValueRegs	constructor(value_reg, [16], 1)
		12: InstOutput	constructor(output, [11], 2)
		14: Type	const_prim(I64)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: Reg	constructor(writable_reg_to_reg, [15], 0)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2254
		../../codegen/src/isa/aarch64/inst.isle line 3517
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		6: Option(InstOutput)	some(14)
		7: Option(Unit)	constructor(preserve_frame_pointers, [], 0)
		8: Option(Unit)	constructor(sign_return_address_disabled, [], 0)
		9: Type	const_prim(I64)
		10: WritableReg	constructor(temp_writable_reg, [9], 1)
		11: Reg	constructor(writable_reg_to_reg, [10], 0)
		13: ValueRegs	constructor(value_reg, [11], 1)
		14: InstOutput	constructor(output, [13], 2)
	]
	constraints = [
		3:	some
		7:	some
		8:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2251
		../../codegen/src/isa/aarch64/inst.isle line 3509
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3487
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_stack_pointer, 0)
		6: Option(InstOutput)	some(11)
		7: PReg	constructor(preg_sp, [], 1)
		10: ValueRegs	constructor(value_reg, [15], 1)
		11: InstOutput	constructor(output, [10], 2)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: Reg	constructor(writable_reg_to_reg, [14], 0)
	]
	constraints = [
		3:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2248
		../../codegen/src/isa/aarch64/inst.isle line 3513
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3487
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_frame_pointer, 0)
		6: Option(InstOutput)	some(11)
		7: PReg	constructor(preg_fp, [], 1)
		10: ValueRegs	constructor(value_reg, [15], 1)
		11: InstOutput	constructor(output, [10], 2)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: Reg	constructor(writable_reg_to_reg, [14], 0)
	]
	constraints = [
		3:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2243
		../../codegen/src/isa/aarch64/inst.isle line 3108
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(GlobalValue)	extractor(symbol_value, 0)
		4: GlobalValue	match_some(3)
		5: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 4)
		6: (ExternalName, RelocDistance, i64)	match_some(5)
		7: ExternalName	match_tuple(6, 0)
		8: BoxExternalName	constructor(box_external_name, [7], 1)
		9: i64	match_tuple(6, 2)
		12: Option(InstOutput)	some(20)
		15: Type	const_prim(I64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2238
		../../codegen/src/isa/aarch64/inst.isle line 3108
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(FuncRef)	extractor(func_addr, 0)
		4: FuncRef	match_some(3)
		5: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 4)
		6: ExternalName	match_tuple(5, 1)
		7: BoxExternalName	constructor(box_external_name, [6], 1)
		8: i64	const_int(0, i64)
		11: Option(InstOutput)	some(19)
		14: Type	const_prim(I64)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: Reg	constructor(writable_reg_to_reg, [15], 0)
		18: ValueRegs	constructor(value_reg, [16], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2233
		../../codegen/src/isa/aarch64/inst.isle line 2590
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(debugtrap, 0)
		6: Option(InstOutput)	some(10)
		7: MInst	make_variant(MInst::Brk, [])
		8: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [7])
		10: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2227
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2112
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_invalid, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(1, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [25, 31], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		17: Option(Type)	extractor(fits_in_64, 5)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		22: ALUOp	make_variant(ALUOp::AddS, [])
		23: WritableReg	constructor(writable_zero_reg, [], 1)
		24: MInst	make_variant(MInst::AluRRImm12, [22, 18, 23, 7, 9])
		25: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [24])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::CSet, [28, 11])
		30: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [29, 30])
	]
	constraints = [
		3:	some
		17:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2227
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2112
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_invalid, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(1, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [25, 31], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		17: Option(Type)	extractor(fits_in_32, 5)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		22: ALUOp	make_variant(ALUOp::AddS, [])
		23: WritableReg	constructor(writable_zero_reg, [], 1)
		24: MInst	make_variant(MInst::AluRRImm12, [22, 18, 23, 7, 9])
		25: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [24])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::CSet, [28, 11])
		30: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [29, 30])
	]
	constraints = [
		3:	some
		17:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2221
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_null, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(0, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [25, 31], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		17: Option(Type)	extractor(fits_in_64, 5)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		22: ALUOp	make_variant(ALUOp::SubS, [])
		23: WritableReg	constructor(writable_zero_reg, [], 1)
		24: MInst	make_variant(MInst::AluRRImm12, [22, 18, 23, 7, 9])
		25: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [24])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::CSet, [28, 11])
		30: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [29, 30])
	]
	constraints = [
		3:	some
		17:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2221
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_null, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(0, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [25, 31], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		17: Option(Type)	extractor(fits_in_32, 5)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		22: ALUOp	make_variant(ALUOp::SubS, [])
		23: WritableReg	constructor(writable_zero_reg, [], 1)
		24: MInst	make_variant(MInst::AluRRImm12, [22, 18, 23, 7, 9])
		25: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [24])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::CSet, [28, 11])
		30: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [29, 30])
	]
	constraints = [
		3:	some
		17:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2216
		../../codegen/src/isa/aarch64/inst.isle line 2580
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(fence, 0)
		6: Option(InstOutput)	some(10)
		7: MInst	make_variant(MInst::Fence, [])
		8: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [7])
		10: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2209
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: u8	const_int(1, u8)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		15: bool	const_prim(false)
		16: ScalarSize	constructor(lane_size, [5], 3)
		19: Option(InstOutput)	some(35)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2206
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: bool	const_prim(true)
		13: Type	match_some(6)
		14: ScalarSize	constructor(lane_size, [13], 2)
		17: Option(InstOutput)	some(27)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_low, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(false)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		15: Option(InstOutput)	some(25)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2194
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: u8	const_int(1, u8)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		15: bool	const_prim(false)
		16: ScalarSize	constructor(lane_size, [5], 3)
		19: Option(InstOutput)	some(35)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2191
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: bool	const_prim(true)
		13: Type	match_some(6)
		14: ScalarSize	constructor(lane_size, [13], 2)
		17: Option(InstOutput)	some(27)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2186
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_low, 5)
		7: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: bool	const_prim(false)
		11: Type	match_tuple(4, 0)
		12: ScalarSize	constructor(lane_size, [11], 2)
		15: Option(InstOutput)	some(25)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2179
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/isa/aarch64/inst.isle line 2576
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		31: ValueRegs	constructor(value_reg, [45], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2175
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(37)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		33: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		36: ValueRegs	constructor(value_reg, [43], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2171
		../../codegen/src/isa/aarch64/inst.isle line 2572
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		24: ValueRegs	constructor(value_reg, [31], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2163
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/isa/aarch64/inst.isle line 2568
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		31: ValueRegs	constructor(value_reg, [45], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2159
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(37)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		33: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		36: ValueRegs	constructor(value_reg, [43], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2155
		../../codegen/src/isa/aarch64/inst.isle line 2564
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		24: ValueRegs	constructor(value_reg, [31], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2148
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/isa/aarch64/inst.isle line 2560
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(32)
		23: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		28: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		31: ValueRegs	constructor(value_reg, [45], 1)
		32: InstOutput	constructor(output, [31], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I8X16)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2144
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(37)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		33: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		36: ValueRegs	constructor(value_reg, [43], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2140
		../../codegen/src/isa/aarch64/inst.isle line 2556
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(25)
		21: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		24: ValueRegs	constructor(value_reg, [31], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2135
		../../codegen/src/isa/aarch64/inst.isle line 2552
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvdemote, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: ScalarSize	make_variant(ScalarSize::Size32, [])
		9: Option(InstOutput)	some(16)
		12: VecRRNarrowOp	make_variant(VecRRNarrowOp::Fcvtn, [])
		15: ValueRegs	constructor(value_reg, [22], 1)
		16: InstOutput	constructor(output, [15], 2)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
	]
	constraints = [
		3:	some
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 3458
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 7)
		9: (MemFlags, Value, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2125
		../../codegen/src/isa/aarch64/inst.isle line 3430
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 8)
		10: (MemFlags, Value, Value, Value)	match_some(9)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 2)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 3)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Type	match_some(6)
		18: MemFlags	match_tuple(10, 0)
		21: Option(InstOutput)	some(31)
		27: WritableReg	constructor(temp_writable_reg, [17], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2120
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Xchg, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xchg)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umax, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2114
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umin, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smax, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2108
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smin, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Eor, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xor)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2102
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Orr, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Or)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2099
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Nand, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Nand)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::And, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::And)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2093
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Sub, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Sub)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2090
		../../codegen/src/isa/aarch64/inst.isle line 3444
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Add, [])
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Add)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2084
		../../codegen/src/isa/aarch64/inst.isle line 2800
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Clr, [])
		13: Value	match_tuple(10, 2)
		14: Type	match_some(6)
		15: Value	match_tuple(10, 3)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Reg	constructor(zero_reg, [], 2)
		19: MemFlags	match_tuple(10, 0)
		22: Option(InstOutput)	some(37)
		26: ALUOp	make_variant(ALUOp::EorNot, [])
		33: WritableReg	constructor(temp_writable_reg, [14], 2)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::And)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		13: Value	match_tuple(10, 2)
		14: Type	match_some(6)
		15: Reg	constructor(zero_reg, [], 1)
		16: Value	match_tuple(10, 3)
		17: Reg	constructor(put_in_reg, [16], 2)
		19: MemFlags	match_tuple(10, 0)
		22: Option(InstOutput)	some(37)
		26: ALUOp	make_variant(ALUOp::Sub, [])
		33: WritableReg	constructor(temp_writable_reg, [14], 2)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Sub)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2076
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Umin, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2072
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Umax, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2068
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Smin, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2064
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Smax, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2060
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Set, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Or)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Eor, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Xor)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2052
		../../codegen/src/isa/aarch64/inst.isle line 3420
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		13: Value	match_tuple(10, 2)
		14: Value	match_tuple(10, 3)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(30)
		26: WritableReg	constructor(temp_writable_reg, [16], 2)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Add)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2045
		../../codegen/src/isa/aarch64/inst.isle line 2354
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value))	extractor(atomic_store, 0)
		4: (MemFlags, Value, Value)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Type	match_some(7)
		9: MemFlags	match_tuple(4, 0)
		10: Reg	constructor(put_in_reg, [5], 1)
		11: Value	match_tuple(4, 2)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(23)
		20: MInst	make_variant(MInst::StoreRelease, [8, 10, 12, 9])
		21: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [20])
		23: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2040
		../../codegen/src/isa/aarch64/inst.isle line 2347
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(atomic_load, 7)
		9: Type	match_some(6)
		10: (MemFlags, Value)	match_some(8)
		11: MemFlags	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		16: Option(InstOutput)	some(25)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3234
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(41)
		24: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		25: (MemFlags, Value, Offset32)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Reg	constructor(put_in_reg, [26], 2)
		28: Offset32	match_tuple(25, 2)
		29: i32	extractor(offset32, 28)
		30: i64	constructor(i32_as_i64, [29], 0)
		31: u64	constructor(i64_as_u64, [30], 0)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		44: Type	const_prim(I64)
		45: ImmExtend	make_variant(ImmExtend::Zero, [])
		46: Reg	constructor(imm, [44, 45, 31], 1)
		51: ALUOp	make_variant(ALUOp::Add, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		24:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3233
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(41)
		24: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		25: (MemFlags, Value, Offset32)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Reg	constructor(put_in_reg, [26], 2)
		28: Offset32	match_tuple(25, 2)
		29: i32	extractor(offset32, 28)
		30: i64	constructor(i32_as_i64, [29], 0)
		31: u64	constructor(i64_as_u64, [30], 0)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		44: Option(Imm12)	extractor(imm12_from_u64, 31)
		45: Type	const_prim(I64)
		46: Imm12	match_some(44)
		51: ALUOp	make_variant(ALUOp::Add, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		24:	some
		44:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3232
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(41)
		24: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		25: (MemFlags, Value, Offset32)	match_some(24)
		26: Value	match_tuple(25, 1)
		27: Reg	constructor(put_in_reg, [26], 2)
		28: Offset32	match_tuple(25, 2)
		29: i32	extractor(offset32, 28)
		30: i64	constructor(i32_as_i64, [29], 0)
		31: u64	constructor(i64_as_u64, [30], 0)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		24:	some
		31:	const_int(0)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2031
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Value)	extractor(ireduce, 9)
		11: Value	match_some(10)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: Option(Imm64)	extractor(iconst, 13)
		15: Imm64	match_some(14)
		16: u64	extractor(u64_from_imm64, 15)
		17: Type	match_tuple(4, 0)
		18: VectorSize	constructor(vector_size, [17], 1)
		19: Reg	constructor(splat_const, [16, 18], 2)
		21: Option(InstOutput)	some(24)
		23: ValueRegs	constructor(value_reg, [19], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2028
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Imm64)	extractor(iconst, 9)
		11: Imm64	match_some(10)
		12: u64	extractor(u64_from_imm64, 11)
		13: Type	match_tuple(4, 0)
		14: VectorSize	constructor(vector_size, [13], 1)
		15: Reg	constructor(splat_const, [12, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2025
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee64)	extractor(f64const, 9)
		11: Ieee64	match_some(10)
		12: u64	extractor(u64_from_ieee64, 11)
		13: Type	match_tuple(4, 0)
		14: VectorSize	constructor(vector_size, [13], 1)
		15: Reg	constructor(splat_const, [12, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2022
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee32)	extractor(f32const, 9)
		11: Ieee32	match_some(10)
		12: u32	extractor(u32_from_ieee32, 11)
		13: u64	constructor(u32_as_u64, [12], 0)
		14: Type	match_tuple(4, 0)
		15: VectorSize	constructor(vector_size, [14], 1)
		16: Reg	constructor(splat_const, [13, 15], 2)
		18: Option(InstOutput)	some(21)
		20: ValueRegs	constructor(value_reg, [16], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2019
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_scalar_float, 8)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: u8	const_int(0, u8)
		16: Option(InstOutput)	some(25)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2015
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	constructor(ty_int_ref_scalar_64, [8], 0)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(23)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2009
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Constant)	extractor(vconst, 5)
		7: Constant	match_some(6)
		8: Option(u64)	extractor(u64_from_constant, 7)
		9: Type	match_tuple(4, 0)
		10: Option(Type)	constructor(ty_vec64, [9], 0)
		11: u64	match_some(8)
		12: Reg	constructor(constant_f64, [11], 1)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(value_reg, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2006
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Constant)	extractor(vconst, 7)
		9: Constant	match_some(8)
		10: Option(u128)	extractor(u128_from_constant, 9)
		11: u128	match_some(10)
		12: Reg	constructor(constant_f128, [11], 1)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(value_reg, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1995
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Type	const_prim(I64)
		12: ValueRegs	constructor(put_in_regs, [8], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [12, 15], 3)
		18: Reg	constructor(zero_reg, [], 5)
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [38, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		26: Option(InstOutput)	some(25)
		30: ALUOp	make_variant(ALUOp::Orr, [])
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: MInst	make_variant(MInst::AluRRR, [35, 10, 36, 45, 18])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1989
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: ALUOp	make_variant(ALUOp::SubS, [])
		29: WritableReg	constructor(writable_zero_reg, [], 1)
		30: MInst	make_variant(MInst::AluRRR, [28, 11, 29, 24, 13])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1989
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [37, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [8], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRR, [34, 11, 35, 44, 13])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		24:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 3842
		../../codegen/src/isa/aarch64/inst.isle line 3846
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [32], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [30, 22, 23, 24, 25], 5)
		27: InstOutput	constructor(output, [26], 8)
		28: Option(InstOutput)	some(27)
		30: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		32: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1964
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Type	const_prim(I64)
		12: ValueRegs	constructor(put_in_regs, [8], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [12, 15], 3)
		18: Reg	constructor(zero_reg, [], 5)
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [38, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		26: Option(InstOutput)	some(25)
		30: ALUOp	make_variant(ALUOp::Orr, [])
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: MInst	make_variant(MInst::AluRRR, [35, 10, 36, 45, 18])
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [37])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1958
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: ALUOp	make_variant(ALUOp::SubS, [])
		29: WritableReg	constructor(writable_zero_reg, [], 1)
		30: MInst	make_variant(MInst::AluRRR, [28, 11, 29, 24, 13])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1958
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [37, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [8], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRR, [34, 11, 35, 44, 13])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		24:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: ALUOp	make_variant(ALUOp::SubS, [])
		29: WritableReg	constructor(writable_zero_reg, [], 1)
		30: MInst	make_variant(MInst::AluRRR, [28, 11, 29, 24, 13])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [31, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Reg	constructor(put_in_reg, [8], 1)
		28: ALUOp	make_variant(ALUOp::SubS, [])
		29: WritableReg	constructor(writable_zero_reg, [], 1)
		30: MInst	make_variant(MInst::AluRRR, [28, 11, 29, 24, 13])
		31: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [30])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		23:	const_prim(I32)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		13: Reg	constructor(zero_reg, [], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [37, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		23: Type	extractor(value_type, 8)
		24: Option(Type)	extractor(fits_in_32, 23)
		25: Reg	constructor(put_in_reg, [8], 1)
		26: bool	const_prim(false)
		27: Type	match_some(24)
		28: u8	constructor(ty_bits, [27], 0)
		29: u8	const_int(32, u8)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRR, [34, 11, 35, 44, 13])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
		24:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Type	const_prim(I32)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [29, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: ALUOp	make_variant(ALUOp::AndS, [])
		27: WritableReg	constructor(writable_zero_reg, [], 2)
		28: MInst	make_variant(MInst::AluRRImmLogic, [25, 32, 27, 11, 13])
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [28])
		31: Option(Type)	extractor(fits_in_64, 10)
		32: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I8)
		31:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Type	const_prim(I32)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [29, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: ALUOp	make_variant(ALUOp::AndS, [])
		27: WritableReg	constructor(writable_zero_reg, [], 2)
		28: MInst	make_variant(MInst::AluRRImmLogic, [25, 32, 27, 11, 13])
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [28])
		31: Option(Type)	extractor(fits_in_32, 10)
		32: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I8)
		31:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1937
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((FloatCC, Value, Value))	extractor(fcmp, 12)
		14: (FloatCC, Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Type	extractor(value_type, 15)
		17: ScalarSize	constructor(scalar_size, [16], 2)
		18: Reg	constructor(put_in_reg, [15], 3)
		19: Value	match_tuple(14, 2)
		20: Reg	constructor(put_in_reg, [19], 4)
		22: FloatCC	match_tuple(14, 0)
		23: Cond	constructor(fp_cond_code, [22], 1)
		24: Type	match_tuple(4, 0)
		25: Value	match_tuple(7, 1)
		26: Value	match_tuple(7, 2)
		27: ValueRegs	constructor(lower_select, [34, 23, 24, 25, 26], 6)
		28: InstOutput	constructor(output, [27], 7)
		29: Option(InstOutput)	some(28)
		33: MInst	make_variant(MInst::FpuCmp, [17, 18, 20])
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [33])
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1924
		../../codegen/src/isa/aarch64/inst.isle line 3842
		../../codegen/src/isa/aarch64/inst.isle line 3846
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [32], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [30, 22, 23, 24, 25], 5)
		27: InstOutput	constructor(output, [26], 6)
		28: Option(InstOutput)	some(27)
		30: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		32: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1919
		../../codegen/src/isa/aarch64/inst.isle line 2816
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(resumable_trap, 0)
		4: TrapCode	match_some(3)
		7: Option(InstOutput)	some(12)
		9: MInst	make_variant(MInst::Udf, [4])
		10: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [9])
		12: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1914
		../../codegen/src/isa/aarch64/inst.isle line 2816
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(trap, 0)
		4: TrapCode	match_some(3)
		7: Option(InstOutput)	some(12)
		9: MInst	make_variant(MInst::Udf, [4])
		10: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [9])
		12: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1909
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((IntCC, Value, Value))	extractor(icmp, 0)
		4: (IntCC, Value, Value)	match_some(3)
		5: IntCC	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: Value	match_tuple(4, 2)
		8: Type	extractor(value_type, 6)
		9: Type	const_prim(I8)
		10: ValueRegs	constructor(lower_icmp_into_reg, [5, 6, 7, 8, 9], 1)
		11: InstOutput	constructor(output, [10], 2)
		12: Option(InstOutput)	some(11)
	]
	constraints = [
		3:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1903
		../../codegen/src/isa/aarch64/inst.isle line 3410
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: IntCC	match_some(11)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [32], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op_swap, [14], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1897
		../../codegen/src/isa/aarch64/inst.isle line 3415
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [41], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1891
		../../codegen/src/isa/aarch64/inst.isle line 3405
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: IntCC	match_tuple(9, 0)
		13: Option(IntCC)	extractor(icmp_zero_cond, 12)
		14: IntCC	match_some(13)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [32], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op, [14], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 3415
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [41], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1879
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	constructor(ty_vector_float, [9], 0)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Value	match_tuple(7, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: FloatCC	match_tuple(7, 0)
		15: Cond	constructor(fp_cond_code, [14], 3)
		16: Reg	constructor(vec_cmp, [11, 13, 9, 15], 4)
		18: Option(InstOutput)	some(21)
		20: ValueRegs	constructor(value_reg, [16], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1874
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(ty_scalar_float, 9)
		11: Type	match_some(10)
		12: ScalarSize	constructor(scalar_size, [11], 1)
		13: Reg	constructor(put_in_reg, [8], 2)
		14: Value	match_tuple(7, 2)
		15: Reg	constructor(put_in_reg, [14], 3)
		17: FloatCC	match_tuple(7, 0)
		18: Cond	constructor(fp_cond_code, [17], 5)
		20: ValueRegs	constructor(with_flags, [27, 33], 7)
		21: InstOutput	constructor(output, [20], 8)
		22: Option(InstOutput)	some(21)
		26: MInst	make_variant(MInst::FpuCmp, [12, 13, 15])
		27: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [26])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::CSet, [30, 18])
		32: Reg	constructor(writable_reg_to_reg, [30], 0)
		33: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [31, 32])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1868
		../../codegen/src/isa/aarch64/inst.isle line 3380
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: FloatCC	match_some(11)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [32], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op_swap, [14], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1862
		../../codegen/src/isa/aarch64/inst.isle line 3385
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [41], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 3375
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: FloatCC	match_tuple(9, 0)
		13: Option(FloatCC)	extractor(fcmp_zero_cond, 12)
		14: FloatCC	match_some(13)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [32], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		25: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op, [14], 1)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1850
		../../codegen/src/isa/aarch64/inst.isle line 3385
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [41], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		24: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		28: VecMisc2	make_variant(VecMisc2::Not, [])
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1844
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ireduce, 7)
		9: Value	match_some(8)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		14: Option(InstOutput)	some(17)
		16: ValueRegs	constructor(value_reg, [12], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1836
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(bitselect, 7)
		9: Type	match_some(6)
		10: (Value, Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 2)
		16: Reg	constructor(put_in_reg, [15], 3)
		19: Option(InstOutput)	some(29)
		24: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		25: VectorSize	constructor(vector_size, [9], 1)
		28: ValueRegs	constructor(value_reg, [37], 1)
		29: InstOutput	constructor(output, [28], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1830
		../../codegen/src/isa/aarch64/inst.isle line 2720
		../../codegen/src/isa/aarch64/inst.isle line 2738
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(bitselect, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: (Value, Value, Value)	match_some(6)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: Reg	constructor(put_in_reg, [12], 5)
		21: Option(InstOutput)	some(39)
		25: ALUOp	make_variant(ALUOp::And, [])
		30: ALUOp	make_variant(ALUOp::AndNot, [])
		35: ALUOp	make_variant(ALUOp::Orr, [])
		38: ValueRegs	constructor(value_reg, [60], 1)
		39: InstOutput	constructor(output, [38], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1825
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Cnt, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1817
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		16: u8	const_int(1, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		19: VectorSize	make_variant(VectorSize::Size8x16, [])
		22: u8	const_int(0, u8)
		23: ScalarSize	make_variant(ScalarSize::Size8, [])
		25: Type	const_prim(I64)
		26: ImmExtend	make_variant(ImmExtend::Zero, [])
		27: u64	const_int(0, u64)
		28: Reg	constructor(imm, [25, 26, 27], 9)
		29: ValueRegs	constructor(value_regs, [57, 28], 10)
		30: InstOutput	constructor(output, [29], 11)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
		41: Type	const_prim(I8X16)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		46: VecMisc2	make_variant(VecMisc2::Cnt, [])
		50: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
		61: Type	const_prim(I8X16)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		67: Type	const_prim(I8X16)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1811
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(41)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		27: VecMisc2	make_variant(VecMisc2::Cnt, [])
		31: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		51: Type	const_prim(I8X16)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1805
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2614
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(41)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		27: VecMisc2	make_variant(VecMisc2::Cnt, [])
		31: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		51: Type	const_prim(I8X16)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1799
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(42)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: Reg	constructor(writable_reg_to_reg, [23], 0)
		27: VecMisc2	make_variant(VecMisc2::Cnt, [])
		32: VecALUOp	make_variant(VecALUOp::Addp, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ValueRegs	constructor(value_reg, [39], 1)
		42: InstOutput	constructor(output, [41], 2)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		53: Type	const_prim(I8X16)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1793
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/isa/aarch64/inst.isle line 2805
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size8, [])
		18: Option(InstOutput)	some(36)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		26: VecMisc2	make_variant(VecMisc2::Cnt, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1771
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bmask, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: ValueRegs	constructor(lower_bmask, [7, 9, 10], 2)
		12: InstOutput	constructor(output, [11], 3)
		13: Option(InstOutput)	some(12)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1763
		../../codegen/src/isa/aarch64/inst.isle line 2795
		../../codegen/src/isa/aarch64/inst.isle line 2795
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		14: ValueRegs	constructor(put_in_regs, [9], 4)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		18: ValueRegs	constructor(value_regs, [34, 40], 7)
		19: InstOutput	constructor(output, [18], 8)
		20: Option(InstOutput)	some(19)
		23: BitOp	make_variant(BitOp::Rev64, [])
		27: BitOp	make_variant(BitOp::Rev64, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1760
		../../codegen/src/isa/aarch64/inst.isle line 2795
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(20)
		16: BitOp	make_variant(BitOp::Rev64, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1757
		../../codegen/src/isa/aarch64/inst.isle line 2792
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(20)
		16: BitOp	make_variant(BitOp::Rev32, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1754
		../../codegen/src/isa/aarch64/inst.isle line 2789
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Type	const_prim(I16)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(20)
		16: BitOp	make_variant(BitOp::Rev16, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1749
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(cls, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		12: Option(InstOutput)	some(19)
		15: BitOp	make_variant(BitOp::Cls, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1735
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2800
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 3)
		14: u8	const_int(63, u8)
		15: Imm12	constructor(u8_into_imm12, [14], 10)
		17: Cond	make_variant(Cond::Eq, [])
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 2)
		22: ImmShift	constructor(imm_shift_from_u8, [14], 7)
		25: Reg	constructor(zero_reg, [], 12)
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	const_int(0, u64)
		31: Reg	constructor(imm, [8, 29, 30], 16)
		32: ValueRegs	constructor(value_regs, [128, 31], 17)
		33: InstOutput	constructor(output, [32], 18)
		34: Option(InstOutput)	some(33)
		37: BitOp	make_variant(BitOp::Cls, [])
		41: OperandSize	make_variant(OperandSize::Size64, [])
		45: BitOp	make_variant(BitOp::Cls, [])
		50: ALUOp	make_variant(ALUOp::EorNot, [])
		55: ALUOp	make_variant(ALUOp::Lsr, [])
		61: ALUOp3	make_variant(ALUOp3::MAdd, [])
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::CSel, [67, 17, 121, 25])
		69: Reg	constructor(writable_reg_to_reg, [67], 0)
		70: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [68, 69])
		73: ValueRegs	constructor(with_flags, [93, 70], 1)
		74: usize	const_int(0, usize)
		75: Reg	constructor(value_regs_get, [73, 74], 2)
		79: ALUOp	make_variant(ALUOp::Add, [])
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: Reg	constructor(writable_reg_to_reg, [85], 0)
		90: ALUOp	make_variant(ALUOp::SubS, [])
		91: WritableReg	constructor(writable_zero_reg, [], 1)
		92: MInst	make_variant(MInst::AluRRImm12, [90, 41, 91, 86, 15])
		93: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [92])
		97: Type	const_prim(I64)
		98: WritableReg	constructor(temp_writable_reg, [97], 1)
		99: Reg	constructor(writable_reg_to_reg, [98], 0)
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: Reg	constructor(writable_reg_to_reg, [105], 0)
		111: Type	const_prim(I64)
		112: WritableReg	constructor(temp_writable_reg, [111], 1)
		113: Reg	constructor(writable_reg_to_reg, [112], 0)
		119: Type	const_prim(I64)
		120: WritableReg	constructor(temp_writable_reg, [119], 1)
		121: Reg	constructor(writable_reg_to_reg, [120], 0)
		126: Type	const_prim(I64)
		127: WritableReg	constructor(temp_writable_reg, [126], 1)
		128: Reg	constructor(writable_reg_to_reg, [127], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 34
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 9)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [9], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Cls, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [57], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Cls, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2784
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 9)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [9], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Cls, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [57], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1715
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(ctz, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		13: Option(InstOutput)	some(24)
		16: BitOp	make_variant(BitOp::RBit, [])
		20: BitOp	make_variant(BitOp::Clz, [])
		23: ValueRegs	constructor(value_reg, [36], 1)
		24: InstOutput	constructor(output, [23], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1709
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/lower.isle line 1691
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 4)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [10, 14], 2)
		17: ValueRegs	constructor(value_regs, [50, 56], 6)
		19: InstOutput	constructor(output, [44], 8)
		20: Option(InstOutput)	some(19)
		23: BitOp	make_variant(BitOp::RBit, [])
		27: BitOp	make_variant(BitOp::RBit, [])
		30: Type	const_prim(I64)
		31: usize	const_int(0, usize)
		32: Reg	constructor(value_regs_get, [17, 31], 3)
		34: usize	const_int(1, usize)
		35: Reg	constructor(value_regs_get, [17, 34], 1)
		37: u8	const_int(6, u8)
		38: ImmShift	constructor(imm_shift_from_u8, [37], 5)
		41: ImmExtend	make_variant(ImmExtend::Zero, [])
		42: u64	const_int(0, u64)
		43: Reg	constructor(imm, [30, 41, 42], 8)
		44: ValueRegs	constructor(value_regs, [102, 43], 9)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
		59: BitOp	make_variant(BitOp::Clz, [])
		63: BitOp	make_variant(BitOp::Clz, [])
		68: ALUOp	make_variant(ALUOp::Lsr, [])
		74: ALUOp3	make_variant(ALUOp3::MAdd, [])
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: Reg	constructor(writable_reg_to_reg, [80], 0)
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: Reg	constructor(writable_reg_to_reg, [86], 0)
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: Reg	constructor(writable_reg_to_reg, [93], 0)
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: Reg	constructor(writable_reg_to_reg, [101], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1706
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2709
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u64	const_int(32768, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [8, 12], 3)
		17: Option(InstOutput)	some(33)
		20: BitOp	make_variant(BitOp::RBit, [])
		25: ALUOp	make_variant(ALUOp::Orr, [])
		29: BitOp	make_variant(BitOp::Clz, [])
		32: ValueRegs	constructor(value_reg, [52], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1703
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2709
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u64	const_int(8388608, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [8, 12], 3)
		17: Option(InstOutput)	some(33)
		20: BitOp	make_variant(BitOp::RBit, [])
		25: ALUOp	make_variant(ALUOp::Orr, [])
		29: BitOp	make_variant(BitOp::Clz, [])
		32: ValueRegs	constructor(value_reg, [52], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1682
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(clz, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		12: Option(InstOutput)	some(19)
		15: BitOp	make_variant(BitOp::Clz, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1679
		../../codegen/src/isa/aarch64/lower.isle line 1691
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		11: InstOutput	constructor(output, [28], 3)
		12: Option(InstOutput)	some(11)
		14: Type	const_prim(I64)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [9, 15], 3)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [9, 18], 1)
		21: u8	const_int(6, u8)
		22: ImmShift	constructor(imm_shift_from_u8, [21], 5)
		25: ImmExtend	make_variant(ImmExtend::Zero, [])
		26: u64	const_int(0, u64)
		27: Reg	constructor(imm, [14, 25, 26], 8)
		28: ValueRegs	constructor(value_regs, [74, 27], 9)
		31: BitOp	make_variant(BitOp::Clz, [])
		35: BitOp	make_variant(BitOp::Clz, [])
		40: ALUOp	make_variant(ALUOp::Lsr, [])
		46: ALUOp3	make_variant(ALUOp3::MAdd, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		72: Type	const_prim(I64)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: Reg	constructor(writable_reg_to_reg, [73], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 9)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [9], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Clz, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [57], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(31)
		18: Type	extractor(value_type, 9)
		19: Reg	constructor(put_in_reg, [9], 1)
		22: BitOp	make_variant(BitOp::Clz, [])
		27: ALUOp	make_variant(ALUOp::Sub, [])
		30: ValueRegs	constructor(value_reg, [44], 1)
		31: InstOutput	constructor(output, [30], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		18:	const_prim(I32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2779
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(37)
		18: Type	extractor(value_type, 9)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [9], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(32, u8)
		28: BitOp	make_variant(BitOp::Clz, [])
		33: ALUOp	make_variant(ALUOp::Sub, [])
		36: ValueRegs	constructor(value_reg, [57], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1667
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bitrev, 5)
		7: Type	match_tuple(4, 0)
		8: Value	match_some(6)
		9: Reg	constructor(put_in_reg, [8], 1)
		12: Option(InstOutput)	some(19)
		15: BitOp	make_variant(BitOp::RBit, [])
		18: ValueRegs	constructor(value_reg, [25], 1)
		19: InstOutput	constructor(output, [18], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1661
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2073
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 4)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [10, 14], 2)
		17: ValueRegs	constructor(value_regs, [33, 39], 6)
		18: InstOutput	constructor(output, [17], 7)
		19: Option(InstOutput)	some(18)
		22: BitOp	make_variant(BitOp::RBit, [])
		26: BitOp	make_variant(BitOp::RBit, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1658
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u8	const_int(16, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		16: Option(InstOutput)	some(28)
		19: BitOp	make_variant(BitOp::RBit, [])
		24: ALUOp	make_variant(ALUOp::Lsr, [])
		27: ValueRegs	constructor(value_reg, [41], 1)
		28: InstOutput	constructor(output, [27], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1652
		../../codegen/src/isa/aarch64/inst.isle line 2774
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Type	const_prim(I32)
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		12: u8	const_int(24, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		16: Option(InstOutput)	some(28)
		19: BitOp	make_variant(BitOp::RBit, [])
		24: ALUOp	make_variant(ALUOp::Lsr, [])
		27: ValueRegs	constructor(value_reg, [41], 1)
		28: InstOutput	constructor(output, [27], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 247, 282])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 247])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 292])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 292, 327])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_64, 34)
		240: OperandSize	make_variant(OperandSize::Size64, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_64, 65)
		285: OperandSize	make_variant(OperandSize::Size64, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 247, 282])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 247])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 292])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 292, 327])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_64, 34)
		240: OperandSize	make_variant(OperandSize::Size64, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_32, 65)
		285: OperandSize	make_variant(OperandSize::Size32, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 247, 282])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 247])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 292])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 292, 327])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_32, 34)
		240: OperandSize	make_variant(OperandSize::Size32, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_64, 65)
		285: OperandSize	make_variant(OperandSize::Size64, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 247, 282])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 247])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 292])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 292, 327])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_32, 34)
		240: OperandSize	make_variant(OperandSize::Size32, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_32, 65)
		285: OperandSize	make_variant(OperandSize::Size32, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 295])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 295, 330])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 295])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 295, 330])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 295])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 295, 330])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsl, [])
		181: Type	const_prim(I64)
		182: WritableReg	constructor(temp_writable_reg, [181], 1)
		183: MInst	make_variant(MInst::CSel, [182, 69, 70, 295])
		184: Reg	constructor(writable_reg_to_reg, [182], 0)
		185: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [183, 184])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::Lsr, [])
		199: ALUOp	make_variant(ALUOp::OrrNot, [])
		204: ALUOp	make_variant(ALUOp::Lsr, [])
		209: ALUOp	make_variant(ALUOp::Orr, [])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 295, 330])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(185, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		185:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 295])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 295, 330])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 295])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 295, 330])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 295])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 295, 330])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 250, 285])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 250])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 295])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 295, 330])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 253, 288])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 253])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 298])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 298, 333])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_64, 34)
		246: OperandSize	make_variant(OperandSize::Size64, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_64, 65)
		291: OperandSize	make_variant(OperandSize::Size64, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 253, 288])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 253])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 298])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 298, 333])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_64, 34)
		246: OperandSize	make_variant(OperandSize::Size64, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_32, 65)
		291: OperandSize	make_variant(OperandSize::Size32, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 253, 288])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 253])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 298])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 298, 333])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_32, 34)
		246: OperandSize	make_variant(OperandSize::Size32, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_64, 65)
		291: OperandSize	make_variant(OperandSize::Size64, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 11)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 12)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 8)
		27: Reg	constructor(value_regs_get, [88, 25], 9)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: usize	const_int(1, usize)
		40: Reg	constructor(value_regs_get, [11, 39], 2)
		42: usize	const_int(0, usize)
		43: Reg	constructor(value_regs_get, [11, 42], 1)
		45: u8	const_int(1, u8)
		46: ImmShift	constructor(imm_shift_from_u8, [45], 7)
		48: Type	const_prim(I32)
		49: Reg	constructor(zero_reg, [], 5)
		54: Reg	constructor(zero_reg, [], 14)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: Reg	constructor(zero_reg, [], 13)
		71: usize	const_int(0, usize)
		72: Reg	constructor(value_regs_get, [11, 71], 1)
		75: usize	const_int(1, usize)
		76: Reg	constructor(value_regs_get, [11, 75], 2)
		78: u8	const_int(1, u8)
		79: ImmShift	constructor(imm_shift_from_u8, [78], 7)
		81: Type	const_prim(I32)
		82: Reg	constructor(zero_reg, [], 5)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsr, [])
		115: ALUOp	make_variant(ALUOp::Lsr, [])
		120: ALUOp	make_variant(ALUOp::Lsl, [])
		125: ALUOp	make_variant(ALUOp::OrrNot, [])
		130: ALUOp	make_variant(ALUOp::Lsl, [])
		135: ALUOp	make_variant(ALUOp::Orr, [])
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: MInst	make_variant(MInst::CSel, [141, 38, 253, 288])
		143: Reg	constructor(writable_reg_to_reg, [141], 0)
		144: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [142, 143])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 54, 253])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(144, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsl, [])
		184: Type	const_prim(I64)
		185: WritableReg	constructor(temp_writable_reg, [184], 1)
		186: MInst	make_variant(MInst::CSel, [185, 69, 70, 298])
		187: Reg	constructor(writable_reg_to_reg, [185], 0)
		188: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [186, 187])
		192: ALUOp	make_variant(ALUOp::Lsl, [])
		197: ALUOp	make_variant(ALUOp::Lsr, [])
		202: ALUOp	make_variant(ALUOp::OrrNot, [])
		207: ALUOp	make_variant(ALUOp::Lsr, [])
		212: ALUOp	make_variant(ALUOp::Orr, [])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 298, 333])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(188, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_32, 34)
		246: OperandSize	make_variant(OperandSize::Size32, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_32, 65)
		291: OperandSize	make_variant(OperandSize::Size32, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		144:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		188:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		21: Option(InstOutput)	some(29)
		25: ALUOp	make_variant(ALUOp::RotR, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1583
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		21: Option(InstOutput)	some(29)
		25: ALUOp	make_variant(ALUOp::RotR, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(36)
		24: Type	extractor(value_type, 17)
		25: Reg	constructor(put_in_reg, [17], 1)
		29: Type	const_prim(I32)
		30: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		35: ValueRegs	constructor(value_reg, [72], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: ALUOp	make_variant(ALUOp::Lsl, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		50: ALUOp	make_variant(ALUOp::Orr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(36)
		24: Type	extractor(value_type, 17)
		25: Reg	constructor(put_in_reg, [17], 1)
		29: Type	const_prim(I32)
		30: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		35: ValueRegs	constructor(value_reg, [72], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: ALUOp	make_variant(ALUOp::Lsl, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		50: ALUOp	make_variant(ALUOp::Orr, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		24:	const_prim(I32)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(42)
		24: Type	extractor(value_type, 17)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [17], 1)
		27: bool	const_prim(false)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(32, u8)
		35: Type	const_prim(I32)
		36: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		41: ValueRegs	constructor(value_reg, [85], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		53: ALUOp	make_variant(ALUOp::Lsl, [])
		58: ALUOp	make_variant(ALUOp::Lsr, [])
		63: ALUOp	make_variant(ALUOp::Orr, [])
		69: Type	const_prim(I64)
		70: WritableReg	constructor(temp_writable_reg, [69], 1)
		71: Reg	constructor(writable_reg_to_reg, [70], 0)
		76: Type	const_prim(I64)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: Reg	constructor(writable_reg_to_reg, [77], 0)
		83: Type	const_prim(I64)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: Reg	constructor(writable_reg_to_reg, [84], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1574
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::RotR, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1570
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: Type	const_prim(I32)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::RotR, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		19: Option(InstOutput)	some(39)
		21: Type	extractor(value_type, 11)
		22: Reg	constructor(put_in_reg, [11], 1)
		26: Type	const_prim(I32)
		27: Reg	constructor(zero_reg, [], 5)
		28: ImmLogic	constructor(rotr_mask, [9], 1)
		30: u8	constructor(ty_bits, [9], 0)
		31: Imm12	constructor(u8_into_imm12, [30], 3)
		38: ValueRegs	constructor(value_reg, [111], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: ALUOp	make_variant(ALUOp::And, [])
		48: ALUOp	make_variant(ALUOp::Sub, [])
		53: ALUOp	make_variant(ALUOp::Sub, [])
		58: ALUOp	make_variant(ALUOp::Lsl, [])
		63: ALUOp	make_variant(ALUOp::Lsr, [])
		68: ALUOp	make_variant(ALUOp::Orr, [])
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		88: Type	const_prim(I64)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: Reg	constructor(writable_reg_to_reg, [89], 0)
		95: Type	const_prim(I64)
		96: WritableReg	constructor(temp_writable_reg, [95], 1)
		97: Reg	constructor(writable_reg_to_reg, [96], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: Reg	constructor(writable_reg_to_reg, [103], 0)
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		19: Option(InstOutput)	some(39)
		21: Type	extractor(value_type, 11)
		22: Reg	constructor(put_in_reg, [11], 1)
		26: Type	const_prim(I32)
		27: Reg	constructor(zero_reg, [], 5)
		28: ImmLogic	constructor(rotr_mask, [9], 1)
		30: u8	constructor(ty_bits, [9], 0)
		31: Imm12	constructor(u8_into_imm12, [30], 3)
		38: ValueRegs	constructor(value_reg, [111], 1)
		39: InstOutput	constructor(output, [38], 2)
		43: ALUOp	make_variant(ALUOp::And, [])
		48: ALUOp	make_variant(ALUOp::Sub, [])
		53: ALUOp	make_variant(ALUOp::Sub, [])
		58: ALUOp	make_variant(ALUOp::Lsl, [])
		63: ALUOp	make_variant(ALUOp::Lsr, [])
		68: ALUOp	make_variant(ALUOp::Orr, [])
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		88: Type	const_prim(I64)
		89: WritableReg	constructor(temp_writable_reg, [88], 1)
		90: Reg	constructor(writable_reg_to_reg, [89], 0)
		95: Type	const_prim(I64)
		96: WritableReg	constructor(temp_writable_reg, [95], 1)
		97: Reg	constructor(writable_reg_to_reg, [96], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: Reg	constructor(writable_reg_to_reg, [103], 0)
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I32)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		19: Option(InstOutput)	some(45)
		21: Type	extractor(value_type, 11)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [11], 1)
		24: bool	const_prim(false)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(32, u8)
		32: Type	const_prim(I32)
		33: Reg	constructor(zero_reg, [], 5)
		34: ImmLogic	constructor(rotr_mask, [9], 1)
		36: u8	constructor(ty_bits, [9], 0)
		37: Imm12	constructor(u8_into_imm12, [36], 3)
		44: ValueRegs	constructor(value_reg, [124], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		56: ALUOp	make_variant(ALUOp::And, [])
		61: ALUOp	make_variant(ALUOp::Sub, [])
		66: ALUOp	make_variant(ALUOp::Sub, [])
		71: ALUOp	make_variant(ALUOp::Lsl, [])
		76: ALUOp	make_variant(ALUOp::Lsr, [])
		81: ALUOp	make_variant(ALUOp::Orr, [])
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: Reg	constructor(writable_reg_to_reg, [88], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: Reg	constructor(writable_reg_to_reg, [95], 0)
		101: Type	const_prim(I64)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: Reg	constructor(writable_reg_to_reg, [102], 0)
		108: Type	const_prim(I64)
		109: WritableReg	constructor(temp_writable_reg, [108], 1)
		110: Reg	constructor(writable_reg_to_reg, [109], 0)
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: Reg	constructor(writable_reg_to_reg, [116], 0)
		122: Type	const_prim(I64)
		123: WritableReg	constructor(temp_writable_reg, [122], 1)
		124: Reg	constructor(writable_reg_to_reg, [123], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 247])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 247, 282])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 292, 327])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 292])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_64, 34)
		240: OperandSize	make_variant(OperandSize::Size64, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_64, 65)
		285: OperandSize	make_variant(OperandSize::Size64, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 247])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 247, 282])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 292, 327])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 292])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_64, 34)
		240: OperandSize	make_variant(OperandSize::Size64, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_32, 65)
		285: OperandSize	make_variant(OperandSize::Size32, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 247])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 247, 282])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 292, 327])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 292])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_32, 34)
		240: OperandSize	make_variant(OperandSize::Size32, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_64, 65)
		285: OperandSize	make_variant(OperandSize::Size64, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [230, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 223], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 240, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 247])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 247, 282])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 285, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 292, 327])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 292])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		223: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [221, 222])
		228: Type	const_prim(I64)
		229: WritableReg	constructor(temp_writable_reg, [228], 1)
		230: Reg	constructor(writable_reg_to_reg, [229], 0)
		235: Type	const_prim(I64)
		236: WritableReg	constructor(temp_writable_reg, [235], 1)
		237: Reg	constructor(writable_reg_to_reg, [236], 0)
		239: Option(Type)	extractor(fits_in_32, 34)
		240: OperandSize	make_variant(OperandSize::Size32, [])
		245: Type	const_prim(I64)
		246: WritableReg	constructor(temp_writable_reg, [245], 1)
		247: Reg	constructor(writable_reg_to_reg, [246], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: Reg	constructor(writable_reg_to_reg, [253], 0)
		259: Type	const_prim(I64)
		260: WritableReg	constructor(temp_writable_reg, [259], 1)
		261: Reg	constructor(writable_reg_to_reg, [260], 0)
		266: Type	const_prim(I64)
		267: WritableReg	constructor(temp_writable_reg, [266], 1)
		268: Reg	constructor(writable_reg_to_reg, [267], 0)
		273: Type	const_prim(I64)
		274: WritableReg	constructor(temp_writable_reg, [273], 1)
		275: Reg	constructor(writable_reg_to_reg, [274], 0)
		280: Type	const_prim(I64)
		281: WritableReg	constructor(temp_writable_reg, [280], 1)
		282: Reg	constructor(writable_reg_to_reg, [281], 0)
		284: Option(Type)	extractor(fits_in_32, 65)
		285: OperandSize	make_variant(OperandSize::Size32, [])
		290: Type	const_prim(I64)
		291: WritableReg	constructor(temp_writable_reg, [290], 1)
		292: Reg	constructor(writable_reg_to_reg, [291], 0)
		297: Type	const_prim(I64)
		298: WritableReg	constructor(temp_writable_reg, [297], 1)
		299: Reg	constructor(writable_reg_to_reg, [298], 0)
		304: Type	const_prim(I64)
		305: WritableReg	constructor(temp_writable_reg, [304], 1)
		306: Reg	constructor(writable_reg_to_reg, [305], 0)
		311: Type	const_prim(I64)
		312: WritableReg	constructor(temp_writable_reg, [311], 1)
		313: Reg	constructor(writable_reg_to_reg, [312], 0)
		318: Type	const_prim(I64)
		319: WritableReg	constructor(temp_writable_reg, [318], 1)
		320: Reg	constructor(writable_reg_to_reg, [319], 0)
		325: Type	const_prim(I64)
		326: WritableReg	constructor(temp_writable_reg, [325], 1)
		327: Reg	constructor(writable_reg_to_reg, [326], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		218:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		239:	some
		284:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 295, 330])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 295])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 295, 330])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 295])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 295, 330])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 295])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 157], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [172, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		157: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [155, 156])
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
		168: ALUOp	make_variant(ALUOp::AndS, [])
		170: WritableReg	constructor(writable_zero_reg, [], 2)
		171: MInst	make_variant(MInst::AluRRImmLogic, [168, 288, 170, 164, 67])
		172: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [171])
		176: ALUOp	make_variant(ALUOp::Lsr, [])
		181: ALUOp	make_variant(ALUOp::Lsr, [])
		186: ALUOp	make_variant(ALUOp::Lsl, [])
		191: ALUOp	make_variant(ALUOp::OrrNot, [])
		196: ALUOp	make_variant(ALUOp::Lsl, [])
		201: ALUOp	make_variant(ALUOp::Orr, [])
		206: Type	const_prim(I64)
		207: WritableReg	constructor(temp_writable_reg, [206], 1)
		208: MInst	make_variant(MInst::CSel, [207, 69, 295, 330])
		209: Reg	constructor(writable_reg_to_reg, [207], 0)
		210: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [208, 209])
		214: Type	const_prim(I64)
		215: WritableReg	constructor(temp_writable_reg, [214], 1)
		216: MInst	make_variant(MInst::CSel, [215, 69, 85, 295])
		217: Reg	constructor(writable_reg_to_reg, [215], 0)
		218: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [216, 217])
		221: MInst	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		222: MInst	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		223: Reg	match_variant(210, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		224: Reg	match_variant(218, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		225: ValueRegs	constructor(value_regs, [223, 224], 1)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [221, 222, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		152:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		210:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		218:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 295, 330])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 295])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 295, 330])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 295])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_64, 34)
		243: OperandSize	make_variant(OperandSize::Size64, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 295, 330])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 295])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_64, 65)
		288: OperandSize	make_variant(OperandSize::Size64, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [233, 240], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 226], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 243, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 250])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 250, 285])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 288, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 295, 330])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 295])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		226: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [224, 225])
		231: Type	const_prim(I64)
		232: WritableReg	constructor(temp_writable_reg, [231], 1)
		233: Reg	constructor(writable_reg_to_reg, [232], 0)
		238: Type	const_prim(I64)
		239: WritableReg	constructor(temp_writable_reg, [238], 1)
		240: Reg	constructor(writable_reg_to_reg, [239], 0)
		242: Option(Type)	extractor(fits_in_32, 34)
		243: OperandSize	make_variant(OperandSize::Size32, [])
		248: Type	const_prim(I64)
		249: WritableReg	constructor(temp_writable_reg, [248], 1)
		250: Reg	constructor(writable_reg_to_reg, [249], 0)
		255: Type	const_prim(I64)
		256: WritableReg	constructor(temp_writable_reg, [255], 1)
		257: Reg	constructor(writable_reg_to_reg, [256], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: Reg	constructor(writable_reg_to_reg, [263], 0)
		269: Type	const_prim(I64)
		270: WritableReg	constructor(temp_writable_reg, [269], 1)
		271: Reg	constructor(writable_reg_to_reg, [270], 0)
		276: Type	const_prim(I64)
		277: WritableReg	constructor(temp_writable_reg, [276], 1)
		278: Reg	constructor(writable_reg_to_reg, [277], 0)
		283: Type	const_prim(I64)
		284: WritableReg	constructor(temp_writable_reg, [283], 1)
		285: Reg	constructor(writable_reg_to_reg, [284], 0)
		287: Option(Type)	extractor(fits_in_32, 65)
		288: OperandSize	make_variant(OperandSize::Size32, [])
		293: Type	const_prim(I64)
		294: WritableReg	constructor(temp_writable_reg, [293], 1)
		295: Reg	constructor(writable_reg_to_reg, [294], 0)
		300: Type	const_prim(I64)
		301: WritableReg	constructor(temp_writable_reg, [300], 1)
		302: Reg	constructor(writable_reg_to_reg, [301], 0)
		307: Type	const_prim(I64)
		308: WritableReg	constructor(temp_writable_reg, [307], 1)
		309: Reg	constructor(writable_reg_to_reg, [308], 0)
		314: Type	const_prim(I64)
		315: WritableReg	constructor(temp_writable_reg, [314], 1)
		316: Reg	constructor(writable_reg_to_reg, [315], 0)
		321: Type	const_prim(I64)
		322: WritableReg	constructor(temp_writable_reg, [321], 1)
		323: Reg	constructor(writable_reg_to_reg, [322], 0)
		328: Type	const_prim(I64)
		329: WritableReg	constructor(temp_writable_reg, [328], 1)
		330: Reg	constructor(writable_reg_to_reg, [329], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		221:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		242:	some
		287:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 253])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 253, 288])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 298, 333])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 298])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_64, 34)
		246: OperandSize	make_variant(OperandSize::Size64, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_64, 65)
		291: OperandSize	make_variant(OperandSize::Size64, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 253])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 253, 288])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 298, 333])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 298])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_64, 34)
		246: OperandSize	make_variant(OperandSize::Size64, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_32, 65)
		291: OperandSize	make_variant(OperandSize::Size32, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 253])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 253, 288])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 298, 333])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 298])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_32, 34)
		246: OperandSize	make_variant(OperandSize::Size32, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_64, 65)
		291: OperandSize	make_variant(OperandSize::Size64, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		17: Reg	constructor(value_regs_get, [57, 14], 8)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		19: u64	const_int(128, u64)
		20: Reg	constructor(imm, [8, 18, 19], 4)
		23: Reg	constructor(value_regs_get, [88, 14], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [57, 25], 11)
		27: Reg	constructor(value_regs_get, [88, 25], 12)
		29: ValueRegs	constructor(value_regs, [236, 243], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		34: Type	const_prim(I64)
		35: u64	const_int(64, u64)
		36: ImmLogic	constructor(u64_into_imm_logic, [34, 35], 11)
		38: Cond	make_variant(Cond::Ne, [])
		39: Reg	constructor(zero_reg, [], 13)
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [11, 40], 1)
		44: usize	const_int(1, usize)
		45: Reg	constructor(value_regs_get, [11, 44], 2)
		47: u8	const_int(1, u8)
		48: ImmShift	constructor(imm_shift_from_u8, [47], 7)
		50: Type	const_prim(I32)
		51: Reg	constructor(zero_reg, [], 5)
		57: ValueRegs	constructor(with_flags, [106, 160], 17)
		61: ALUOp	make_variant(ALUOp::Sub, [])
		65: Type	const_prim(I64)
		66: u64	const_int(64, u64)
		67: ImmLogic	constructor(u64_into_imm_logic, [65, 66], 11)
		69: Cond	make_variant(Cond::Ne, [])
		70: usize	const_int(1, usize)
		71: Reg	constructor(value_regs_get, [11, 70], 2)
		73: usize	const_int(0, usize)
		74: Reg	constructor(value_regs_get, [11, 73], 1)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		79: Type	const_prim(I32)
		80: Reg	constructor(zero_reg, [], 5)
		85: Reg	constructor(zero_reg, [], 14)
		88: ValueRegs	constructor(with_flags, [175, 229], 17)
		92: ALUOp	make_variant(ALUOp::Orr, [])
		97: ALUOp	make_variant(ALUOp::Orr, [])
		102: ALUOp	make_variant(ALUOp::AndS, [])
		104: WritableReg	constructor(writable_zero_reg, [], 2)
		105: MInst	make_variant(MInst::AluRRImmLogic, [102, 246, 104, 15, 36])
		106: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [105])
		110: ALUOp	make_variant(ALUOp::Lsl, [])
		115: Type	const_prim(I64)
		116: WritableReg	constructor(temp_writable_reg, [115], 1)
		117: MInst	make_variant(MInst::CSel, [116, 38, 39, 253])
		118: Reg	constructor(writable_reg_to_reg, [116], 0)
		119: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [117, 118])
		123: ALUOp	make_variant(ALUOp::Lsl, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::OrrNot, [])
		138: ALUOp	make_variant(ALUOp::Lsr, [])
		143: ALUOp	make_variant(ALUOp::Orr, [])
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: MInst	make_variant(MInst::CSel, [149, 38, 253, 288])
		151: Reg	constructor(writable_reg_to_reg, [149], 0)
		152: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [150, 151])
		155: MInst	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		156: MInst	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		157: Reg	match_variant(119, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		158: Reg	match_variant(152, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		159: ValueRegs	constructor(value_regs, [157, 158], 1)
		160: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [155, 156, 159])
		165: Type	const_prim(I64)
		166: WritableReg	constructor(temp_writable_reg, [165], 1)
		167: Reg	constructor(writable_reg_to_reg, [166], 0)
		171: ALUOp	make_variant(ALUOp::AndS, [])
		173: WritableReg	constructor(writable_zero_reg, [], 2)
		174: MInst	make_variant(MInst::AluRRImmLogic, [171, 291, 173, 167, 67])
		175: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [174])
		179: ALUOp	make_variant(ALUOp::Lsr, [])
		184: ALUOp	make_variant(ALUOp::Lsr, [])
		189: ALUOp	make_variant(ALUOp::Lsl, [])
		194: ALUOp	make_variant(ALUOp::OrrNot, [])
		199: ALUOp	make_variant(ALUOp::Lsl, [])
		204: ALUOp	make_variant(ALUOp::Orr, [])
		209: Type	const_prim(I64)
		210: WritableReg	constructor(temp_writable_reg, [209], 1)
		211: MInst	make_variant(MInst::CSel, [210, 69, 298, 333])
		212: Reg	constructor(writable_reg_to_reg, [210], 0)
		213: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [211, 212])
		217: Type	const_prim(I64)
		218: WritableReg	constructor(temp_writable_reg, [217], 1)
		219: MInst	make_variant(MInst::CSel, [218, 69, 85, 298])
		220: Reg	constructor(writable_reg_to_reg, [218], 0)
		221: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [219, 220])
		224: MInst	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		225: MInst	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		226: Reg	match_variant(213, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		227: Reg	match_variant(221, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		228: ValueRegs	constructor(value_regs, [226, 227], 1)
		229: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [224, 225, 228])
		234: Type	const_prim(I64)
		235: WritableReg	constructor(temp_writable_reg, [234], 1)
		236: Reg	constructor(writable_reg_to_reg, [235], 0)
		241: Type	const_prim(I64)
		242: WritableReg	constructor(temp_writable_reg, [241], 1)
		243: Reg	constructor(writable_reg_to_reg, [242], 0)
		245: Option(Type)	extractor(fits_in_32, 34)
		246: OperandSize	make_variant(OperandSize::Size32, [])
		251: Type	const_prim(I64)
		252: WritableReg	constructor(temp_writable_reg, [251], 1)
		253: Reg	constructor(writable_reg_to_reg, [252], 0)
		258: Type	const_prim(I64)
		259: WritableReg	constructor(temp_writable_reg, [258], 1)
		260: Reg	constructor(writable_reg_to_reg, [259], 0)
		265: Type	const_prim(I64)
		266: WritableReg	constructor(temp_writable_reg, [265], 1)
		267: Reg	constructor(writable_reg_to_reg, [266], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: Reg	constructor(writable_reg_to_reg, [273], 0)
		279: Type	const_prim(I64)
		280: WritableReg	constructor(temp_writable_reg, [279], 1)
		281: Reg	constructor(writable_reg_to_reg, [280], 0)
		286: Type	const_prim(I64)
		287: WritableReg	constructor(temp_writable_reg, [286], 1)
		288: Reg	constructor(writable_reg_to_reg, [287], 0)
		290: Option(Type)	extractor(fits_in_32, 65)
		291: OperandSize	make_variant(OperandSize::Size32, [])
		296: Type	const_prim(I64)
		297: WritableReg	constructor(temp_writable_reg, [296], 1)
		298: Reg	constructor(writable_reg_to_reg, [297], 0)
		303: Type	const_prim(I64)
		304: WritableReg	constructor(temp_writable_reg, [303], 1)
		305: Reg	constructor(writable_reg_to_reg, [304], 0)
		310: Type	const_prim(I64)
		311: WritableReg	constructor(temp_writable_reg, [310], 1)
		312: Reg	constructor(writable_reg_to_reg, [311], 0)
		317: Type	const_prim(I64)
		318: WritableReg	constructor(temp_writable_reg, [317], 1)
		319: Reg	constructor(writable_reg_to_reg, [318], 0)
		324: Type	const_prim(I64)
		325: WritableReg	constructor(temp_writable_reg, [324], 1)
		326: Reg	constructor(writable_reg_to_reg, [325], 0)
		331: Type	const_prim(I64)
		332: WritableReg	constructor(temp_writable_reg, [331], 1)
		333: Reg	constructor(writable_reg_to_reg, [332], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		119:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		152:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		213:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		221:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		245:	some
		290:	some
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1543
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		22: Option(InstOutput)	some(30)
		26: ALUOp	make_variant(ALUOp::RotR, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1538
		../../codegen/src/isa/aarch64/inst.isle line 2769
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		22: Option(InstOutput)	some(30)
		26: ALUOp	make_variant(ALUOp::RotR, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1532
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 5)
		12: Reg	constructor(zero_reg, [], 3)
		13: Value	match_tuple(9, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 1)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 2)
		20: Option(InstOutput)	some(33)
		24: ALUOp	make_variant(ALUOp::Sub, [])
		29: ALUOp	make_variant(ALUOp::RotR, [])
		32: ValueRegs	constructor(value_reg, [47], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1526
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2766
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: Type	const_prim(I32)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 5)
		12: Reg	constructor(zero_reg, [], 3)
		13: Value	match_tuple(9, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 1)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 2)
		20: Option(InstOutput)	some(33)
		24: ALUOp	make_variant(ALUOp::Sub, [])
		29: ALUOp	make_variant(ALUOp::RotR, [])
		32: ValueRegs	constructor(value_reg, [47], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(37)
		25: Type	extractor(value_type, 17)
		26: Reg	constructor(put_in_reg, [17], 1)
		30: Type	const_prim(I32)
		31: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		36: ValueRegs	constructor(value_reg, [73], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: ALUOp	make_variant(ALUOp::Lsl, [])
		46: ALUOp	make_variant(ALUOp::Lsr, [])
		51: ALUOp	make_variant(ALUOp::Orr, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	const_prim(I64)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(37)
		25: Type	extractor(value_type, 17)
		26: Reg	constructor(put_in_reg, [17], 1)
		30: Type	const_prim(I32)
		31: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		36: ValueRegs	constructor(value_reg, [73], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: ALUOp	make_variant(ALUOp::Lsl, [])
		46: ALUOp	make_variant(ALUOp::Lsr, [])
		51: ALUOp	make_variant(ALUOp::Orr, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		25:	const_prim(I32)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/lower.isle line 1626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(43)
		25: Type	extractor(value_type, 17)
		26: Option(Type)	extractor(fits_in_32, 25)
		27: Reg	constructor(put_in_reg, [17], 1)
		28: bool	const_prim(false)
		29: Type	match_some(26)
		30: u8	constructor(ty_bits, [29], 0)
		31: u8	const_int(32, u8)
		36: Type	const_prim(I32)
		37: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		42: ValueRegs	constructor(value_reg, [86], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		54: ALUOp	make_variant(ALUOp::Lsl, [])
		59: ALUOp	make_variant(ALUOp::Lsr, [])
		64: ALUOp	make_variant(ALUOp::Orr, [])
		70: Type	const_prim(I64)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		77: Type	const_prim(I64)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
		84: Type	const_prim(I64)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: Reg	constructor(writable_reg_to_reg, [85], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		26:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Type	const_prim(I32)
		14: Reg	constructor(zero_reg, [], 3)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 1)
		17: usize	const_int(0, usize)
		18: Reg	constructor(value_regs_get, [16, 17], 2)
		22: Option(InstOutput)	some(47)
		24: Type	extractor(value_type, 11)
		25: Reg	constructor(put_in_reg, [11], 1)
		29: ALUOp	make_variant(ALUOp::Sub, [])
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		36: ImmLogic	constructor(rotr_mask, [9], 1)
		38: u8	constructor(ty_bits, [9], 0)
		39: Imm12	constructor(u8_into_imm12, [38], 3)
		46: ValueRegs	constructor(value_reg, [126], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		58: ALUOp	make_variant(ALUOp::And, [])
		63: ALUOp	make_variant(ALUOp::Sub, [])
		68: ALUOp	make_variant(ALUOp::Sub, [])
		73: ALUOp	make_variant(ALUOp::Lsl, [])
		78: ALUOp	make_variant(ALUOp::Lsr, [])
		83: ALUOp	make_variant(ALUOp::Orr, [])
		89: Type	const_prim(I64)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: Reg	constructor(writable_reg_to_reg, [90], 0)
		96: Type	const_prim(I64)
		97: WritableReg	constructor(temp_writable_reg, [96], 1)
		98: Reg	constructor(writable_reg_to_reg, [97], 0)
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: Reg	constructor(writable_reg_to_reg, [104], 0)
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Type	const_prim(I32)
		14: Reg	constructor(zero_reg, [], 3)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 1)
		17: usize	const_int(0, usize)
		18: Reg	constructor(value_regs_get, [16, 17], 2)
		22: Option(InstOutput)	some(47)
		24: Type	extractor(value_type, 11)
		25: Reg	constructor(put_in_reg, [11], 1)
		29: ALUOp	make_variant(ALUOp::Sub, [])
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		36: ImmLogic	constructor(rotr_mask, [9], 1)
		38: u8	constructor(ty_bits, [9], 0)
		39: Imm12	constructor(u8_into_imm12, [38], 3)
		46: ValueRegs	constructor(value_reg, [126], 1)
		47: InstOutput	constructor(output, [46], 2)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
		58: ALUOp	make_variant(ALUOp::And, [])
		63: ALUOp	make_variant(ALUOp::Sub, [])
		68: ALUOp	make_variant(ALUOp::Sub, [])
		73: ALUOp	make_variant(ALUOp::Lsl, [])
		78: ALUOp	make_variant(ALUOp::Lsr, [])
		83: ALUOp	make_variant(ALUOp::Orr, [])
		89: Type	const_prim(I64)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: Reg	constructor(writable_reg_to_reg, [90], 0)
		96: Type	const_prim(I64)
		97: WritableReg	constructor(temp_writable_reg, [96], 1)
		98: Reg	constructor(writable_reg_to_reg, [97], 0)
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: Reg	constructor(writable_reg_to_reg, [104], 0)
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I32)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Type	const_prim(I32)
		14: Reg	constructor(zero_reg, [], 3)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 1)
		17: usize	const_int(0, usize)
		18: Reg	constructor(value_regs_get, [16, 17], 2)
		22: Option(InstOutput)	some(53)
		24: Type	extractor(value_type, 11)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [11], 1)
		27: bool	const_prim(false)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(32, u8)
		35: ALUOp	make_variant(ALUOp::Sub, [])
		40: Type	const_prim(I32)
		41: Reg	constructor(zero_reg, [], 5)
		42: ImmLogic	constructor(rotr_mask, [9], 1)
		44: u8	constructor(ty_bits, [9], 0)
		45: Imm12	constructor(u8_into_imm12, [44], 3)
		52: ValueRegs	constructor(value_reg, [139], 1)
		53: InstOutput	constructor(output, [52], 2)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: Reg	constructor(writable_reg_to_reg, [66], 0)
		71: ALUOp	make_variant(ALUOp::And, [])
		76: ALUOp	make_variant(ALUOp::Sub, [])
		81: ALUOp	make_variant(ALUOp::Sub, [])
		86: ALUOp	make_variant(ALUOp::Lsl, [])
		91: ALUOp	make_variant(ALUOp::Lsr, [])
		96: ALUOp	make_variant(ALUOp::Orr, [])
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: Reg	constructor(writable_reg_to_reg, [103], 0)
		109: Type	const_prim(I64)
		110: WritableReg	constructor(temp_writable_reg, [109], 1)
		111: Reg	constructor(writable_reg_to_reg, [110], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: Reg	constructor(writable_reg_to_reg, [117], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: Reg	constructor(writable_reg_to_reg, [124], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: Reg	constructor(writable_reg_to_reg, [131], 0)
		137: Type	const_prim(I64)
		138: WritableReg	constructor(temp_writable_reg, [137], 1)
		139: Reg	constructor(writable_reg_to_reg, [138], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1471
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		20: Option(InstOutput)	some(23)
		22: ValueRegs	constructor(put_in_regs, [18], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
		../../codegen/src/isa/aarch64/inst.isle line 2761
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: Imm64	match_some(13)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: VectorSize	constructor(vector_size, [16], 2)
		23: Option(InstOutput)	some(31)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		30: ValueRegs	constructor(value_reg, [38], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1464
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/isa/aarch64/inst.isle line 2745
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 8)
		12: Type	const_prim(I64)
		13: Reg	constructor(zero_reg, [], 5)
		14: Type	const_prim(I32)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(6)
		18: ImmLogic	constructor(shift_mask, [17], 3)
		21: VectorSize	constructor(vector_size, [17], 1)
		25: Option(InstOutput)	some(48)
		29: ALUOp	make_variant(ALUOp::And, [])
		34: ALUOp	make_variant(ALUOp::Sub, [])
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: VecALUOp	make_variant(VecALUOp::Sshl, [])
		47: ValueRegs	constructor(value_reg, [69], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I8X16)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [45], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 13)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: u8	const_int(63, u8)
		41: ImmShift	constructor(imm_shift_from_u8, [40], 10)
		45: ValueRegs	constructor(with_flags, [53, 109], 18)
		49: ALUOp	make_variant(ALUOp::AndS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 2)
		52: MInst	make_variant(MInst::AluRRImmLogic, [49, 112, 51, 14, 22])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		57: ALUOp	make_variant(ALUOp::Asr, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::OrrNot, [])
		77: ALUOp	make_variant(ALUOp::Lsl, [])
		82: ALUOp	make_variant(ALUOp::Orr, [])
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: MInst	make_variant(MInst::CSel, [88, 24, 119, 154])
		90: Reg	constructor(writable_reg_to_reg, [88], 0)
		91: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [89, 90])
		95: ALUOp	make_variant(ALUOp::Asr, [])
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: MInst	make_variant(MInst::CSel, [101, 24, 161, 119])
		103: Reg	constructor(writable_reg_to_reg, [101], 0)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [102, 103])
		107: MInst	match_variant(91, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		108: MInst	match_variant(104, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		109: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [107, 108])
		111: Option(Type)	extractor(fits_in_64, 20)
		112: OperandSize	make_variant(OperandSize::Size64, [])
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
		131: Type	const_prim(I64)
		132: WritableReg	constructor(temp_writable_reg, [131], 1)
		133: Reg	constructor(writable_reg_to_reg, [132], 0)
		138: Type	const_prim(I64)
		139: WritableReg	constructor(temp_writable_reg, [138], 1)
		140: Reg	constructor(writable_reg_to_reg, [139], 0)
		145: Type	const_prim(I64)
		146: WritableReg	constructor(temp_writable_reg, [145], 1)
		147: Reg	constructor(writable_reg_to_reg, [146], 0)
		152: Type	const_prim(I64)
		153: WritableReg	constructor(temp_writable_reg, [152], 1)
		154: Reg	constructor(writable_reg_to_reg, [153], 0)
		159: Type	const_prim(I64)
		160: WritableReg	constructor(temp_writable_reg, [159], 1)
		161: Reg	constructor(writable_reg_to_reg, [160], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		91:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		104:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		111:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [45], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 13)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: u8	const_int(63, u8)
		41: ImmShift	constructor(imm_shift_from_u8, [40], 10)
		45: ValueRegs	constructor(with_flags, [53, 109], 18)
		49: ALUOp	make_variant(ALUOp::AndS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 2)
		52: MInst	make_variant(MInst::AluRRImmLogic, [49, 112, 51, 14, 22])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		57: ALUOp	make_variant(ALUOp::Asr, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::OrrNot, [])
		77: ALUOp	make_variant(ALUOp::Lsl, [])
		82: ALUOp	make_variant(ALUOp::Orr, [])
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: MInst	make_variant(MInst::CSel, [88, 24, 119, 154])
		90: Reg	constructor(writable_reg_to_reg, [88], 0)
		91: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [89, 90])
		95: ALUOp	make_variant(ALUOp::Asr, [])
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: MInst	make_variant(MInst::CSel, [101, 24, 161, 119])
		103: Reg	constructor(writable_reg_to_reg, [101], 0)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [102, 103])
		107: MInst	match_variant(91, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		108: MInst	match_variant(104, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		109: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [107, 108])
		111: Option(Type)	extractor(fits_in_32, 20)
		112: OperandSize	make_variant(OperandSize::Size32, [])
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
		131: Type	const_prim(I64)
		132: WritableReg	constructor(temp_writable_reg, [131], 1)
		133: Reg	constructor(writable_reg_to_reg, [132], 0)
		138: Type	const_prim(I64)
		139: WritableReg	constructor(temp_writable_reg, [138], 1)
		140: Reg	constructor(writable_reg_to_reg, [139], 0)
		145: Type	const_prim(I64)
		146: WritableReg	constructor(temp_writable_reg, [145], 1)
		147: Reg	constructor(writable_reg_to_reg, [146], 0)
		152: Type	const_prim(I64)
		153: WritableReg	constructor(temp_writable_reg, [152], 1)
		154: Reg	constructor(writable_reg_to_reg, [153], 0)
		159: Type	const_prim(I64)
		160: WritableReg	constructor(temp_writable_reg, [159], 1)
		161: Reg	constructor(writable_reg_to_reg, [160], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		91:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		104:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		111:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [45], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 13)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: u8	const_int(63, u8)
		41: ImmShift	constructor(imm_shift_from_u8, [40], 10)
		45: ValueRegs	constructor(with_flags, [53, 112], 18)
		49: ALUOp	make_variant(ALUOp::AndS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 2)
		52: MInst	make_variant(MInst::AluRRImmLogic, [49, 115, 51, 14, 22])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		57: ALUOp	make_variant(ALUOp::Asr, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::OrrNot, [])
		77: ALUOp	make_variant(ALUOp::Lsl, [])
		82: ALUOp	make_variant(ALUOp::Orr, [])
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: MInst	make_variant(MInst::CSel, [88, 24, 122, 157])
		90: Reg	constructor(writable_reg_to_reg, [88], 0)
		91: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [89, 90])
		95: ALUOp	make_variant(ALUOp::Asr, [])
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: MInst	make_variant(MInst::CSel, [101, 24, 164, 122])
		103: Reg	constructor(writable_reg_to_reg, [101], 0)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [102, 103])
		107: MInst	match_variant(91, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		108: MInst	match_variant(104, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		109: Reg	match_variant(91, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		110: Reg	match_variant(104, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		111: ValueRegs	constructor(value_regs, [109, 110], 1)
		112: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [107, 108, 111])
		114: Option(Type)	extractor(fits_in_64, 20)
		115: OperandSize	make_variant(OperandSize::Size64, [])
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: Reg	constructor(writable_reg_to_reg, [121], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: Reg	constructor(writable_reg_to_reg, [128], 0)
		134: Type	const_prim(I64)
		135: WritableReg	constructor(temp_writable_reg, [134], 1)
		136: Reg	constructor(writable_reg_to_reg, [135], 0)
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: Reg	constructor(writable_reg_to_reg, [142], 0)
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: Reg	constructor(writable_reg_to_reg, [149], 0)
		155: Type	const_prim(I64)
		156: WritableReg	constructor(temp_writable_reg, [155], 1)
		157: Reg	constructor(writable_reg_to_reg, [156], 0)
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		91:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		104:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		114:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [45], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 13)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: u8	const_int(63, u8)
		41: ImmShift	constructor(imm_shift_from_u8, [40], 10)
		45: ValueRegs	constructor(with_flags, [53, 112], 18)
		49: ALUOp	make_variant(ALUOp::AndS, [])
		51: WritableReg	constructor(writable_zero_reg, [], 2)
		52: MInst	make_variant(MInst::AluRRImmLogic, [49, 115, 51, 14, 22])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		57: ALUOp	make_variant(ALUOp::Asr, [])
		62: ALUOp	make_variant(ALUOp::Lsr, [])
		67: ALUOp	make_variant(ALUOp::Lsl, [])
		72: ALUOp	make_variant(ALUOp::OrrNot, [])
		77: ALUOp	make_variant(ALUOp::Lsl, [])
		82: ALUOp	make_variant(ALUOp::Orr, [])
		87: Type	const_prim(I64)
		88: WritableReg	constructor(temp_writable_reg, [87], 1)
		89: MInst	make_variant(MInst::CSel, [88, 24, 122, 157])
		90: Reg	constructor(writable_reg_to_reg, [88], 0)
		91: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [89, 90])
		95: ALUOp	make_variant(ALUOp::Asr, [])
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: MInst	make_variant(MInst::CSel, [101, 24, 164, 122])
		103: Reg	constructor(writable_reg_to_reg, [101], 0)
		104: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [102, 103])
		107: MInst	match_variant(91, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		108: MInst	match_variant(104, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		109: Reg	match_variant(91, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		110: Reg	match_variant(104, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		111: ValueRegs	constructor(value_regs, [109, 110], 1)
		112: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [107, 108, 111])
		114: Option(Type)	extractor(fits_in_32, 20)
		115: OperandSize	make_variant(OperandSize::Size32, [])
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: Reg	constructor(writable_reg_to_reg, [121], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: Reg	constructor(writable_reg_to_reg, [128], 0)
		134: Type	const_prim(I64)
		135: WritableReg	constructor(temp_writable_reg, [134], 1)
		136: Reg	constructor(writable_reg_to_reg, [135], 0)
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: Reg	constructor(writable_reg_to_reg, [142], 0)
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: Reg	constructor(writable_reg_to_reg, [149], 0)
		155: Type	const_prim(I64)
		156: WritableReg	constructor(temp_writable_reg, [155], 1)
		157: Reg	constructor(writable_reg_to_reg, [156], 0)
		162: Type	const_prim(I64)
		163: WritableReg	constructor(temp_writable_reg, [162], 1)
		164: Reg	constructor(writable_reg_to_reg, [163], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		91:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		104:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		114:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1451
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: ALUOp	make_variant(ALUOp::Asr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 19, 13], 2)
		16: Option(InstOutput)	some(22)
		18: Type	extractor(value_type, 11)
		19: Reg	constructor(put_in_reg, [11], 1)
		21: ValueRegs	constructor(value_reg, [14], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1451
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: ALUOp	make_variant(ALUOp::Asr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 35, 13], 2)
		16: Option(InstOutput)	some(28)
		18: Type	extractor(value_type, 11)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [11], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		27: ValueRegs	constructor(value_reg, [14], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 12)
		20: Reg	constructor(put_in_reg, [12], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 12)
		20: Reg	constructor(put_in_reg, [12], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 36, 14], 2)
		17: Option(InstOutput)	some(29)
		19: Type	extractor(value_type, 12)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [12], 1)
		22: bool	const_prim(true)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(32, u8)
		28: ValueRegs	constructor(value_reg, [15], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1413
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		20: Option(InstOutput)	some(23)
		22: ValueRegs	constructor(put_in_regs, [18], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1411
		../../codegen/src/isa/aarch64/inst.isle line 2757
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: Imm64	match_some(13)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: VectorSize	constructor(vector_size, [16], 2)
		23: Option(InstOutput)	some(31)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		30: ValueRegs	constructor(value_reg, [38], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1406
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/isa/aarch64/inst.isle line 2749
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 8)
		12: Type	const_prim(I64)
		13: Reg	constructor(zero_reg, [], 5)
		14: Type	const_prim(I32)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(6)
		18: ImmLogic	constructor(shift_mask, [17], 3)
		21: VectorSize	constructor(vector_size, [17], 1)
		25: Option(InstOutput)	some(48)
		29: ALUOp	make_variant(ALUOp::And, [])
		34: ALUOp	make_variant(ALUOp::Sub, [])
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: VecALUOp	make_variant(VecALUOp::Ushl, [])
		47: ValueRegs	constructor(value_reg, [69], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		67: Type	const_prim(I8X16)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: Reg	constructor(writable_reg_to_reg, [68], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: Reg	constructor(zero_reg, [], 14)
		43: ValueRegs	constructor(with_flags, [51, 102], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 105, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsr, [])
		60: ALUOp	make_variant(ALUOp::Lsr, [])
		65: ALUOp	make_variant(ALUOp::Lsl, [])
		70: ALUOp	make_variant(ALUOp::OrrNot, [])
		75: ALUOp	make_variant(ALUOp::Lsl, [])
		80: ALUOp	make_variant(ALUOp::Orr, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: MInst	make_variant(MInst::CSel, [86, 24, 112, 147])
		88: Reg	constructor(writable_reg_to_reg, [86], 0)
		89: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [87, 88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 40, 112])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(89, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		102: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [100, 101])
		104: Option(Type)	extractor(fits_in_64, 20)
		105: OperandSize	make_variant(OperandSize::Size64, [])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
		131: Type	const_prim(I64)
		132: WritableReg	constructor(temp_writable_reg, [131], 1)
		133: Reg	constructor(writable_reg_to_reg, [132], 0)
		138: Type	const_prim(I64)
		139: WritableReg	constructor(temp_writable_reg, [138], 1)
		140: Reg	constructor(writable_reg_to_reg, [139], 0)
		145: Type	const_prim(I64)
		146: WritableReg	constructor(temp_writable_reg, [145], 1)
		147: Reg	constructor(writable_reg_to_reg, [146], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		89:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		97:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		104:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: Reg	constructor(zero_reg, [], 14)
		43: ValueRegs	constructor(with_flags, [51, 102], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 105, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsr, [])
		60: ALUOp	make_variant(ALUOp::Lsr, [])
		65: ALUOp	make_variant(ALUOp::Lsl, [])
		70: ALUOp	make_variant(ALUOp::OrrNot, [])
		75: ALUOp	make_variant(ALUOp::Lsl, [])
		80: ALUOp	make_variant(ALUOp::Orr, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: MInst	make_variant(MInst::CSel, [86, 24, 112, 147])
		88: Reg	constructor(writable_reg_to_reg, [86], 0)
		89: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [87, 88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 40, 112])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(89, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		102: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [100, 101])
		104: Option(Type)	extractor(fits_in_32, 20)
		105: OperandSize	make_variant(OperandSize::Size32, [])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
		131: Type	const_prim(I64)
		132: WritableReg	constructor(temp_writable_reg, [131], 1)
		133: Reg	constructor(writable_reg_to_reg, [132], 0)
		138: Type	const_prim(I64)
		139: WritableReg	constructor(temp_writable_reg, [138], 1)
		140: Reg	constructor(writable_reg_to_reg, [139], 0)
		145: Type	const_prim(I64)
		146: WritableReg	constructor(temp_writable_reg, [145], 1)
		147: Reg	constructor(writable_reg_to_reg, [146], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		89:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		97:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		104:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: Reg	constructor(zero_reg, [], 14)
		43: ValueRegs	constructor(with_flags, [51, 105], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 108, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsr, [])
		60: ALUOp	make_variant(ALUOp::Lsr, [])
		65: ALUOp	make_variant(ALUOp::Lsl, [])
		70: ALUOp	make_variant(ALUOp::OrrNot, [])
		75: ALUOp	make_variant(ALUOp::Lsl, [])
		80: ALUOp	make_variant(ALUOp::Orr, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: MInst	make_variant(MInst::CSel, [86, 24, 115, 150])
		88: Reg	constructor(writable_reg_to_reg, [86], 0)
		89: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [87, 88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 40, 115])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		102: Reg	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: Reg	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		104: ValueRegs	constructor(value_regs, [102, 103], 1)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [100, 101, 104])
		107: Option(Type)	extractor(fits_in_64, 20)
		108: OperandSize	make_variant(OperandSize::Size64, [])
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: Reg	constructor(writable_reg_to_reg, [114], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: Reg	constructor(writable_reg_to_reg, [121], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: Reg	constructor(writable_reg_to_reg, [128], 0)
		134: Type	const_prim(I64)
		135: WritableReg	constructor(temp_writable_reg, [134], 1)
		136: Reg	constructor(writable_reg_to_reg, [135], 0)
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: Reg	constructor(writable_reg_to_reg, [142], 0)
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: Reg	constructor(writable_reg_to_reg, [149], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		89:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		97:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		107:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
		../../codegen/src/isa/aarch64/lower.isle line 1427
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2681
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [10, 25], 2)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [10, 28], 1)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		34: Type	const_prim(I32)
		35: Reg	constructor(zero_reg, [], 5)
		40: Reg	constructor(zero_reg, [], 14)
		43: ValueRegs	constructor(with_flags, [51, 105], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 108, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsr, [])
		60: ALUOp	make_variant(ALUOp::Lsr, [])
		65: ALUOp	make_variant(ALUOp::Lsl, [])
		70: ALUOp	make_variant(ALUOp::OrrNot, [])
		75: ALUOp	make_variant(ALUOp::Lsl, [])
		80: ALUOp	make_variant(ALUOp::Orr, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: MInst	make_variant(MInst::CSel, [86, 24, 115, 150])
		88: Reg	constructor(writable_reg_to_reg, [86], 0)
		89: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [87, 88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 40, 115])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		102: Reg	match_variant(89, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: Reg	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		104: ValueRegs	constructor(value_regs, [102, 103], 1)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [100, 101, 104])
		107: Option(Type)	extractor(fits_in_32, 20)
		108: OperandSize	make_variant(OperandSize::Size32, [])
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: Reg	constructor(writable_reg_to_reg, [114], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: Reg	constructor(writable_reg_to_reg, [121], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: Reg	constructor(writable_reg_to_reg, [128], 0)
		134: Type	const_prim(I64)
		135: WritableReg	constructor(temp_writable_reg, [134], 1)
		136: Reg	constructor(writable_reg_to_reg, [135], 0)
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: Reg	constructor(writable_reg_to_reg, [142], 0)
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: Reg	constructor(writable_reg_to_reg, [149], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		89:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		97:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		107:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1394
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: ALUOp	make_variant(ALUOp::Lsr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 19, 13], 2)
		16: Option(InstOutput)	some(22)
		18: Type	extractor(value_type, 11)
		19: Reg	constructor(put_in_reg, [11], 1)
		21: ValueRegs	constructor(value_reg, [14], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1394
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: ALUOp	make_variant(ALUOp::Lsr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 35, 13], 2)
		16: Option(InstOutput)	some(28)
		18: Type	extractor(value_type, 11)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [11], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		27: ValueRegs	constructor(value_reg, [14], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 12)
		20: Reg	constructor(put_in_reg, [12], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 20, 14], 2)
		17: Option(InstOutput)	some(23)
		19: Type	extractor(value_type, 12)
		20: Reg	constructor(put_in_reg, [12], 1)
		22: ValueRegs	constructor(value_reg, [15], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 36, 14], 2)
		17: Option(InstOutput)	some(29)
		19: Type	extractor(value_type, 12)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [12], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(32, u8)
		28: ValueRegs	constructor(value_reg, [15], 1)
		29: InstOutput	constructor(output, [28], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/inst.isle line 2753
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: Imm64	match_some(13)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: VectorSize	constructor(vector_size, [16], 2)
		23: Option(InstOutput)	some(31)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Shl, [])
		30: ValueRegs	constructor(value_reg, [38], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1337
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/isa/aarch64/inst.isle line 2745
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 6)
		12: Type	const_prim(I32)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ImmLogic	constructor(shift_mask, [15], 3)
		18: VectorSize	constructor(vector_size, [15], 1)
		22: Option(InstOutput)	some(40)
		26: ALUOp	make_variant(ALUOp::And, [])
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: VecALUOp	make_variant(VecALUOp::Sshl, [])
		39: ValueRegs	constructor(value_reg, [54], 1)
		40: InstOutput	constructor(output, [39], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
		52: Type	const_prim(I8X16)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: Reg	constructor(writable_reg_to_reg, [53], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: Reg	constructor(zero_reg, [], 13)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [10, 26], 1)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [10, 30], 2)
		33: u8	const_int(1, u8)
		34: ImmShift	constructor(imm_shift_from_u8, [33], 7)
		36: Type	const_prim(I32)
		37: Reg	constructor(zero_reg, [], 5)
		43: ValueRegs	constructor(with_flags, [51, 102], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 105, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsl, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::CSel, [61, 24, 25, 112])
		63: Reg	constructor(writable_reg_to_reg, [61], 0)
		64: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [62, 63])
		68: ALUOp	make_variant(ALUOp::Lsl, [])
		73: ALUOp	make_variant(ALUOp::Lsr, [])
		78: ALUOp	make_variant(ALUOp::OrrNot, [])
		83: ALUOp	make_variant(ALUOp::Lsr, [])
		88: ALUOp	make_variant(ALUOp::Orr, [])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 112, 147])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(64, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		102: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [100, 101])
		104: Option(Type)	extractor(fits_in_64, 20)
		105: OperandSize	make_variant(OperandSize::Size64, [])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
		131: Type	const_prim(I64)
		132: WritableReg	constructor(temp_writable_reg, [131], 1)
		133: Reg	constructor(writable_reg_to_reg, [132], 0)
		138: Type	const_prim(I64)
		139: WritableReg	constructor(temp_writable_reg, [138], 1)
		140: Reg	constructor(writable_reg_to_reg, [139], 0)
		145: Type	const_prim(I64)
		146: WritableReg	constructor(temp_writable_reg, [145], 1)
		147: Reg	constructor(writable_reg_to_reg, [146], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		64:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		97:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		104:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 465
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: Reg	constructor(zero_reg, [], 13)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [10, 26], 1)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [10, 30], 2)
		33: u8	const_int(1, u8)
		34: ImmShift	constructor(imm_shift_from_u8, [33], 7)
		36: Type	const_prim(I32)
		37: Reg	constructor(zero_reg, [], 5)
		43: ValueRegs	constructor(with_flags, [51, 102], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 105, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsl, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::CSel, [61, 24, 25, 112])
		63: Reg	constructor(writable_reg_to_reg, [61], 0)
		64: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [62, 63])
		68: ALUOp	make_variant(ALUOp::Lsl, [])
		73: ALUOp	make_variant(ALUOp::Lsr, [])
		78: ALUOp	make_variant(ALUOp::OrrNot, [])
		83: ALUOp	make_variant(ALUOp::Lsr, [])
		88: ALUOp	make_variant(ALUOp::Orr, [])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 112, 147])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(64, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsSideEffect, inst)
		102: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect2, [100, 101])
		104: Option(Type)	extractor(fits_in_32, 20)
		105: OperandSize	make_variant(OperandSize::Size32, [])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: Reg	constructor(writable_reg_to_reg, [111], 0)
		117: Type	const_prim(I64)
		118: WritableReg	constructor(temp_writable_reg, [117], 1)
		119: Reg	constructor(writable_reg_to_reg, [118], 0)
		124: Type	const_prim(I64)
		125: WritableReg	constructor(temp_writable_reg, [124], 1)
		126: Reg	constructor(writable_reg_to_reg, [125], 0)
		131: Type	const_prim(I64)
		132: WritableReg	constructor(temp_writable_reg, [131], 1)
		133: Reg	constructor(writable_reg_to_reg, [132], 0)
		138: Type	const_prim(I64)
		139: WritableReg	constructor(temp_writable_reg, [138], 1)
		140: Reg	constructor(writable_reg_to_reg, [139], 0)
		145: Type	const_prim(I64)
		146: WritableReg	constructor(temp_writable_reg, [145], 1)
		147: Reg	constructor(writable_reg_to_reg, [146], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		64:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		97:	variant(ConsumesFlags::ConsumesFlagsSideEffect)
		104:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: Reg	constructor(zero_reg, [], 13)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [10, 26], 1)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [10, 30], 2)
		33: u8	const_int(1, u8)
		34: ImmShift	constructor(imm_shift_from_u8, [33], 7)
		36: Type	const_prim(I32)
		37: Reg	constructor(zero_reg, [], 5)
		43: ValueRegs	constructor(with_flags, [51, 105], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 108, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsl, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::CSel, [61, 24, 25, 115])
		63: Reg	constructor(writable_reg_to_reg, [61], 0)
		64: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [62, 63])
		68: ALUOp	make_variant(ALUOp::Lsl, [])
		73: ALUOp	make_variant(ALUOp::Lsr, [])
		78: ALUOp	make_variant(ALUOp::OrrNot, [])
		83: ALUOp	make_variant(ALUOp::Lsr, [])
		88: ALUOp	make_variant(ALUOp::Orr, [])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 115, 150])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(64, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		102: Reg	match_variant(64, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: Reg	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		104: ValueRegs	constructor(value_regs, [102, 103], 1)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [100, 101, 104])
		107: Option(Type)	extractor(fits_in_64, 20)
		108: OperandSize	make_variant(OperandSize::Size64, [])
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: Reg	constructor(writable_reg_to_reg, [114], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: Reg	constructor(writable_reg_to_reg, [121], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: Reg	constructor(writable_reg_to_reg, [128], 0)
		134: Type	const_prim(I64)
		135: WritableReg	constructor(temp_writable_reg, [134], 1)
		136: Reg	constructor(writable_reg_to_reg, [135], 0)
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: Reg	constructor(writable_reg_to_reg, [142], 0)
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: Reg	constructor(writable_reg_to_reg, [149], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		64:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		97:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		107:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
		../../codegen/src/isa/aarch64/lower.isle line 1320
		../../codegen/src/isa/aarch64/inst.isle line 2362
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2706
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 459
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [43], 5)
		17: Option(InstOutput)	some(16)
		20: Type	const_prim(I64)
		21: u64	const_int(64, u64)
		22: ImmLogic	constructor(u64_into_imm_logic, [20, 21], 11)
		24: Cond	make_variant(Cond::Ne, [])
		25: Reg	constructor(zero_reg, [], 13)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [10, 26], 1)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [10, 30], 2)
		33: u8	const_int(1, u8)
		34: ImmShift	constructor(imm_shift_from_u8, [33], 7)
		36: Type	const_prim(I32)
		37: Reg	constructor(zero_reg, [], 5)
		43: ValueRegs	constructor(with_flags, [51, 105], 17)
		47: ALUOp	make_variant(ALUOp::AndS, [])
		49: WritableReg	constructor(writable_zero_reg, [], 2)
		50: MInst	make_variant(MInst::AluRRImmLogic, [47, 108, 49, 14, 22])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		55: ALUOp	make_variant(ALUOp::Lsl, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::CSel, [61, 24, 25, 115])
		63: Reg	constructor(writable_reg_to_reg, [61], 0)
		64: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [62, 63])
		68: ALUOp	make_variant(ALUOp::Lsl, [])
		73: ALUOp	make_variant(ALUOp::Lsr, [])
		78: ALUOp	make_variant(ALUOp::OrrNot, [])
		83: ALUOp	make_variant(ALUOp::Lsr, [])
		88: ALUOp	make_variant(ALUOp::Orr, [])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 24, 115, 150])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		100: MInst	match_variant(64, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		101: MInst	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, inst)
		102: Reg	match_variant(64, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		103: Reg	match_variant(97, ConsumesFlags::ConsumesFlagsReturnsReg, result)
		104: ValueRegs	constructor(value_regs, [102, 103], 1)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [100, 101, 104])
		107: Option(Type)	extractor(fits_in_32, 20)
		108: OperandSize	make_variant(OperandSize::Size32, [])
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: Reg	constructor(writable_reg_to_reg, [114], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: Reg	constructor(writable_reg_to_reg, [121], 0)
		127: Type	const_prim(I64)
		128: WritableReg	constructor(temp_writable_reg, [127], 1)
		129: Reg	constructor(writable_reg_to_reg, [128], 0)
		134: Type	const_prim(I64)
		135: WritableReg	constructor(temp_writable_reg, [134], 1)
		136: Reg	constructor(writable_reg_to_reg, [135], 0)
		141: Type	const_prim(I64)
		142: WritableReg	constructor(temp_writable_reg, [141], 1)
		143: Reg	constructor(writable_reg_to_reg, [142], 0)
		148: Type	const_prim(I64)
		149: WritableReg	constructor(temp_writable_reg, [148], 1)
		150: Reg	constructor(writable_reg_to_reg, [149], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		64:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		97:	variant(ConsumesFlags::ConsumesFlagsReturnsReg)
		107:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1303
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: ALUOp	make_variant(ALUOp::Lsl, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(do_shift, [8, 9, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: ALUOp	make_variant(ALUOp::Lsl, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [9, 10, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1294
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1293
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1281
		../../codegen/src/isa/aarch64/inst.isle line 2733
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Eor, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1279
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: ALUOp	make_variant(ALUOp::Eor, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [30], 2)
		15: Option(InstOutput)	some(14)
		20: ValueRegs	constructor(put_in_regs, [11], 1)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 2)
		23: ValueRegs	constructor(put_in_regs, [12], 4)
		24: Reg	constructor(value_regs_get, [23, 21], 5)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [20, 26], 3)
		28: Reg	constructor(value_regs_get, [23, 26], 6)
		30: ValueRegs	constructor(value_regs, [37, 44], 9)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1276
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: ALUOp	make_variant(ALUOp::Eor, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1272
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1271
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1259
		../../codegen/src/isa/aarch64/inst.isle line 2715
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Orr, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1257
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: ALUOp	make_variant(ALUOp::Orr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [30], 2)
		15: Option(InstOutput)	some(14)
		20: ValueRegs	constructor(put_in_regs, [11], 1)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 2)
		23: ValueRegs	constructor(put_in_regs, [12], 4)
		24: Reg	constructor(value_regs_get, [23, 21], 5)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [20, 26], 3)
		28: Reg	constructor(value_regs_get, [23, 26], 6)
		30: ValueRegs	constructor(value_regs, [37, 44], 9)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1254
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: ALUOp	make_variant(ALUOp::Orr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1249
		../../codegen/src/isa/aarch64/inst.isle line 2741
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		22: Option(InstOutput)	some(30)
		26: VecALUOp	make_variant(VecALUOp::Bic, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1247
		../../codegen/src/isa/aarch64/inst.isle line 2741
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		22: Option(InstOutput)	some(30)
		26: VecALUOp	make_variant(VecALUOp::Bic, [])
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1245
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1244
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [15, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [15, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1232
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::And, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1230
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: ALUOp	make_variant(ALUOp::And, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [30], 2)
		15: Option(InstOutput)	some(14)
		20: ValueRegs	constructor(put_in_regs, [11], 1)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [20, 21], 2)
		23: ValueRegs	constructor(put_in_regs, [12], 4)
		24: Reg	constructor(value_regs_get, [23, 21], 5)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [20, 26], 3)
		28: Reg	constructor(value_regs_get, [23, 26], 6)
		30: ValueRegs	constructor(value_regs, [37, 44], 9)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1227
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: ALUOp	make_variant(ALUOp::And, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1223
		../../codegen/src/isa/aarch64/inst.isle line 3086
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Value))	extractor(bxor, 10)
		12: ALUOp	make_variant(ALUOp::EorNot, [])
		13: Type	const_prim(I64)
		14: (Value, Value)	match_some(11)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		18: InstOutput	constructor(output, [34], 2)
		19: Option(InstOutput)	some(18)
		24: ValueRegs	constructor(put_in_regs, [15], 1)
		25: usize	const_int(0, usize)
		26: Reg	constructor(value_regs_get, [24, 25], 2)
		27: ValueRegs	constructor(put_in_regs, [16], 4)
		28: Reg	constructor(value_regs_get, [27, 25], 5)
		30: usize	const_int(1, usize)
		31: Reg	constructor(value_regs_get, [24, 30], 3)
		32: Reg	constructor(value_regs_get, [27, 30], 6)
		34: ValueRegs	constructor(value_regs, [41, 48], 9)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
		../../codegen/src/isa/aarch64/inst.isle line 3077
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		20: Option(InstOutput)	some(42)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option((Value, Value))	extractor(ishl, 26)
		28: (Value, Value)	match_some(27)
		29: Value	match_tuple(28, 1)
		30: Option(Inst)	extractor(def_inst, 29)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [14, 33], 0)
		35: Reg	constructor(put_in_reg, [16], 1)
		36: Value	match_tuple(28, 0)
		37: Reg	constructor(put_in_reg, [36], 2)
		38: ShiftOpAndAmt	match_some(34)
		41: ValueRegs	constructor(value_reg, [50], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		25:	some
		27:	some
		30:	some
		32:	some
		34:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
		../../codegen/src/isa/aarch64/inst.isle line 3074
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		20: Option(InstOutput)	some(35)
		25: Option(Inst)	extractor(def_inst, 17)
		26: Inst	match_some(25)
		27: Option(Imm64)	extractor(iconst, 26)
		28: Imm64	match_some(27)
		29: Option(ImmLogic)	constructor(imm_logic_from_imm64, [14, 28], 0)
		30: Reg	constructor(put_in_reg, [16], 1)
		31: ImmLogic	match_some(29)
		34: ValueRegs	constructor(value_reg, [42], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		25:	some
		27:	some
		29:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
		../../codegen/src/isa/aarch64/inst.isle line 3072
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		20: Option(InstOutput)	some(30)
		25: Reg	constructor(put_in_reg, [16], 1)
		26: Reg	constructor(put_in_reg, [17], 2)
		29: ValueRegs	constructor(value_reg, [37], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1217
		../../codegen/src/isa/aarch64/inst.isle line 2693
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(22)
		18: VecMisc2	make_variant(VecMisc2::Not, [])
		21: ValueRegs	constructor(value_reg, [28], 1)
		22: InstOutput	constructor(output, [21], 2)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1208
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Type	const_prim(I64)
		9: Reg	constructor(zero_reg, [], 4)
		10: Value	match_some(7)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		15: Reg	constructor(zero_reg, [], 6)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [11, 16], 3)
		19: ValueRegs	constructor(value_regs, [38, 45], 8)
		20: InstOutput	constructor(output, [19], 9)
		21: Option(InstOutput)	some(20)
		25: ALUOp	make_variant(ALUOp::OrrNot, [])
		30: ALUOp	make_variant(ALUOp::OrrNot, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/isa/aarch64/inst.isle line 2701
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(ishl, 11)
		13: (Value, Value)	match_some(12)
		14: Value	match_tuple(13, 1)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: Option(Imm64)	extractor(iconst, 16)
		18: Type	match_some(6)
		19: Imm64	match_some(17)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [18, 19], 0)
		21: Reg	constructor(zero_reg, [], 1)
		22: Value	match_tuple(13, 0)
		23: Reg	constructor(put_in_reg, [22], 2)
		24: ShiftOpAndAmt	match_some(20)
		27: Option(InstOutput)	some(36)
		32: ALUOp	make_variant(ALUOp::OrrNot, [])
		35: ValueRegs	constructor(value_reg, [44], 1)
		36: InstOutput	constructor(output, [35], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		17:	some
		20:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1197
		../../codegen/src/isa/aarch64/inst.isle line 2698
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Type	match_some(6)
		10: Reg	constructor(zero_reg, [], 1)
		11: Value	match_some(8)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(23)
		19: ALUOp	make_variant(ALUOp::OrrNot, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1181
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Reg	constructor(put_in_reg, [13], 1)
		16: Uimm8	match_tuple(12, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Type	const_prim(I64)
		21: u8	const_int(63, u8)
		22: ImmShift	constructor(imm_shift_from_u8, [21], 3)
		24: ValueRegs	constructor(value_regs, [32, 44], 5)
		25: InstOutput	constructor(output, [24], 6)
		26: Option(InstOutput)	some(25)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ALUOp	make_variant(ALUOp::Asr, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		14:	const_prim(I64X2)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1170
		../../codegen/src/isa/aarch64/inst.isle line 3008
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: Uimm8	match_tuple(12, 1)
		18: u8	extractor(u8_from_uimm8, 17)
		19: VectorSize	constructor(vector_size, [14], 2)
		20: Type	const_prim(I64)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [37, 49], 7)
		27: InstOutput	constructor(output, [26], 8)
		28: Option(InstOutput)	some(27)
		30: OperandSize	make_variant(OperandSize::Size64, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		41: ALUOp	make_variant(ALUOp::Asr, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
		20:	const_prim(I64)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1170
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: Uimm8	match_tuple(12, 1)
		18: u8	extractor(u8_from_uimm8, 17)
		19: VectorSize	constructor(vector_size, [14], 2)
		20: Type	const_prim(I64)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [38, 50], 7)
		27: InstOutput	constructor(output, [26], 8)
		28: Option(InstOutput)	some(27)
		30: Option(Type)	extractor(fits_in_32, 20)
		31: OperandSize	make_variant(OperandSize::Size32, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: Reg	constructor(writable_reg_to_reg, [37], 0)
		42: ALUOp	make_variant(ALUOp::Asr, [])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
		30:	some
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1160
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 2)
		14: ValueRegs	constructor(value_regs, [19, 31], 4)
		15: InstOutput	constructor(output, [14], 5)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
		23: ALUOp	make_variant(ALUOp::Asr, [])
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1160
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 2)
		14: ValueRegs	constructor(value_regs, [37, 44], 4)
		15: InstOutput	constructor(output, [14], 5)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(true)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		29: ALUOp	make_variant(ALUOp::Asr, [])
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1151
		../../codegen/src/isa/aarch64/inst.isle line 3008
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_tuple(13, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: VectorSize	constructor(vector_size, [18], 2)
		20: Type	match_some(6)
		24: Option(InstOutput)	some(36)
		26: OperandSize	make_variant(OperandSize::Size64, [])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		20:	const_prim(I64)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1151
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2306
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_tuple(13, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: VectorSize	constructor(vector_size, [18], 2)
		20: Type	match_some(6)
		24: Option(InstOutput)	some(37)
		26: Option(Type)	extractor(fits_in_32, 20)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		26:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1146
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(true)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1137
		../../codegen/src/isa/aarch64/inst.isle line 2299
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Uimm8	match_tuple(12, 1)
		16: u8	extractor(u8_from_uimm8, 15)
		17: Type	extractor(value_type, 13)
		18: ScalarSize	constructor(lane_size, [17], 2)
		20: Type	const_prim(I64)
		21: ImmExtend	make_variant(ImmExtend::Zero, [])
		22: u64	const_int(0, u64)
		23: Reg	constructor(imm, [20, 21, 22], 4)
		24: ValueRegs	constructor(value_regs, [32, 23], 5)
		25: InstOutput	constructor(output, [24], 6)
		26: Option(InstOutput)	some(25)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
		../../codegen/src/isa/aarch64/inst.isle line 2997
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [19, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Reg	constructor(put_in_reg, [8], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		18:	const_prim(I64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [32, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		16: Option(InstOutput)	some(15)
		18: Type	extractor(value_type, 8)
		19: Option(Type)	extractor(fits_in_32, 18)
		20: Reg	constructor(put_in_reg, [8], 1)
		21: bool	const_prim(false)
		22: Type	match_some(19)
		23: u8	constructor(ty_bits, [22], 0)
		24: u8	const_int(64, u8)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		19:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1125
		../../codegen/src/isa/aarch64/inst.isle line 3040
		../../codegen/src/isa/aarch64/inst.isle line 2347
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((MemFlags, Value))	extractor(atomic_load, 11)
		13: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		14: Type	extractor(value_type, 9)
		15: (MemFlags, Value)	match_some(12)
		16: MemFlags	match_tuple(15, 0)
		17: Inst	match_some(13)
		21: Option(InstOutput)	some(35)
		23: Option((MemFlags, Value))	extractor(atomic_load, 17)
		24: (MemFlags, Value)	match_some(23)
		25: Value	match_tuple(24, 1)
		26: Reg	constructor(put_in_reg, [25], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		13:	some
		23:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1118
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_tuple(13, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: ScalarSize	constructor(lane_size, [18], 2)
		22: Option(InstOutput)	some(31)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1113
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(false)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1106
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umax, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [11], 4)
		18: Reg	constructor(put_in_reg, [13], 5)
		21: Option(InstOutput)	some(38)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		33: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		34: VectorSize	constructor(vector_size, [8], 1)
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1103
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Umax, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1100
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smax, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [11], 4)
		18: Reg	constructor(put_in_reg, [13], 5)
		21: Option(InstOutput)	some(38)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		33: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		34: VectorSize	constructor(vector_size, [8], 1)
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1097
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Smax, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1094
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umin, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [13], 4)
		18: Reg	constructor(put_in_reg, [11], 5)
		21: Option(InstOutput)	some(38)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		33: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		34: VectorSize	constructor(vector_size, [8], 1)
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1091
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Umin, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1088
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2810
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1921
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smin, 6)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(put_in_reg, [13], 4)
		18: Reg	constructor(put_in_reg, [11], 5)
		21: Option(InstOutput)	some(38)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
		33: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		34: VectorSize	constructor(vector_size, [8], 1)
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1085
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Smin, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_64, 25)
		39: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_32, 25)
		39: OperandSize	make_variant(OperandSize::Size32, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_64, 25)
		35: OperandSize	make_variant(OperandSize::Size64, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_32, 25)
		35: OperandSize	make_variant(OperandSize::Size32, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_64, 25)
		39: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_32, 25)
		39: OperandSize	make_variant(OperandSize::Size32, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_64, 25)
		35: OperandSize	make_variant(OperandSize::Size64, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_32, 25)
		35: OperandSize	make_variant(OperandSize::Size32, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_64, 25)
		39: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_32, 25)
		39: OperandSize	make_variant(OperandSize::Size32, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_64, 25)
		35: OperandSize	make_variant(OperandSize::Size64, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_32, 25)
		35: OperandSize	make_variant(OperandSize::Size32, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_64, 25)
		39: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1068
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [36], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_16, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: u8	constructor(ty_bits, [25], 0)
		29: u8	const_int(32, u8)
		31: Reg	constructor(put_in_reg, [15], 3)
		36: ValueRegs	constructor(value_reg, [73], 9)
		38: Option(Type)	extractor(fits_in_32, 25)
		39: OperandSize	make_variant(OperandSize::Size32, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		57: ALUOp	make_variant(ALUOp::SubS, [])
		58: WritableReg	constructor(writable_zero_reg, [], 1)
		59: MInst	make_variant(MInst::AluRRR, [57, 39, 58, 46, 53])
		60: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [59])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::CSel, [65, 11, 46, 53])
		67: Reg	constructor(writable_reg_to_reg, [65], 0)
		68: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [66, 67])
		71: ValueRegs	constructor(with_flags, [60, 68], 1)
		72: usize	const_int(0, usize)
		73: Reg	constructor(value_regs_get, [71, 72], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		38:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_64, 25)
		35: OperandSize	make_variant(OperandSize::Size64, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
		../../codegen/src/isa/aarch64/lower.isle line 1060
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 2376
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		17: InstOutput	constructor(output, [32], 2)
		18: Option(InstOutput)	some(17)
		24: Option(Type)	extractor(fits_in_64, 10)
		25: Type	match_some(24)
		27: Reg	constructor(put_in_reg, [14], 1)
		28: Reg	constructor(put_in_reg, [15], 2)
		32: ValueRegs	constructor(value_reg, [55], 7)
		34: Option(Type)	extractor(fits_in_32, 25)
		35: OperandSize	make_variant(OperandSize::Size32, [])
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRR, [39, 35, 40, 27, 28])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSel, [47, 11, 27, 28])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [42, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		24:	some
		34:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(45)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		23: Option(Inst)	extractor(def_inst, 13)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(u64)	extractor(nonzero_u64_from_imm64, 26)
		28: Type	extractor(value_type, 13)
		29: ImmExtend	make_variant(ImmExtend::Sign, [])
		30: u64	match_some(27)
		31: Reg	constructor(imm, [28, 29, 30], 1)
		35: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ALUOp3	make_variant(ALUOp3::MSub, [])
		44: ValueRegs	constructor(value_reg, [60], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		23:	some
		25:	some
		27:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		28: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [57], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 13)
		41: Reg	constructor(put_in_reg, [13], 1)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		40:	const_prim(I64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		28: ALUOp	make_variant(ALUOp::SDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [63], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 13)
		41: Option(Type)	extractor(fits_in_32, 40)
		42: Reg	constructor(put_in_reg, [13], 1)
		43: bool	const_prim(true)
		44: Type	match_some(41)
		45: u8	constructor(ty_bits, [44], 0)
		46: u8	const_int(64, u8)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		41:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(51)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		29: Option(Inst)	extractor(def_inst, 13)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(u64)	extractor(nonzero_u64_from_imm64, 32)
		34: Type	extractor(value_type, 13)
		35: ImmExtend	make_variant(ImmExtend::Sign, [])
		36: u64	match_some(33)
		37: Reg	constructor(imm, [34, 35, 36], 1)
		41: ALUOp	make_variant(ALUOp::SDiv, [])
		47: ALUOp3	make_variant(ALUOp3::MSub, [])
		50: ValueRegs	constructor(value_reg, [73], 1)
		51: InstOutput	constructor(output, [50], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [70], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: Type	extractor(value_type, 13)
		54: Reg	constructor(put_in_reg, [13], 1)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		53:	const_prim(I64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(true)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::SDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [76], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: Type	extractor(value_type, 13)
		54: Option(Type)	extractor(fits_in_32, 53)
		55: Reg	constructor(put_in_reg, [13], 1)
		56: bool	const_prim(true)
		57: Type	match_some(54)
		58: u8	constructor(ty_bits, [57], 0)
		59: u8	const_int(64, u8)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		54:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(45)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		23: Option(Inst)	extractor(def_inst, 13)
		24: Inst	match_some(23)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Imm64	match_some(25)
		27: Option(u64)	extractor(nonzero_u64_from_imm64, 26)
		28: Type	extractor(value_type, 13)
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	match_some(27)
		31: Reg	constructor(imm, [28, 29, 30], 1)
		35: ALUOp	make_variant(ALUOp::UDiv, [])
		41: ALUOp3	make_variant(ALUOp3::MSub, [])
		44: ValueRegs	constructor(value_reg, [60], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		23:	some
		25:	some
		27:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		28: ALUOp	make_variant(ALUOp::UDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [57], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 13)
		41: Reg	constructor(put_in_reg, [13], 1)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		40:	const_prim(I64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(38)
		20: Type	extractor(value_type, 11)
		21: Reg	constructor(put_in_reg, [11], 1)
		28: ALUOp	make_variant(ALUOp::UDiv, [])
		34: ALUOp3	make_variant(ALUOp3::MSub, [])
		37: ValueRegs	constructor(value_reg, [63], 1)
		38: InstOutput	constructor(output, [37], 2)
		40: Type	extractor(value_type, 13)
		41: Option(Type)	extractor(fits_in_32, 40)
		42: Reg	constructor(put_in_reg, [13], 1)
		43: bool	const_prim(false)
		44: Type	match_some(41)
		45: u8	constructor(ty_bits, [44], 0)
		46: u8	const_int(64, u8)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	const_prim(I64)
		41:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(51)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		29: Option(Inst)	extractor(def_inst, 13)
		30: Inst	match_some(29)
		31: Option(Imm64)	extractor(iconst, 30)
		32: Imm64	match_some(31)
		33: Option(u64)	extractor(nonzero_u64_from_imm64, 32)
		34: Type	extractor(value_type, 13)
		35: ImmExtend	make_variant(ImmExtend::Zero, [])
		36: u64	match_some(33)
		37: Reg	constructor(imm, [34, 35, 36], 1)
		41: ALUOp	make_variant(ALUOp::UDiv, [])
		47: ALUOp3	make_variant(ALUOp3::MSub, [])
		50: ValueRegs	constructor(value_reg, [73], 1)
		51: InstOutput	constructor(output, [50], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		29:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [70], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: Type	extractor(value_type, 13)
		54: Reg	constructor(put_in_reg, [13], 1)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		53:	const_prim(I64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		18: Option(InstOutput)	some(44)
		20: Type	extractor(value_type, 11)
		21: Option(Type)	extractor(fits_in_32, 20)
		22: Reg	constructor(put_in_reg, [11], 1)
		23: bool	const_prim(false)
		24: Type	match_some(21)
		25: u8	constructor(ty_bits, [24], 0)
		26: u8	const_int(64, u8)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		40: ALUOp3	make_variant(ALUOp3::MSub, [])
		43: ValueRegs	constructor(value_reg, [76], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: Type	extractor(value_type, 13)
		54: Option(Type)	extractor(fits_in_32, 53)
		55: Reg	constructor(put_in_reg, [13], 1)
		56: bool	const_prim(false)
		57: Type	match_some(54)
		58: u8	constructor(ty_bits, [57], 0)
		59: u8	const_int(64, u8)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		54:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Type	const_prim(I64)
		18: Value	match_tuple(9, 0)
		20: ImmExtend	make_variant(ImmExtend::Sign, [])
		21: u64	match_some(16)
		22: Reg	constructor(imm, [14, 20, 21], 2)
		25: Option(InstOutput)	some(36)
		27: Type	extractor(value_type, 18)
		28: Reg	constructor(put_in_reg, [18], 1)
		32: ALUOp	make_variant(ALUOp::SDiv, [])
		35: ValueRegs	constructor(value_reg, [43], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		27:	const_prim(I64)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Type	const_prim(I64)
		18: Value	match_tuple(9, 0)
		20: ImmExtend	make_variant(ImmExtend::Sign, [])
		21: u64	match_some(16)
		22: Reg	constructor(imm, [14, 20, 21], 2)
		25: Option(InstOutput)	some(42)
		27: Type	extractor(value_type, 18)
		28: Option(Type)	extractor(fits_in_32, 27)
		29: Reg	constructor(put_in_reg, [18], 1)
		30: bool	const_prim(true)
		31: Type	match_some(28)
		32: u8	constructor(ty_bits, [31], 0)
		33: u8	const_int(64, u8)
		38: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ValueRegs	constructor(value_reg, [56], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		28:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		19: Option(InstOutput)	some(43)
		21: Type	extractor(value_type, 12)
		22: Reg	constructor(put_in_reg, [12], 1)
		24: Option(Inst)	extractor(def_inst, 14)
		25: Inst	match_some(24)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Imm64	match_some(26)
		28: Option(u64)	extractor(nonzero_u64_from_imm64, 27)
		29: Type	extractor(value_type, 14)
		30: ImmExtend	make_variant(ImmExtend::Sign, [])
		31: u64	match_some(28)
		32: Reg	constructor(imm, [29, 30, 31], 1)
		39: ALUOp	make_variant(ALUOp::SDiv, [])
		42: ValueRegs	constructor(value_reg, [50], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
		24:	some
		26:	some
		28:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		19: Option(InstOutput)	some(36)
		21: Type	extractor(value_type, 12)
		22: Reg	constructor(put_in_reg, [12], 1)
		32: ALUOp	make_variant(ALUOp::SDiv, [])
		35: ValueRegs	constructor(value_reg, [47], 1)
		36: InstOutput	constructor(output, [35], 2)
		38: Type	extractor(value_type, 14)
		39: Reg	constructor(put_in_reg, [14], 1)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
		38:	const_prim(I64)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		19: Option(InstOutput)	some(36)
		21: Type	extractor(value_type, 12)
		22: Reg	constructor(put_in_reg, [12], 1)
		32: ALUOp	make_variant(ALUOp::SDiv, [])
		35: ValueRegs	constructor(value_reg, [53], 1)
		36: InstOutput	constructor(output, [35], 2)
		38: Type	extractor(value_type, 14)
		39: Option(Type)	extractor(fits_in_32, 38)
		40: Reg	constructor(put_in_reg, [14], 1)
		41: bool	const_prim(true)
		42: Type	match_some(39)
		43: u8	constructor(ty_bits, [42], 0)
		44: u8	const_int(64, u8)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	const_prim(I64)
		39:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1021
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		19: Option(InstOutput)	some(49)
		21: Type	extractor(value_type, 12)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [12], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		30: Option(Inst)	extractor(def_inst, 14)
		31: Inst	match_some(30)
		32: Option(Imm64)	extractor(iconst, 31)
		33: Imm64	match_some(32)
		34: Option(u64)	extractor(nonzero_u64_from_imm64, 33)
		35: Type	extractor(value_type, 14)
		36: ImmExtend	make_variant(ImmExtend::Sign, [])
		37: u64	match_some(34)
		38: Reg	constructor(imm, [35, 36, 37], 1)
		45: ALUOp	make_variant(ALUOp::SDiv, [])
		48: ValueRegs	constructor(value_reg, [63], 1)
		49: InstOutput	constructor(output, [48], 2)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: Reg	constructor(writable_reg_to_reg, [55], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		30:	some
		32:	some
		34:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		19: Option(InstOutput)	some(42)
		21: Type	extractor(value_type, 12)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [12], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		38: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ValueRegs	constructor(value_reg, [60], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		51: Type	extractor(value_type, 14)
		52: Reg	constructor(put_in_reg, [14], 1)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		51:	const_prim(I64)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/lower.isle line 1016
		../../codegen/src/isa/aarch64/inst.isle line 3014
		../../codegen/src/isa/aarch64/inst.isle line 2689
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: Type	const_prim(I64)
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		14: Value	match_tuple(11, 1)
		19: Option(InstOutput)	some(42)
		21: Type	extractor(value_type, 12)
		22: Option(Type)	extractor(fits_in_32, 21)
		23: Reg	constructor(put_in_reg, [12], 1)
		24: bool	const_prim(true)
		25: Type	match_some(22)
		26: u8	constructor(ty_bits, [25], 0)
		27: u8	const_int(64, u8)
		38: ALUOp	make_variant(ALUOp::SDiv, [])
		41: ValueRegs	constructor(value_reg, [66], 1)
		42: InstOutput	constructor(output, [41], 2)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: Reg	constructor(writable_reg_to_reg, [48], 0)
		51: Type	extractor(value_type, 14)
		52: Option(Type)	extractor(fits_in_32, 51)
		53: Reg	constructor(put_in_reg, [14], 1)
		54: bool	const_prim(true)
		55: Type	match_some(52)
		56: u8	constructor(ty_bits, [55], 0)
		57: u8	const_int(64, u8)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		22:	some
		52:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		17: Option(InstOutput)	some(38)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		22: Option(Inst)	extractor(def_inst, 13)
		23: Inst	match_some(22)
		24: Option(Imm64)	extractor(iconst, 23)
		25: Imm64	match_some(24)
		26: Option(u64)	extractor(nonzero_u64_from_imm64, 25)
		27: Type	extractor(value_type, 13)
		28: ImmExtend	make_variant(ImmExtend::Zero, [])
		29: u64	match_some(26)
		30: Reg	constructor(imm, [27, 28, 29], 1)
		34: ALUOp	make_variant(ALUOp::UDiv, [])
		37: ValueRegs	constructor(value_reg, [45], 1)
		38: InstOutput	constructor(output, [37], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		22:	some
		24:	some
		26:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		17: Option(InstOutput)	some(31)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		27: ALUOp	make_variant(ALUOp::UDiv, [])
		30: ValueRegs	constructor(value_reg, [42], 1)
		31: InstOutput	constructor(output, [30], 2)
		33: Type	extractor(value_type, 13)
		34: Reg	constructor(put_in_reg, [13], 1)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		33:	const_prim(I64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		17: Option(InstOutput)	some(31)
		19: Type	extractor(value_type, 11)
		20: Reg	constructor(put_in_reg, [11], 1)
		27: ALUOp	make_variant(ALUOp::UDiv, [])
		30: ValueRegs	constructor(value_reg, [48], 1)
		31: InstOutput	constructor(output, [30], 2)
		33: Type	extractor(value_type, 13)
		34: Option(Type)	extractor(fits_in_32, 33)
		35: Reg	constructor(put_in_reg, [13], 1)
		36: bool	const_prim(false)
		37: Type	match_some(34)
		38: u8	constructor(ty_bits, [37], 0)
		39: u8	const_int(64, u8)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		19:	const_prim(I64)
		34:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 978
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		17: Option(InstOutput)	some(44)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		28: Option(Inst)	extractor(def_inst, 13)
		29: Inst	match_some(28)
		30: Option(Imm64)	extractor(iconst, 29)
		31: Imm64	match_some(30)
		32: Option(u64)	extractor(nonzero_u64_from_imm64, 31)
		33: Type	extractor(value_type, 13)
		34: ImmExtend	make_variant(ImmExtend::Zero, [])
		35: u64	match_some(32)
		36: Reg	constructor(imm, [33, 34, 35], 1)
		40: ALUOp	make_variant(ALUOp::UDiv, [])
		43: ValueRegs	constructor(value_reg, [58], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: Reg	constructor(writable_reg_to_reg, [50], 0)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		28:	some
		30:	some
		32:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		17: Option(InstOutput)	some(37)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		36: ValueRegs	constructor(value_reg, [55], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		46: Type	extractor(value_type, 13)
		47: Reg	constructor(put_in_reg, [13], 1)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		46:	const_prim(I64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/lower.isle line 973
		../../codegen/src/isa/aarch64/inst.isle line 2685
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 3002
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		17: Option(InstOutput)	some(37)
		19: Type	extractor(value_type, 11)
		20: Option(Type)	extractor(fits_in_32, 19)
		21: Reg	constructor(put_in_reg, [11], 1)
		22: bool	const_prim(false)
		23: Type	match_some(20)
		24: u8	constructor(ty_bits, [23], 0)
		25: u8	const_int(64, u8)
		33: ALUOp	make_variant(ALUOp::UDiv, [])
		36: ValueRegs	constructor(value_reg, [61], 1)
		37: InstOutput	constructor(output, [36], 2)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: Reg	constructor(writable_reg_to_reg, [43], 0)
		46: Type	extractor(value_type, 13)
		47: Option(Type)	extractor(fits_in_32, 46)
		48: Reg	constructor(put_in_reg, [13], 1)
		49: bool	const_prim(false)
		50: Type	match_some(47)
		51: u8	constructor(ty_bits, [50], 0)
		52: u8	const_int(64, u8)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		47:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [55], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 11)
		26: Reg	constructor(put_in_reg, [11], 1)
		28: Type	extractor(value_type, 13)
		29: Reg	constructor(put_in_reg, [13], 1)
		34: ALUOp3	make_variant(ALUOp3::MAdd, [])
		39: ALUOp	make_variant(ALUOp::Lsr, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	const_prim(I64)
		28:	const_prim(I64)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [68], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 11)
		26: Reg	constructor(put_in_reg, [11], 1)
		28: Type	extractor(value_type, 13)
		29: Option(Type)	extractor(fits_in_32, 28)
		30: Reg	constructor(put_in_reg, [13], 1)
		31: bool	const_prim(false)
		32: Type	match_some(29)
		33: u8	constructor(ty_bits, [32], 0)
		34: u8	const_int(64, u8)
		40: ALUOp3	make_variant(ALUOp3::MAdd, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	const_prim(I64)
		29:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2997
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [68], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 11)
		26: Option(Type)	extractor(fits_in_32, 25)
		27: Reg	constructor(put_in_reg, [11], 1)
		28: bool	const_prim(false)
		29: Type	match_some(26)
		30: u8	constructor(ty_bits, [29], 0)
		31: u8	const_int(64, u8)
		34: Type	extractor(value_type, 13)
		35: Reg	constructor(put_in_reg, [13], 1)
		40: ALUOp3	make_variant(ALUOp3::MAdd, [])
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		26:	some
		34:	const_prim(I64)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2993
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [81], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		25: Type	extractor(value_type, 11)
		26: Option(Type)	extractor(fits_in_32, 25)
		27: Reg	constructor(put_in_reg, [11], 1)
		28: bool	const_prim(false)
		29: Type	match_some(26)
		30: u8	constructor(ty_bits, [29], 0)
		31: u8	const_int(64, u8)
		34: Type	extractor(value_type, 13)
		35: Option(Type)	extractor(fits_in_32, 34)
		36: Reg	constructor(put_in_reg, [13], 1)
		37: bool	const_prim(false)
		38: Type	match_some(35)
		39: u8	constructor(ty_bits, [38], 0)
		40: u8	const_int(64, u8)
		46: ALUOp3	make_variant(ALUOp3::MAdd, [])
		51: ALUOp	make_variant(ALUOp::Lsr, [])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		72: Type	const_prim(I64)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: Reg	constructor(writable_reg_to_reg, [73], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		26:	some
		35:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 949
		../../codegen/src/isa/aarch64/inst.isle line 2520
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umulhi, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		16: Option(InstOutput)	some(24)
		20: ALUOp	make_variant(ALUOp::UMulH, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(42)
		24: Type	extractor(value_type, 11)
		25: Reg	constructor(put_in_reg, [11], 1)
		27: Type	extractor(value_type, 13)
		28: Reg	constructor(put_in_reg, [13], 1)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		38: ALUOp	make_variant(ALUOp::Asr, [])
		41: ValueRegs	constructor(value_reg, [57], 1)
		42: InstOutput	constructor(output, [41], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: Reg	constructor(writable_reg_to_reg, [49], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
		27:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(48)
		24: Type	extractor(value_type, 11)
		25: Reg	constructor(put_in_reg, [11], 1)
		27: Type	extractor(value_type, 13)
		28: Option(Type)	extractor(fits_in_32, 27)
		29: Reg	constructor(put_in_reg, [13], 1)
		30: bool	const_prim(true)
		31: Type	match_some(28)
		32: u8	constructor(ty_bits, [31], 0)
		33: u8	const_int(64, u8)
		39: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::Asr, [])
		47: ValueRegs	constructor(value_reg, [70], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		24:	const_prim(I64)
		28:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2989
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(48)
		24: Type	extractor(value_type, 11)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [11], 1)
		27: bool	const_prim(true)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(64, u8)
		33: Type	extractor(value_type, 13)
		34: Reg	constructor(put_in_reg, [13], 1)
		39: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp	make_variant(ALUOp::Asr, [])
		47: ValueRegs	constructor(value_reg, [70], 1)
		48: InstOutput	constructor(output, [47], 2)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: Reg	constructor(writable_reg_to_reg, [69], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
		33:	const_prim(I64)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2985
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		13: Value	match_tuple(10, 1)
		15: Reg	constructor(zero_reg, [], 3)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(54)
		24: Type	extractor(value_type, 11)
		25: Option(Type)	extractor(fits_in_32, 24)
		26: Reg	constructor(put_in_reg, [11], 1)
		27: bool	const_prim(true)
		28: Type	match_some(25)
		29: u8	constructor(ty_bits, [28], 0)
		30: u8	const_int(64, u8)
		33: Type	extractor(value_type, 13)
		34: Option(Type)	extractor(fits_in_32, 33)
		35: Reg	constructor(put_in_reg, [13], 1)
		36: bool	const_prim(true)
		37: Type	match_some(34)
		38: u8	constructor(ty_bits, [37], 0)
		39: u8	const_int(64, u8)
		45: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp	make_variant(ALUOp::Asr, [])
		53: ValueRegs	constructor(value_reg, [83], 1)
		54: InstOutput	constructor(output, [53], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: Reg	constructor(writable_reg_to_reg, [60], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: Reg	constructor(writable_reg_to_reg, [67], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: Reg	constructor(writable_reg_to_reg, [75], 0)
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		25:	some
		34:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 937
		../../codegen/src/isa/aarch64/inst.isle line 2524
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smulhi, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		16: Option(InstOutput)	some(24)
		20: ALUOp	make_variant(ALUOp::SMulH, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 930
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 924
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 918
		../../codegen/src/isa/aarch64/inst.isle line 2656
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 912
		../../codegen/src/isa/aarch64/inst.isle line 2656
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I32X4)
		16:	some
		18:	some
		20:	const_prim(I32X4)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 906
		../../codegen/src/isa/aarch64/inst.isle line 2652
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 900
		../../codegen/src/isa/aarch64/inst.isle line 2652
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 894
		../../codegen/src/isa/aarch64/inst.isle line 2648
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 888
		../../codegen/src/isa/aarch64/inst.isle line 2648
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I16X8)
		16:	some
		18:	some
		20:	const_prim(I16X8)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 882
		../../codegen/src/isa/aarch64/inst.isle line 2644
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 876
		../../codegen/src/isa/aarch64/inst.isle line 2644
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 870
		../../codegen/src/isa/aarch64/inst.isle line 2640
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 864
		../../codegen/src/isa/aarch64/inst.isle line 2640
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(34)
		30: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		33: ValueRegs	constructor(value_reg, [41], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I8X16)
		16:	some
		18:	some
		20:	const_prim(I8X16)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 825
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/isa/aarch64/inst.isle line 2528
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/isa/aarch64/inst.isle line 2618
		../../codegen/src/isa/aarch64/inst.isle line 2548
		../../codegen/src/isa/aarch64/inst.isle line 2548
		../../codegen/src/isa/aarch64/inst.isle line 2636
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2223
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Value	match_tuple(8, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		17: bool	const_prim(false)
		19: ScalarSize	make_variant(ScalarSize::Size32, [])
		24: Option(InstOutput)	some(59)
		27: VecMisc2	make_variant(VecMisc2::Rev64, [])
		32: VecALUOp	make_variant(VecALUOp::Mul, [])
		37: VecALUOp	make_variant(VecALUOp::Addp, [])
		41: VecRRLongOp	make_variant(VecRRLongOp::Shll32, [])
		45: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		49: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		55: VecRRRLongModOp	make_variant(VecRRRLongModOp::Umlal32, [])
		58: ValueRegs	constructor(value_reg, [105], 1)
		59: InstOutput	constructor(output, [58], 2)
		63: Type	const_prim(I8X16)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		70: Type	const_prim(I8X16)
		71: WritableReg	constructor(temp_writable_reg, [70], 1)
		72: Reg	constructor(writable_reg_to_reg, [71], 0)
		77: Type	const_prim(I8X16)
		78: WritableReg	constructor(temp_writable_reg, [77], 1)
		79: Reg	constructor(writable_reg_to_reg, [78], 0)
		83: Type	const_prim(I8X16)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: Reg	constructor(writable_reg_to_reg, [84], 0)
		89: Type	const_prim(I8X16)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: Reg	constructor(writable_reg_to_reg, [90], 0)
		95: Type	const_prim(I8X16)
		96: WritableReg	constructor(temp_writable_reg, [95], 1)
		97: Reg	constructor(writable_reg_to_reg, [96], 0)
		103: Type	const_prim(I8X16)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: Reg	constructor(writable_reg_to_reg, [104], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 793
		../../codegen/src/isa/aarch64/inst.isle line 2528
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option(())	extractor(not_i64x2, 9)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [9], 3)
		19: Option(InstOutput)	some(27)
		23: VecALUOp	make_variant(VecALUOp::Mul, [])
		26: ValueRegs	constructor(value_reg, [34], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 765
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2520
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		17: Reg	constructor(zero_reg, [], 10)
		19: usize	const_int(1, usize)
		20: Reg	constructor(value_regs_get, [11, 19], 3)
		21: Reg	constructor(value_regs_get, [15, 19], 6)
		25: ValueRegs	constructor(value_regs, [58, 81], 12)
		26: InstOutput	constructor(output, [25], 13)
		27: Option(InstOutput)	some(26)
		32: ALUOp3	make_variant(ALUOp3::MAdd, [])
		37: ALUOp	make_variant(ALUOp::UMulH, [])
		43: ALUOp3	make_variant(ALUOp3::MAdd, [])
		49: ALUOp3	make_variant(ALUOp3::MAdd, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: Reg	constructor(writable_reg_to_reg, [57], 0)
		63: Type	const_prim(I64)
		64: WritableReg	constructor(temp_writable_reg, [63], 1)
		65: Reg	constructor(writable_reg_to_reg, [64], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		79: Type	const_prim(I64)
		80: WritableReg	constructor(temp_writable_reg, [79], 1)
		81: Reg	constructor(writable_reg_to_reg, [80], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 761
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(zero_reg, [], 3)
		18: Option(InstOutput)	some(27)
		23: ALUOp3	make_variant(ALUOp3::MAdd, [])
		26: ValueRegs	constructor(value_reg, [35], 1)
		27: InstOutput	constructor(output, [26], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 755
		../../codegen/src/isa/aarch64/inst.isle line 2532
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(22)
		18: VecMisc2	make_variant(VecMisc2::Neg, [])
		21: ValueRegs	constructor(value_reg, [28], 1)
		22: InstOutput	constructor(output, [21], 2)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [31], 4)
		13: Option(InstOutput)	some(12)
		14: Type	const_prim(I64)
		15: ImmExtend	make_variant(ImmExtend::Zero, [])
		16: u64	const_int(0, u64)
		17: Reg	constructor(imm, [14, 15, 16], 1)
		18: Reg	constructor(imm, [14, 15, 16], 2)
		19: ValueRegs	constructor(value_regs, [17, 18], 3)
		22: Type	const_prim(I64)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [19, 23], 1)
		25: Reg	constructor(value_regs_get, [10, 23], 3)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [19, 27], 2)
		29: Reg	constructor(value_regs_get, [10, 27], 4)
		31: ValueRegs	constructor(with_flags, [41, 51], 7)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::AluRRR, [35, 54, 38, 24, 25])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [39, 40])
		45: ALUOp	make_variant(ALUOp::Sbc, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::AluRRR, [45, 57, 48, 28, 29])
		50: Reg	constructor(writable_reg_to_reg, [48], 0)
		51: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [49, 50])
		53: Option(Type)	extractor(fits_in_64, 22)
		54: OperandSize	make_variant(OperandSize::Size64, [])
		56: Option(Type)	extractor(fits_in_64, 22)
		57: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		53:	some
		56:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [31], 4)
		13: Option(InstOutput)	some(12)
		14: Type	const_prim(I64)
		15: ImmExtend	make_variant(ImmExtend::Zero, [])
		16: u64	const_int(0, u64)
		17: Reg	constructor(imm, [14, 15, 16], 1)
		18: Reg	constructor(imm, [14, 15, 16], 2)
		19: ValueRegs	constructor(value_regs, [17, 18], 3)
		22: Type	const_prim(I64)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [19, 23], 1)
		25: Reg	constructor(value_regs_get, [10, 23], 3)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [19, 27], 2)
		29: Reg	constructor(value_regs_get, [10, 27], 4)
		31: ValueRegs	constructor(with_flags, [41, 51], 7)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::AluRRR, [35, 54, 38, 24, 25])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [39, 40])
		45: ALUOp	make_variant(ALUOp::Sbc, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::AluRRR, [45, 57, 48, 28, 29])
		50: Reg	constructor(writable_reg_to_reg, [48], 0)
		51: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [49, 50])
		53: Option(Type)	extractor(fits_in_64, 22)
		54: OperandSize	make_variant(OperandSize::Size64, [])
		56: Option(Type)	extractor(fits_in_32, 22)
		57: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		53:	some
		56:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [31], 4)
		13: Option(InstOutput)	some(12)
		14: Type	const_prim(I64)
		15: ImmExtend	make_variant(ImmExtend::Zero, [])
		16: u64	const_int(0, u64)
		17: Reg	constructor(imm, [14, 15, 16], 1)
		18: Reg	constructor(imm, [14, 15, 16], 2)
		19: ValueRegs	constructor(value_regs, [17, 18], 3)
		22: Type	const_prim(I64)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [19, 23], 1)
		25: Reg	constructor(value_regs_get, [10, 23], 3)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [19, 27], 2)
		29: Reg	constructor(value_regs_get, [10, 27], 4)
		31: ValueRegs	constructor(with_flags, [41, 51], 7)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::AluRRR, [35, 54, 38, 24, 25])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [39, 40])
		45: ALUOp	make_variant(ALUOp::Sbc, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::AluRRR, [45, 57, 48, 28, 29])
		50: Reg	constructor(writable_reg_to_reg, [48], 0)
		51: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [49, 50])
		53: Option(Type)	extractor(fits_in_32, 22)
		54: OperandSize	make_variant(OperandSize::Size32, [])
		56: Option(Type)	extractor(fits_in_64, 22)
		57: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		53:	some
		56:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1856
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [31], 4)
		13: Option(InstOutput)	some(12)
		14: Type	const_prim(I64)
		15: ImmExtend	make_variant(ImmExtend::Zero, [])
		16: u64	const_int(0, u64)
		17: Reg	constructor(imm, [14, 15, 16], 1)
		18: Reg	constructor(imm, [14, 15, 16], 2)
		19: ValueRegs	constructor(value_regs, [17, 18], 3)
		22: Type	const_prim(I64)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [19, 23], 1)
		25: Reg	constructor(value_regs_get, [10, 23], 3)
		27: usize	const_int(1, usize)
		28: Reg	constructor(value_regs_get, [19, 27], 2)
		29: Reg	constructor(value_regs_get, [10, 27], 4)
		31: ValueRegs	constructor(with_flags, [41, 51], 7)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::AluRRR, [35, 54, 38, 24, 25])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [39, 40])
		45: ALUOp	make_variant(ALUOp::Sbc, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::AluRRR, [45, 57, 48, 28, 29])
		50: Reg	constructor(writable_reg_to_reg, [48], 0)
		51: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [49, 50])
		53: Option(Type)	extractor(fits_in_32, 22)
		54: OperandSize	make_variant(OperandSize::Size32, [])
		56: Option(Type)	extractor(fits_in_32, 22)
		57: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		53:	some
		56:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 747
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Type	match_some(6)
		10: Reg	constructor(zero_reg, [], 1)
		11: Value	match_some(8)
		12: Reg	constructor(put_in_reg, [11], 2)
		15: Option(InstOutput)	some(23)
		19: ALUOp	make_variant(ALUOp::Sub, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 741
		../../codegen/src/isa/aarch64/inst.isle line 2516
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Sqsub, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 736
		../../codegen/src/isa/aarch64/inst.isle line 2512
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Uqsub, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 731
		../../codegen/src/isa/aarch64/inst.isle line 2508
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Sqadd, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 726
		../../codegen/src/isa/aarch64/inst.isle line 2504
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(26)
		22: VecALUOp	make_variant(VecALUOp::Uqadd, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [27], 4)
		15: Option(InstOutput)	some(14)
		18: Type	const_prim(I64)
		19: usize	const_int(0, usize)
		20: Reg	constructor(value_regs_get, [10, 19], 1)
		21: Reg	constructor(value_regs_get, [12, 19], 3)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Reg	constructor(value_regs_get, [12, 23], 4)
		27: ValueRegs	constructor(with_flags, [37, 47], 7)
		31: ALUOp	make_variant(ALUOp::SubS, [])
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::AluRRR, [31, 50, 34, 20, 21])
		36: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [35, 36])
		41: ALUOp	make_variant(ALUOp::Sbc, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::AluRRR, [41, 53, 44, 24, 25])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [45, 46])
		49: Option(Type)	extractor(fits_in_64, 18)
		50: OperandSize	make_variant(OperandSize::Size64, [])
		52: Option(Type)	extractor(fits_in_64, 18)
		53: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		49:	some
		52:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [27], 4)
		15: Option(InstOutput)	some(14)
		18: Type	const_prim(I64)
		19: usize	const_int(0, usize)
		20: Reg	constructor(value_regs_get, [10, 19], 1)
		21: Reg	constructor(value_regs_get, [12, 19], 3)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Reg	constructor(value_regs_get, [12, 23], 4)
		27: ValueRegs	constructor(with_flags, [37, 47], 7)
		31: ALUOp	make_variant(ALUOp::SubS, [])
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::AluRRR, [31, 50, 34, 20, 21])
		36: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [35, 36])
		41: ALUOp	make_variant(ALUOp::Sbc, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::AluRRR, [41, 53, 44, 24, 25])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [45, 46])
		49: Option(Type)	extractor(fits_in_64, 18)
		50: OperandSize	make_variant(OperandSize::Size64, [])
		52: Option(Type)	extractor(fits_in_32, 18)
		53: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		49:	some
		52:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [27], 4)
		15: Option(InstOutput)	some(14)
		18: Type	const_prim(I64)
		19: usize	const_int(0, usize)
		20: Reg	constructor(value_regs_get, [10, 19], 1)
		21: Reg	constructor(value_regs_get, [12, 19], 3)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Reg	constructor(value_regs_get, [12, 23], 4)
		27: ValueRegs	constructor(with_flags, [37, 47], 7)
		31: ALUOp	make_variant(ALUOp::SubS, [])
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::AluRRR, [31, 50, 34, 20, 21])
		36: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [35, 36])
		41: ALUOp	make_variant(ALUOp::Sbc, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::AluRRR, [41, 53, 44, 24, 25])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [45, 46])
		49: Option(Type)	extractor(fits_in_32, 18)
		50: OperandSize	make_variant(OperandSize::Size32, [])
		52: Option(Type)	extractor(fits_in_64, 18)
		53: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		49:	some
		52:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2467
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [27], 4)
		15: Option(InstOutput)	some(14)
		18: Type	const_prim(I64)
		19: usize	const_int(0, usize)
		20: Reg	constructor(value_regs_get, [10, 19], 1)
		21: Reg	constructor(value_regs_get, [12, 19], 3)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Reg	constructor(value_regs_get, [12, 23], 4)
		27: ValueRegs	constructor(with_flags, [37, 47], 7)
		31: ALUOp	make_variant(ALUOp::SubS, [])
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::AluRRR, [31, 50, 34, 20, 21])
		36: Reg	constructor(writable_reg_to_reg, [34], 0)
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [35, 36])
		41: ALUOp	make_variant(ALUOp::Sbc, [])
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: MInst	make_variant(MInst::AluRRR, [41, 53, 44, 24, 25])
		46: Reg	constructor(writable_reg_to_reg, [44], 0)
		47: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [45, 46])
		49: Option(Type)	extractor(fits_in_32, 18)
		50: OperandSize	make_variant(OperandSize::Size32, [])
		52: Option(Type)	extractor(fits_in_32, 18)
		53: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		49:	some
		52:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 717
		../../codegen/src/isa/aarch64/inst.isle line 2464
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		17: Option(InstOutput)	some(25)
		21: VecALUOp	make_variant(VecALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 711
		../../codegen/src/isa/aarch64/inst.isle line 2461
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(38)
		34: ALUOp	make_variant(ALUOp::Sub, [])
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 706
		../../codegen/src/isa/aarch64/inst.isle line 2458
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2035
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Sub, [])
		25: ValueRegs	constructor(value_reg, [41], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Reg	constructor(put_extended_in_reg, [15], 1)
		32: ExtendOp	constructor(get_extended_op, [15], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 700
		../../codegen/src/isa/aarch64/inst.isle line 1810
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(33)
		18: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Type, Inst))	extractor(has_type, 21)
		23: (Type, Inst)	match_some(22)
		24: Inst	match_tuple(23, 1)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Type	match_tuple(23, 0)
		27: Imm64	match_some(25)
		28: i64	constructor(i64_sextend_imm64, [26, 27], 0)
		29: i64	constructor(i64_neg, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		31: Option(Imm12)	extractor(imm12_from_u64, 30)
		32: Imm12	match_some(31)
		33: Option(Imm12)	some(32)
		37: ALUOp	make_variant(ALUOp::Add, [])
		40: ValueRegs	constructor(value_reg, [48], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		22:	some
		25:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 695
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Sub, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 691
		../../codegen/src/isa/aarch64/inst.isle line 2452
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		17: Option(InstOutput)	some(25)
		21: ALUOp	make_variant(ALUOp::Sub, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 683
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 677
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 674
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 671
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 668
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 663
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 660
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 657
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		16: Option(InstOutput)	some(19)
		18: ValueRegs	constructor(value_reg, [14], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 654
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 651
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 648
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 643
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::I64ToF64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		14: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 640
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::I64ToF32, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		14: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(32)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		18:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(32)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(true)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		18:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 631
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 628
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 623
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::U64ToF64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		14: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 620
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::U64ToF32, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		14: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(32)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
		18:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(26)
		17: Type	extractor(value_type, 8)
		18: Reg	constructor(put_in_reg, [8], 1)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		17:	const_prim(I32)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 3687
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(32)
		17: Type	extractor(value_type, 8)
		18: Option(Type)	extractor(fits_in_32, 17)
		19: Reg	constructor(put_in_reg, [8], 1)
		20: bool	const_prim(false)
		21: Type	match_some(18)
		22: u8	constructor(ty_bits, [21], 0)
		23: u8	const_int(32, u8)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
		18:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 611
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 608
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [5], 2)
		21: Option(InstOutput)	some(30)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 603
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 11])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 11, 11])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 600
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [63], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 12])
		44: ValueRegs	constructor(with_flags, [68, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [73, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		67: MInst	make_variant(MInst::FpuCmp, [24, 12, 12])
		68: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [67])
		72: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		73: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [72])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 597
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 11])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 11, 11])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 594
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(true)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [63], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 12])
		44: ValueRegs	constructor(with_flags, [68, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [73, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		67: MInst	make_variant(MInst::FpuCmp, [24, 12, 12])
		68: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [67])
		72: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		73: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [72])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 589
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 11])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 11, 11])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 586
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [63], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 12])
		44: ValueRegs	constructor(with_flags, [68, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [73, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		67: MInst	make_variant(MInst::FpuCmp, [24, 12, 12])
		68: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [67])
		72: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		73: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [72])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 583
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(34)
		23: ScalarSize	constructor(scalar_size, [13], 1)
		25: u8	constructor(ty_bits, [13], 0)
		26: u8	constructor(ty_bits, [14], 0)
		27: Reg	constructor(min_fp_value, [12, 25, 26], 3)
		28: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 45, 27], 4)
		29: Reg	constructor(max_fp_value, [12, 25, 26], 5)
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 2)
		40: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 11])
		43: ValueRegs	constructor(with_flags, [67, 42], 3)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 4)
		50: Cond	make_variant(Cond::Ge, [])
		51: CondBrKind	constructor(cond_br_cond, [50], 2)
		52: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		53: MInst	make_variant(MInst::TrapIf, [51, 52])
		54: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [53, 28])
		55: ValueRegs	constructor(with_flags, [72, 54], 3)
		56: usize	const_int(0, usize)
		57: Reg	constructor(value_regs_get, [55, 56], 4)
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: Reg	constructor(writable_reg_to_reg, [61], 0)
		66: MInst	make_variant(MInst::FpuCmp, [23, 11, 11])
		67: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [66])
		71: MInst	make_variant(MInst::FpuCmp, [23, 28, 29])
		72: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [71])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 580
		../../codegen/src/isa/aarch64/inst.isle line 3631
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3568
		../../codegen/src/isa/aarch64/inst.isle line 3615
		../../codegen/src/isa/aarch64/inst.isle line 3679
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 1962
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		12: Reg	constructor(put_in_reg, [9], 1)
		13: bool	const_prim(false)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(35)
		24: ScalarSize	constructor(scalar_size, [14], 1)
		26: u8	constructor(ty_bits, [14], 0)
		27: u8	constructor(ty_bits, [15], 0)
		28: Reg	constructor(min_fp_value, [13, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [13, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [63], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 12])
		44: ValueRegs	constructor(with_flags, [68, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [73, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: Reg	constructor(writable_reg_to_reg, [62], 0)
		67: MInst	make_variant(MInst::FpuCmp, [24, 12, 12])
		68: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [67])
		72: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		73: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [72])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3559
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(25)
		19: Option((u32, u32))	extractor(multi_lane, 12)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/isa/aarch64/inst.isle line 3554
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		15: Option(InstOutput)	some(25)
		19: Option(Type)	extractor(ty_scalar_float, 12)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		19:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 520
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: VecALUModOp	make_variant(VecALUModOp::Fmla, [])
		10: (Value, Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: Value	match_tuple(10, 2)
		14: VectorSize	constructor(vector_size, [5], 1)
		15: Reg	constructor(lower_fmla, [9, 11, 12, 13, 14], 2)
		17: Option(InstOutput)	some(20)
		19: ValueRegs	constructor(value_reg, [15], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 516
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: FPUOp3	make_variant(FPUOp3::MAdd, [])
		10: Type	match_some(6)
		11: ScalarSize	constructor(scalar_size, [10], 1)
		12: (Value, Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Value	match_tuple(12, 2)
		18: Reg	constructor(put_in_reg, [17], 4)
		21: Option(InstOutput)	some(32)
		27: Type	const_prim(F64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 511
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Nearest64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 508
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Nearest32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 505
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(nearest, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintn, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 500
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Zero64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 497
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Zero32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 494
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(trunc, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintz, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 489
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Minus64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 486
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Minus32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 483
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(floor, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintm, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 478
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Plus64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 475
		../../codegen/src/isa/aarch64/inst.isle line 2253
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: FpuRoundMode	make_variant(FpuRoundMode::Plus32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 472
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ceil, 7)
		9: VecMisc2	make_variant(VecMisc2::Frintp, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 467
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fdemote, 6)
		8: FPUOp1	make_variant(FPUOp1::Cvt64To32, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: Option(InstOutput)	some(23)
		18: Type	const_prim(F64)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 462
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fpromote, 6)
		8: FPUOp1	make_variant(FPUOp1::Cvt32To64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		14: Option(InstOutput)	some(23)
		18: Type	const_prim(F64)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 457
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: FPUOp1	make_variant(FPUOp1::Abs, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		16: Option(InstOutput)	some(25)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 454
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: VecMisc2	make_variant(VecMisc2::Fabs, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 449
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: FPUOp1	make_variant(FPUOp1::Neg, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		16: Option(InstOutput)	some(25)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 446
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: VecMisc2	make_variant(VecMisc2::Fneg, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 441
		../../codegen/src/isa/aarch64/inst.isle line 1913
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: FPUOp1	make_variant(FPUOp1::Sqrt, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		16: Option(InstOutput)	some(25)
		20: Type	const_prim(F64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 438
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: VecMisc2	make_variant(VecMisc2::Fsqrt, [])
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [5], 2)
		15: Option(InstOutput)	some(24)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: Reg	constructor(writable_reg_to_reg, [20], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 433
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: FPUOp2	make_variant(FPUOp2::Max, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 430
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmax, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 425
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: FPUOp2	make_variant(FPUOp2::Min, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 422
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmin, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 417
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: FPUOp2	make_variant(FPUOp2::Div, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 414
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 409
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: FPUOp2	make_variant(FPUOp2::Mul, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 406
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmul, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 401
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: FPUOp2	make_variant(FPUOp2::Sub, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 398
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: VecALUOp	make_variant(VecALUOp::Fsub, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 393
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Add, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: ScalarSize	constructor(scalar_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(F64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 390
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fadd, 7)
		9: VecALUOp	make_variant(VecALUOp::Fadd, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 385
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sqmul_round_sat, 7)
		9: VecALUOp	make_variant(VecALUOp::Sqrdmulh, [])
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [5], 3)
		18: Option(InstOutput)	some(28)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(avg_round, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(lane_fits_in_32, 7)
		9: VecALUOp	make_variant(VecALUOp::Urhadd, [])
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 371
		../../codegen/src/isa/aarch64/inst.isle line 2715
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/isa/aarch64/inst.isle line 2757
		../../codegen/src/isa/aarch64/inst.isle line 2757
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(avg_round, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 3)
		13: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: u64	const_int(1, u64)
		16: Reg	constructor(splat_const, [15, 13], 1)
		18: Reg	constructor(put_in_reg, [9], 6)
		19: u8	const_int(1, u8)
		21: Reg	constructor(put_in_reg, [11], 8)
		26: Option(InstOutput)	some(59)
		30: VecALUOp	make_variant(VecALUOp::Orr, [])
		35: VecALUOp	make_variant(VecALUOp::And, [])
		40: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		45: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		50: VecALUOp	make_variant(VecALUOp::Add, [])
		55: VecALUOp	make_variant(VecALUOp::Add, [])
		58: ValueRegs	constructor(value_reg, [101], 1)
		59: InstOutput	constructor(output, [58], 2)
		64: Type	const_prim(I8X16)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I8X16)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		78: Type	const_prim(I8X16)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: Reg	constructor(writable_reg_to_reg, [79], 0)
		85: Type	const_prim(I8X16)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: Reg	constructor(writable_reg_to_reg, [86], 0)
		92: Type	const_prim(I8X16)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: Reg	constructor(writable_reg_to_reg, [93], 0)
		99: Type	const_prim(I8X16)
		100: WritableReg	constructor(temp_writable_reg, [99], 1)
		101: Reg	constructor(writable_reg_to_reg, [100], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [44, 59], 10)
		23: InstOutput	constructor(output, [22], 11)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::Asr, [])
		33: ALUOp	make_variant(ALUOp::Eor, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 76, 41, 73, 66])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		48: ALUOp	make_variant(ALUOp::Eor, [])
		53: ALUOp	make_variant(ALUOp::Sbc, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::AluRRR, [53, 86, 56, 83, 66])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		75: Option(Type)	extractor(fits_in_64, 8)
		76: OperandSize	make_variant(OperandSize::Size64, [])
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		85: Option(Type)	extractor(fits_in_64, 8)
		86: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		75:	some
		85:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [44, 59], 10)
		23: InstOutput	constructor(output, [22], 11)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::Asr, [])
		33: ALUOp	make_variant(ALUOp::Eor, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 76, 41, 73, 66])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		48: ALUOp	make_variant(ALUOp::Eor, [])
		53: ALUOp	make_variant(ALUOp::Sbc, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::AluRRR, [53, 86, 56, 83, 66])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		75: Option(Type)	extractor(fits_in_64, 8)
		76: OperandSize	make_variant(OperandSize::Size64, [])
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		85: Option(Type)	extractor(fits_in_32, 8)
		86: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		75:	some
		85:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [44, 59], 10)
		23: InstOutput	constructor(output, [22], 11)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::Asr, [])
		33: ALUOp	make_variant(ALUOp::Eor, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 76, 41, 73, 66])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		48: ALUOp	make_variant(ALUOp::Eor, [])
		53: ALUOp	make_variant(ALUOp::Sbc, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::AluRRR, [53, 86, 56, 83, 66])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		75: Option(Type)	extractor(fits_in_32, 8)
		76: OperandSize	make_variant(OperandSize::Size32, [])
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		85: Option(Type)	extractor(fits_in_64, 8)
		86: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		75:	some
		85:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2096
		../../codegen/src/isa/aarch64/inst.isle line 2730
		../../codegen/src/isa/aarch64/inst.isle line 2141
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Type	const_prim(I64)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		22: ValueRegs	constructor(with_flags, [44, 59], 10)
		23: InstOutput	constructor(output, [22], 11)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::Asr, [])
		33: ALUOp	make_variant(ALUOp::Eor, [])
		38: ALUOp	make_variant(ALUOp::SubS, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 76, 41, 73, 66])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		48: ALUOp	make_variant(ALUOp::Eor, [])
		53: ALUOp	make_variant(ALUOp::Sbc, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::AluRRR, [53, 86, 56, 83, 66])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [57, 58])
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: Reg	constructor(writable_reg_to_reg, [65], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: Reg	constructor(writable_reg_to_reg, [72], 0)
		75: Option(Type)	extractor(fits_in_32, 8)
		76: OperandSize	make_variant(OperandSize::Size32, [])
		81: Type	const_prim(I64)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: Reg	constructor(writable_reg_to_reg, [82], 0)
		85: Option(Type)	extractor(fits_in_32, 8)
		86: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		75:	some
		85:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2972
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_some(6)
		14: Option(InstOutput)	some(30)
		16: Type	extractor(value_type, 10)
		17: Reg	constructor(put_in_reg, [10], 1)
		20: u8	const_int(0, u8)
		21: Imm12	constructor(u8_into_imm12, [20], 1)
		23: Cond	make_variant(Cond::Gt, [])
		25: ValueRegs	constructor(with_flags, [37, 45], 4)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 5)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRImm12, [34, 9, 35, 17, 21])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::CSNeg, [42, 23, 17, 17])
		44: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 44])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		16:	const_prim(I64)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2971
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_some(6)
		14: Option(InstOutput)	some(30)
		16: Type	extractor(value_type, 10)
		17: Reg	constructor(put_in_reg, [10], 1)
		20: u8	const_int(0, u8)
		21: Imm12	constructor(u8_into_imm12, [20], 1)
		23: Cond	make_variant(Cond::Gt, [])
		25: ValueRegs	constructor(with_flags, [37, 45], 4)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 5)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
		34: ALUOp	make_variant(ALUOp::SubS, [])
		35: WritableReg	constructor(writable_zero_reg, [], 1)
		36: MInst	make_variant(MInst::AluRRImm12, [34, 9, 35, 17, 21])
		37: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [36])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::CSNeg, [42, 23, 17, 17])
		44: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 44])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		16:	const_prim(I32)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2967
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_some(6)
		14: Option(InstOutput)	some(36)
		16: Type	extractor(value_type, 10)
		17: Option(Type)	extractor(fits_in_32, 16)
		18: Reg	constructor(put_in_reg, [10], 1)
		19: bool	const_prim(true)
		20: Type	match_some(17)
		21: u8	constructor(ty_bits, [20], 0)
		22: u8	const_int(32, u8)
		26: u8	const_int(0, u8)
		27: Imm12	constructor(u8_into_imm12, [26], 1)
		29: Cond	make_variant(Cond::Gt, [])
		31: ValueRegs	constructor(with_flags, [50, 58], 4)
		32: usize	const_int(0, usize)
		33: Reg	constructor(value_regs_get, [31, 32], 5)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: ALUOp	make_variant(ALUOp::SubS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 1)
		49: MInst	make_variant(MInst::AluRRImm12, [47, 9, 48, 43, 27])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::CSNeg, [55, 29, 43, 43])
		57: Reg	constructor(writable_reg_to_reg, [55], 0)
		58: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [56, 57])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		17:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 345
		../../codegen/src/isa/aarch64/inst.isle line 2608
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2407
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: OperandSize	make_variant(OperandSize::Size64, [])
		9: Value	match_some(7)
		10: Reg	constructor(put_in_reg, [9], 1)
		13: Option(InstOutput)	some(26)
		16: u8	const_int(0, u8)
		17: Imm12	constructor(u8_into_imm12, [16], 1)
		19: Cond	make_variant(Cond::Gt, [])
		21: ValueRegs	constructor(with_flags, [33, 41], 4)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 5)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: ALUOp	make_variant(ALUOp::SubS, [])
		31: WritableReg	constructor(writable_zero_reg, [], 1)
		32: MInst	make_variant(MInst::AluRRImm12, [30, 8, 31, 10, 17])
		33: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [32])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::CSNeg, [38, 19, 10, 10])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [39, 40])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 342
		../../codegen/src/isa/aarch64/inst.isle line 2603
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(iabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		14: Option(InstOutput)	some(21)
		17: VecMisc2	make_variant(VecMisc2::Abs, [])
		20: ValueRegs	constructor(value_reg, [27], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 337
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd_pairwise, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		13: VectorSize	constructor(vector_size, [12], 3)
		16: Option(InstOutput)	some(24)
		20: VecALUOp	make_variant(VecALUOp::Addp, [])
		23: ValueRegs	constructor(value_reg, [31], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 334
		../../codegen/src/isa/aarch64/inst.isle line 2632
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp16, [])
		27: ValueRegs	constructor(value_reg, [33], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 2629
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp8, [])
		27: ValueRegs	constructor(value_reg, [33], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 326
		../../codegen/src/isa/aarch64/inst.isle line 2626
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp16, [])
		27: ValueRegs	constructor(value_reg, [33], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 322
		../../codegen/src/isa/aarch64/inst.isle line 2623
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(28)
		24: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp8, [])
		27: ValueRegs	constructor(value_reg, [33], 1)
		28: InstOutput	constructor(output, [27], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 3806
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2124
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [40, 27], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
		15: Option(Type)	constructor(ty_vec64, [6], 0)
		16: OperandSize	make_variant(OperandSize::Size64, [])
		17: u8	const_int(0, u8)
		18: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: Imm12	constructor(u8_into_imm12, [17], 2)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::CSet, [24, 8])
		26: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [25, 26])
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: WritableReg	constructor(writable_zero_reg, [], 1)
		39: MInst	make_variant(MInst::AluRRImm12, [37, 16, 38, 33, 20])
		40: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [39])
	]
	constraints = [
		3:	some
		15:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 3802
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2124
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [50, 30], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
		15: Option(Type)	extractor(ty_vec128, 6)
		16: OperandSize	make_variant(OperandSize::Size64, [])
		17: VecALUOp	make_variant(VecALUOp::Umaxp, [])
		18: VectorSize	make_variant(VectorSize::Size32x4, [])
		20: u8	const_int(0, u8)
		21: ScalarSize	make_variant(ScalarSize::Size64, [])
		23: Imm12	constructor(u8_into_imm12, [20], 3)
		26: Type	const_prim(I64)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::CSet, [27, 8])
		29: Reg	constructor(writable_reg_to_reg, [27], 0)
		30: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [28, 29])
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: Reg	constructor(writable_reg_to_reg, [36], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: Reg	constructor(writable_reg_to_reg, [42], 0)
		47: ALUOp	make_variant(ALUOp::SubS, [])
		48: WritableReg	constructor(writable_zero_reg, [], 1)
		49: MInst	make_variant(MInst::AluRRImm12, [47, 16, 48, 43, 23])
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [49])
	]
	constraints = [
		3:	some
		15:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 306
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Type	match_some(6)
		8: Option(Type)	constructor(not_vec32x2, [7], 0)
		9: OperandSize	make_variant(OperandSize::Size64, [])
		10: VecLanesOp	make_variant(VecLanesOp::Uminv, [])
		11: Reg	constructor(put_in_reg, [4], 1)
		12: VectorSize	constructor(vector_size, [7], 2)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Imm12	constructor(u8_into_imm12, [14], 5)
		19: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(with_flags, [42, 48], 8)
		22: InstOutput	constructor(output, [21], 9)
		23: Option(InstOutput)	some(22)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: WritableReg	constructor(writable_zero_reg, [], 1)
		41: MInst	make_variant(MInst::AluRRImm12, [39, 9, 40, 35, 17])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 19])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [46, 47])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 289
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2018
		../../codegen/src/isa/aarch64/inst.isle line 2422
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Reg	constructor(zero_reg, [], 3)
		12: Reg	constructor(put_in_reg, [4], 1)
		13: u8	const_int(0, u8)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: u64	const_int(32, u64)
		18: OperandSize	make_variant(OperandSize::Size32, [])
		19: UImm5	constructor(u8_into_uimm5, [13], 5)
		20: bool	const_prim(false)
		21: bool	const_prim(true)
		22: NZCV	constructor(nzcv, [20, 21, 20, 20], 6)
		23: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(with_flags, [44, 56], 8)
		26: InstOutput	constructor(output, [25], 9)
		27: Option(InstOutput)	some(26)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
		38: Type	const_prim(I64)
		39: Option(ShiftOpAndAmt)	constructor(lshr_from_u64, [38, 16], 0)
		40: ALUOp	make_variant(ALUOp::SubS, [])
		41: WritableReg	constructor(writable_zero_reg, [], 1)
		42: ShiftOpAndAmt	match_some(39)
		43: MInst	make_variant(MInst::AluRRRShift, [40, 10, 41, 11, 33, 42])
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [43])
		50: MInst	make_variant(MInst::CCmpImm, [18, 33, 19, 22, 23])
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: MInst	make_variant(MInst::CSet, [52, 23])
		54: Reg	constructor(writable_reg_to_reg, [52], 0)
		55: ValueRegs	constructor(value_reg, [54], 2)
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [50, 53, 55])
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		9:	const_int(2)
		39:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 283
		../../codegen/src/isa/aarch64/inst.isle line 3415
		../../codegen/src/isa/aarch64/inst.isle line 2595
		../../codegen/src/isa/aarch64/inst.isle line 1962
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: Reg	constructor(put_in_reg, [4], 1)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Cond	make_variant(Cond::Eq, [])
		18: ValueRegs	constructor(with_flags, [34, 40], 6)
		19: InstOutput	constructor(output, [18], 7)
		20: Option(InstOutput)	some(19)
		23: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		28: VecALUOp	make_variant(VecALUOp::Addp, [])
		33: MInst	make_variant(MInst::FpuCmp, [10, 53, 53])
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [33])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::CSet, [37, 16])
		39: Reg	constructor(writable_reg_to_reg, [37], 0)
		40: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [38, 39])
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: Type	const_prim(I8X16)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		9:	const_int(2)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2981
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(22)
		13: Type	extractor(value_type, 4)
		14: Reg	constructor(put_in_reg, [4], 1)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		13:	const_prim(I64)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2980
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(22)
		13: Type	extractor(value_type, 4)
		14: Reg	constructor(put_in_reg, [4], 1)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		13:	const_prim(I32)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2976
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2319
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(28)
		13: Type	extractor(value_type, 4)
		14: Option(Type)	extractor(fits_in_32, 13)
		15: Reg	constructor(put_in_reg, [4], 1)
		16: bool	const_prim(false)
		17: Type	match_some(14)
		18: u8	constructor(ty_bits, [17], 0)
		19: u8	const_int(32, u8)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: Reg	constructor(writable_reg_to_reg, [24], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
		14:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 266
		../../codegen/src/isa/aarch64/inst.isle line 2271
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: ScalarSize	make_variant(ScalarSize::Size64, [])
		10: Option(InstOutput)	some(18)
		13: Type	const_prim(I8X16)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: Reg	constructor(writable_reg_to_reg, [14], 0)
		17: ValueRegs	constructor(value_reg, [15], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 263
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F32X4)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64X2)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 260
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		13: Option(InstOutput)	some(21)
		16: Type	const_prim(F32X4)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: Reg	constructor(writable_reg_to_reg, [17], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32X4)
		7:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 255
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iconcat, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: ValueRegs	constructor(value_regs, [10, 12], 3)
		14: InstOutput	constructor(output, [13], 4)
		15: Option(InstOutput)	some(14)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 246
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(isplit, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: ValueRegs	constructor(put_in_regs, [4], 1)
		7: usize	const_int(0, usize)
		8: Reg	constructor(value_regs_get, [6, 7], 2)
		9: ValueRegs	constructor(value_reg, [8], 3)
		10: usize	const_int(1, usize)
		11: Reg	constructor(value_regs_get, [6, 10], 4)
		12: ValueRegs	constructor(value_reg, [11], 5)
		13: InstOutput	constructor(output_pair, [9, 12], 6)
		14: Option(InstOutput)	some(13)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 241
		../../codegen/src/isa/aarch64/inst.isle line 2156
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(swizzle, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		14: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 235
		../../codegen/src/isa/aarch64/inst.isle line 2169
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Immediate))	extractor(shuffle, 5)
		7: (Value, Value, Immediate)	match_some(6)
		8: Immediate	match_tuple(7, 2)
		9: Option(u128)	extractor(u128_from_immediate, 8)
		10: Value	match_tuple(7, 0)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Value	match_tuple(7, 1)
		13: Reg	constructor(put_in_reg, [12], 3)
		14: u128	match_some(9)
		15: Reg	constructor(constant_f128, [14], 1)
		16: Type	match_tuple(4, 0)
		19: Option(InstOutput)	some(29)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 232
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev64, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(14673614102390417578512422760905835780)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 230
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev64, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(12004814239757670119517129289737963270)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 228
		../../codegen/src/isa/aarch64/inst.isle line 2544
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev64, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(10680758337341567148842519922299176455)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 226
		../../codegen/src/isa/aarch64/inst.isle line 2540
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev32, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(17342576855639742879858139805557719810)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 224
		../../codegen/src/isa/aarch64/inst.isle line 2540
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev32, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(16018520953223639909183530438118932995)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 222
		../../codegen/src/isa/aarch64/inst.isle line 2536
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2149
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(20)
		16: VecMisc2	make_variant(VecMisc2::Rev16, [])
		19: ValueRegs	constructor(value_reg, [26], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(18687320815856387368178823909286805505)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 212
		../../codegen/src/isa/aarch64/inst.isle line 4192
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909301208165426529540)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 210
		../../codegen/src/isa/aarch64/inst.isle line 4188
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664569647092737326704519438008576)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 208
		../../codegen/src/isa/aarch64/inst.isle line 4192
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142128814346332279593629287318274)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 206
		../../codegen/src/isa/aarch64/inst.isle line 4188
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693260819630515246292341806293057792)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 204
		../../codegen/src/isa/aarch64/inst.isle line 4192
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284541550424544734358823780242100481)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 202
		../../codegen/src/isa/aarch64/inst.isle line 4188
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Trn1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(39950100895832629191365197868744970240)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 194
		../../codegen/src/isa/aarch64/inst.isle line 4184
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909590568856778836232)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 192
		../../codegen/src/isa/aarch64/inst.isle line 4180
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901951279430565641561564801794304)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 190
		../../codegen/src/isa/aarch64/inst.isle line 4184
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142129435743685477327603181816072)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 188
		../../codegen/src/isa/aarch64/inst.isle line 4180
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686616892700419341528320311204774144)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 186
		../../codegen/src/isa/aarch64/inst.isle line 4184
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284561912683712994304547342093195272)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 184
		../../codegen/src/isa/aarch64/inst.isle line 4180
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Zip1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30609036675948388650355540050116153344)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 179
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427191743139026172726477975062792)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 177
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901955007814682223719185998020864)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 175
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427190500344320355979912890680580)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 173
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664572132682148381476266902159616)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 171
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362386467224802506860000736977486594)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 169
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693505158040971420872748913983226112)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 167
		../../codegen/src/isa/aarch64/inst.isle line 4176
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41357194091136896220700492464948314881)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 165
		../../codegen/src/isa/aarch64/inst.isle line 4172
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(23)
		19: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		22: ValueRegs	constructor(value_reg, [30], 1)
		23: InstOutput	constructor(output, [22], 2)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: Reg	constructor(writable_reg_to_reg, [29], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(40022753436544980677706866553451184640)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 152
		../../codegen/src/isa/aarch64/inst.isle line 2340
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(vec_extract_imm4_from_immediate, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Value	match_tuple(4, 1)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: u8	match_some(6)
		14: Option(InstOutput)	some(23)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: Reg	constructor(writable_reg_to_reg, [19], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 133
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup64_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size64x2, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 131
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup32_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 129
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup16_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 127
		../../codegen/src/isa/aarch64/inst.isle line 1989
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup8_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(22)
		17: Type	const_prim(I8X16)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: Reg	constructor(writable_reg_to_reg, [18], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [34, 44], 9)
		23: InstOutput	constructor(output, [22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::AddS, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::AluRRR, [28, 47, 31, 13, 16])
		33: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [32, 33])
		38: ALUOp	make_variant(ALUOp::Adc, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 50, 41, 19, 20])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [42, 43])
		46: Option(Type)	extractor(fits_in_64, 8)
		47: OperandSize	make_variant(OperandSize::Size64, [])
		49: Option(Type)	extractor(fits_in_64, 8)
		50: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		46:	some
		49:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1227
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [34, 44], 9)
		23: InstOutput	constructor(output, [22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::AddS, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::AluRRR, [28, 47, 31, 13, 16])
		33: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [32, 33])
		38: ALUOp	make_variant(ALUOp::Adc, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 50, 41, 19, 20])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [42, 43])
		46: Option(Type)	extractor(fits_in_64, 8)
		47: OperandSize	make_variant(OperandSize::Size64, [])
		49: Option(Type)	extractor(fits_in_32, 8)
		50: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		46:	some
		49:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [34, 44], 9)
		23: InstOutput	constructor(output, [22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::AddS, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::AluRRR, [28, 47, 31, 13, 16])
		33: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [32, 33])
		38: ALUOp	make_variant(ALUOp::Adc, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 50, 41, 19, 20])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [42, 43])
		46: Option(Type)	extractor(fits_in_32, 8)
		47: OperandSize	make_variant(OperandSize::Size32, [])
		49: Option(Type)	extractor(fits_in_64, 8)
		50: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		46:	some
		49:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2080
		../../codegen/src/isa/aarch64/inst.isle line 2088
		../../codegen/src/isa/aarch64/inst.isle line 1226
		../../codegen/src/isa/aarch64/inst.isle line 1226
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: Type	const_prim(I64)
		9: (Value, Value)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Value	match_tuple(9, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 4)
		16: Reg	constructor(value_regs_get, [15, 12], 5)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [11, 18], 3)
		20: Reg	constructor(value_regs_get, [15, 18], 6)
		22: ValueRegs	constructor(with_flags, [34, 44], 9)
		23: InstOutput	constructor(output, [22], 10)
		24: Option(InstOutput)	some(23)
		28: ALUOp	make_variant(ALUOp::AddS, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::AluRRR, [28, 47, 31, 13, 16])
		33: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [32, 33])
		38: ALUOp	make_variant(ALUOp::Adc, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::AluRRR, [38, 50, 41, 19, 20])
		43: Reg	constructor(writable_reg_to_reg, [41], 0)
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [42, 43])
		46: Option(Type)	extractor(fits_in_32, 8)
		47: OperandSize	make_variant(OperandSize::Size32, [])
		49: Option(Type)	extractor(fits_in_32, 8)
		50: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		46:	some
		49:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 100
		../../codegen/src/isa/aarch64/inst.isle line 2447
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		17: Option(InstOutput)	some(25)
		21: VecALUOp	make_variant(VecALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 95
		../../codegen/src/isa/aarch64/inst.isle line 2492
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: Type	match_some(6)
		15: (Value, Value)	match_some(13)
		16: Value	match_tuple(15, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_tuple(15, 1)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Value	match_tuple(9, 0)
		21: Reg	constructor(put_in_reg, [20], 3)
		24: Option(InstOutput)	some(33)
		29: ALUOp3	make_variant(ALUOp3::MSub, [])
		32: ValueRegs	constructor(value_reg, [41], 1)
		33: InstOutput	constructor(output, [32], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 91
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: Type	match_some(6)
		15: (Value, Value)	match_some(13)
		16: Value	match_tuple(15, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_tuple(15, 1)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Value	match_tuple(9, 1)
		21: Reg	constructor(put_in_reg, [20], 3)
		24: Option(InstOutput)	some(33)
		29: ALUOp3	make_variant(ALUOp3::MAdd, [])
		32: ValueRegs	constructor(value_reg, [41], 1)
		33: InstOutput	constructor(output, [32], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 88
		../../codegen/src/isa/aarch64/inst.isle line 2487
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2050
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: Type	match_some(6)
		15: (Value, Value)	match_some(13)
		16: Value	match_tuple(15, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_tuple(15, 1)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Value	match_tuple(9, 0)
		21: Reg	constructor(put_in_reg, [20], 3)
		24: Option(InstOutput)	some(33)
		29: ALUOp3	make_variant(ALUOp3::MAdd, [])
		32: ValueRegs	constructor(value_reg, [41], 1)
		33: InstOutput	constructor(output, [32], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 82
		../../codegen/src/isa/aarch64/inst.isle line 2444
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 1)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(38)
		34: ALUOp	make_variant(ALUOp::Add, [])
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 77
		../../codegen/src/isa/aarch64/inst.isle line 2444
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(38)
		34: ALUOp	make_variant(ALUOp::Add, [])
		37: ValueRegs	constructor(value_reg, [46], 1)
		38: InstOutput	constructor(output, [37], 2)
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 72
		../../codegen/src/isa/aarch64/inst.isle line 2438
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2035
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [41], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Reg	constructor(put_extended_in_reg, [15], 1)
		32: ExtendOp	constructor(get_extended_op, [15], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 69
		../../codegen/src/isa/aarch64/inst.isle line 2438
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2035
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [41], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Reg	constructor(put_extended_in_reg, [15], 1)
		32: ExtendOp	constructor(get_extended_op, [15], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 63
		../../codegen/src/isa/aarch64/inst.isle line 1810
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(33)
		18: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Type, Inst))	extractor(has_type, 21)
		23: (Type, Inst)	match_some(22)
		24: Inst	match_tuple(23, 1)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Type	match_tuple(23, 0)
		27: Imm64	match_some(25)
		28: i64	constructor(i64_sextend_imm64, [26, 27], 0)
		29: i64	constructor(i64_neg, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		31: Option(Imm12)	extractor(imm12_from_u64, 30)
		32: Imm12	match_some(31)
		33: Option(Imm12)	some(32)
		37: ALUOp	make_variant(ALUOp::Sub, [])
		40: ValueRegs	constructor(value_reg, [48], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		22:	some
		25:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 59
		../../codegen/src/isa/aarch64/inst.isle line 1810
		../../codegen/src/isa/aarch64/inst.isle line 2455
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(33)
		18: Option(InstOutput)	some(41)
		20: Option(Inst)	extractor(def_inst, 10)
		21: Inst	match_some(20)
		22: Option((Type, Inst))	extractor(has_type, 21)
		23: (Type, Inst)	match_some(22)
		24: Inst	match_tuple(23, 1)
		25: Option(Imm64)	extractor(iconst, 24)
		26: Type	match_tuple(23, 0)
		27: Imm64	match_some(25)
		28: i64	constructor(i64_sextend_imm64, [26, 27], 0)
		29: i64	constructor(i64_neg, [28], 0)
		30: u64	constructor(i64_as_u64, [29], 0)
		31: Option(Imm12)	extractor(imm12_from_u64, 30)
		32: Imm12	match_some(31)
		33: Option(Imm12)	some(32)
		37: ALUOp	make_variant(ALUOp::Sub, [])
		40: ValueRegs	constructor(value_reg, [48], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		20:	some
		22:	some
		25:	some
		31:	some
		33:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 54
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 1)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 51
		../../codegen/src/isa/aarch64/inst.isle line 2435
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Type	match_some(6)
		13: Value	match_tuple(9, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(26)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [33], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2432
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		17: Option(InstOutput)	some(25)
		21: ALUOp	make_variant(ALUOp::Add, [])
		24: ValueRegs	constructor(value_reg, [32], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 39
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(nop, 0)
		4: Reg	constructor(invalid_reg, [], 1)
		6: Option(InstOutput)	some(9)
		8: ValueRegs	constructor(value_reg, [4], 1)
		9: InstOutput	constructor(output, [8], 2)
	]
	constraints = [
		3:	some
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 34
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee64)	extractor(f64const, 0)
		4: Ieee64	match_some(3)
		5: u64	extractor(u64_from_ieee64, 4)
		6: Reg	constructor(constant_f64, [5], 1)
		8: Option(InstOutput)	some(11)
		10: ValueRegs	constructor(value_reg, [6], 1)
		11: InstOutput	constructor(output, [10], 2)
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3249
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2271
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		8: Option(InstOutput)	some(18)
		10: Type	const_prim(I32)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	constructor(u32_as_u64, [5], 0)
		13: Reg	constructor(imm, [10, 11, 12], 1)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: ValueRegs	constructor(value_reg, [23], 1)
		18: InstOutput	constructor(output, [17], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
	]
	constraints = [
		3:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3246
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2278
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		8: Option(InstOutput)	some(17)
		10: u64	constructor(u32_as_u64, [5], 0)
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: Option(ASIMDFPModImm)	constructor(asimd_fp_mod_imm_from_u64, [10, 11], 0)
		13: ASIMDFPModImm	match_some(12)
		16: ValueRegs	constructor(value_reg, [22], 1)
		17: InstOutput	constructor(output, [16], 2)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: Reg	constructor(writable_reg_to_reg, [21], 0)
	]
	constraints = [
		3:	some
		12:	some
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/isa/aarch64/inst.isle line 3242
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		8: Option(InstOutput)	some(17)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: ASIMDMovModImm	constructor(asimd_mov_mod_imm_zero, [10], 1)
		12: bool	const_prim(false)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		16: ValueRegs	constructor(value_reg, [23], 1)
		17: InstOutput	constructor(output, [16], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: Reg	constructor(writable_reg_to_reg, [22], 0)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 24
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(())	extractor(null, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: u64	const_int(0, u64)
		10: Reg	constructor(imm, [7, 8, 9], 1)
		12: Option(InstOutput)	some(15)
		14: ValueRegs	constructor(value_reg, [10], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 19
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Imm64)	extractor(iconst, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: Imm64	match_some(6)
		10: u64	extractor(u64_from_imm64, 9)
		11: Reg	constructor(imm, [7, 8, 10], 1)
		13: Option(InstOutput)	some(16)
		15: ValueRegs	constructor(value_reg, [11], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
}

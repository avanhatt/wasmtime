inline term: lower
expansions = 481
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 97
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_high, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		12: bool	const_prim(true)
		15: Option(InstOutput)	some(28)
		16: Option(Option(InstOutput))	some(15)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecExtend, [11, 22, 8, 12, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 92
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_high, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		12: bool	const_prim(true)
		15: Option(InstOutput)	some(28)
		16: Option(Option(InstOutput))	some(15)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecExtend, [11, 22, 8, 12, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 87
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Uimm8))	extractor(extract_vector, 0)
		4: (Value, Uimm8)	match_some(3)
		5: Uimm8	match_tuple(4, 1)
		6: Value	match_tuple(4, 0)
		7: Reg	constructor(put_in_reg, [6], 1)
		8: ValueRegs	constructor(value_reg, [7], 2)
		9: InstOutput	constructor(output, [8], 3)
		10: Option(InstOutput)	some(9)
		11: Option(Option(InstOutput))	some(10)
	]
	constraints = [
		3:	some
		5:	const_int(0)
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 81
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(DynamicStackSlot)	extractor(dynamic_stack_addr, 0)
		4: Type	const_prim(I64)
		5: WritableReg	constructor(temp_writable_reg, [4], 1)
		6: DynamicStackSlot	match_some(3)
		7: MInst	constructor(abi_dynamic_stackslot_addr, [5, 6], 2)
		8: Unit	constructor(emit, [7], 3)
		9: Reg	constructor(writable_reg_to_reg, [5], 0)
		10: ValueRegs	constructor(value_reg, [9], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
		13: Option(Option(InstOutput))	some(12)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 75
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/isa/aarch64/inst.isle line 2569
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(33)
		21: Option(Option(InstOutput))	some(20)
		24: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		29: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		32: ValueRegs	constructor(value_reg, [50], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecRRNarrowLow, [24, 38, 11, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRNarrowHigh, [29, 47, 41, 16, 17])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 71
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(40)
		23: Option(Option(InstOutput))	some(22)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecMovElement, [30, 11, 13, 14, 15, 16])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		39: ValueRegs	constructor(value_reg, [48], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecRRNarrowLow, [36, 45, 33, 19])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 67
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uunarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(26)
		19: Option(Option(InstOutput))	some(18)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRNarrowLow, [22, 31, 13, 15])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 61
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/isa/aarch64/inst.isle line 2561
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(33)
		21: Option(Option(InstOutput))	some(20)
		24: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		29: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		32: ValueRegs	constructor(value_reg, [50], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecRRNarrowLow, [24, 38, 11, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRNarrowHigh, [29, 47, 41, 16, 17])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 57
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(40)
		23: Option(Option(InstOutput))	some(22)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecMovElement, [30, 11, 13, 14, 15, 16])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		39: ValueRegs	constructor(value_reg, [48], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecRRNarrowLow, [36, 45, 33, 19])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 53
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(unarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(26)
		19: Option(Option(InstOutput))	some(18)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRNarrowLow, [22, 31, 13, 15])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/isa/aarch64/inst.isle line 2553
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(33)
		21: Option(Option(InstOutput))	some(20)
		24: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		29: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		32: ValueRegs	constructor(value_reg, [50], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecRRNarrowLow, [24, 38, 11, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRNarrowHigh, [29, 47, 41, 16, 17])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 43
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(40)
		23: Option(Option(InstOutput))	some(22)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecMovElement, [30, 11, 13, 14, 15, 16])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		39: ValueRegs	constructor(value_reg, [48], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecRRNarrowLow, [36, 45, 33, 19])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 39
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Type	match_tuple(4, 0)
		11: Option(Type)	extractor(ty_dyn128_int, 10)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(11)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(26)
		19: Option(Option(InstOutput))	some(18)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRNarrowLow, [22, 31, 13, 15])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 35
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmax, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmax, [])
		17: ValueRegs	constructor(value_reg, [29], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [15, 26, 11, 13, 14])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 31
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmin, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmin, [])
		17: ValueRegs	constructor(value_reg, [29], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [15, 26, 11, 13, 14])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 27
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fdiv, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		17: ValueRegs	constructor(value_reg, [29], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [15, 26, 11, 13, 14])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 23
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fmul, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmul, [])
		17: ValueRegs	constructor(value_reg, [29], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [15, 26, 11, 13, 14])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 19
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fsub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fsub, [])
		17: ValueRegs	constructor(value_reg, [29], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [15, 26, 11, 13, 14])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 15
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Fadd, [])
		17: ValueRegs	constructor(value_reg, [29], 5)
		18: InstOutput	constructor(output, [17], 6)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [15, 26, 11, 13, 14])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 11
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option((u32, u32))	extractor(dynamic_lane, 9)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [9], 3)
		17: VecALUOp	make_variant(VecALUOp::Mul, [])
		19: ValueRegs	constructor(value_reg, [31], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecRRR, [17, 28, 13, 15, 16])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 7
		../../codegen/src/isa/aarch64/inst.isle line 2457
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [33], 5)
		17: InstOutput	constructor(output, [16], 6)
		18: Option(InstOutput)	some(17)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Sub, [])
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [23, 30, 11, 13, 14])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 3
		../../codegen/src/isa/aarch64/inst.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		16: ValueRegs	constructor(value_reg, [33], 5)
		17: InstOutput	constructor(output, [16], 6)
		18: Option(InstOutput)	some(17)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Add, [])
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [23, 30, 11, 13, 14])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2882
		../../codegen/src/isa/aarch64/inst.isle line 2216
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvpromote_low, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: VecRRLongOp	make_variant(VecRRLongOp::Fcvtl32, [])
		7: bool	const_prim(false)
		10: Option(InstOutput)	some(22)
		11: Option(Option(InstOutput))	some(10)
		15: Type	const_prim(I8X16)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: MInst	make_variant(MInst::VecRRLong, [6, 16, 5, 7])
		18: Unit	constructor(emit, [17], 2)
		19: Reg	constructor(writable_reg_to_reg, [16], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2877
		../../codegen/src/isa/aarch64/inst.isle line 3815
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		15: Option(InstOutput)	some(25)
		16: Option(Option(InstOutput))	some(15)
		18: Type	const_prim(I64)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::MachOTlsGetAddr, [12, 19])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::Macho)
		8:	some
		10:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2874
		../../codegen/src/isa/aarch64/inst.isle line 3808
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: TlsModel	extractor(tls_model, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(GlobalValue)	extractor(tls_value, 7)
		9: GlobalValue	match_some(8)
		10: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(10)
		12: ExternalName	match_tuple(11, 0)
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		18: Type	const_prim(I64)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: WritableReg	constructor(temp_writable_reg, [18], 2)
		21: BoxExternalName	constructor(box_external_name, [12], 3)
		22: MInst	make_variant(MInst::ElfTlsGetAddr, [21, 19, 20])
		23: Unit	constructor(emit, [22], 4)
		24: Reg	constructor(writable_reg_to_reg, [19], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	variant(TlsModel::ElfGd)
		8:	some
		10:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2861
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2517
		../../codegen/src/isa/aarch64/inst.isle line 2020
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I64)
		16: Reg	constructor(put_in_reg, [9], 5)
		17: Reg	constructor(put_in_reg, [11], 6)
		19: OperandSize	make_variant(OperandSize::Size64, [])
		20: u64	const_int(63, u64)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [73], 11)
		26: ValueRegs	constructor(value_reg, [62], 12)
		27: InstOutput	constructor(output_pair, [25, 26], 13)
		28: Option(InstOutput)	some(27)
		29: Option(Option(InstOutput))	some(28)
		34: ALUOp3	make_variant(ALUOp3::MAdd, [])
		39: ALUOp	make_variant(ALUOp::SMulH, [])
		45: Type	const_prim(I64)
		46: Option(ShiftOpAndAmt)	constructor(ashr_from_u64, [45, 20], 0)
		47: WritableReg	constructor(writable_zero_reg, [], 1)
		48: ALUOp	make_variant(ALUOp::SubS, [])
		49: ShiftOpAndAmt	match_some(46)
		50: MInst	make_variant(MInst::AluRRRShift, [48, 19, 47, 83, 73, 49])
		51: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [50])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: MInst	make_variant(MInst::CSet, [54, 22])
		56: Reg	constructor(writable_reg_to_reg, [54], 0)
		57: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 56])
		60: ValueRegs	constructor(with_flags, [51, 57], 1)
		61: usize	const_int(0, usize)
		62: Reg	constructor(value_regs_get, [60, 61], 2)
		68: Type	const_prim(I64)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: OperandSize	constructor(operand_size, [14], 2)
		71: MInst	make_variant(MInst::AluRRRR, [34, 70, 69, 10, 12, 13])
		72: Unit	constructor(emit, [71], 3)
		73: Reg	constructor(writable_reg_to_reg, [69], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: OperandSize	constructor(operand_size, [14], 2)
		81: MInst	make_variant(MInst::AluRRR, [39, 80, 79, 16, 17])
		82: Unit	constructor(emit, [81], 3)
		83: Reg	constructor(writable_reg_to_reg, [79], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		46:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2847
		../../codegen/src/isa/aarch64/inst.isle line 2493
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: ExtendOp	make_variant(ExtendOp::SXTW, [])
		18: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(value_reg, [61], 8)
		22: ValueRegs	constructor(value_reg, [50], 9)
		23: InstOutput	constructor(output_pair, [21, 22], 10)
		24: Option(InstOutput)	some(23)
		25: Option(Option(InstOutput))	some(24)
		29: ALUOp3	make_variant(ALUOp3::SMAddL, [])
		30: Type	const_prim(I32)
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRRExtend, [37, 15, 36, 61, 61, 16])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::CSet, [42, 18])
		44: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 44])
		48: ValueRegs	constructor(with_flags, [39, 45], 1)
		49: usize	const_int(0, usize)
		50: Reg	constructor(value_regs_get, [48, 49], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [30], 2)
		59: MInst	make_variant(MInst::AluRRRR, [29, 58, 57, 10, 12, 13])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2831
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg_sext32, [13], 2)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg_sext32, [15], 3)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [64], 9)
		25: ValueRegs	constructor(value_reg, [53], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		28: Option(Option(InstOutput))	some(27)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: ALUOp	make_variant(ALUOp::SubS, [])
		41: MInst	make_variant(MInst::AluRRRExtend, [40, 19, 39, 64, 64, 11])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 21])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [46, 47])
		51: ValueRegs	constructor(with_flags, [42, 48], 1)
		52: usize	const_int(0, usize)
		53: Reg	constructor(value_regs_get, [51, 52], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: OperandSize	constructor(operand_size, [9], 2)
		62: MInst	make_variant(MInst::AluRRRR, [33, 61, 60, 14, 16, 17])
		63: Unit	constructor(emit, [62], 3)
		64: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2813
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2513
		../../codegen/src/isa/aarch64/inst.isle line 2123
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2117
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I64)
		16: Reg	constructor(put_in_reg, [9], 5)
		17: Reg	constructor(put_in_reg, [11], 6)
		19: u8	const_int(0, u8)
		20: Imm12	constructor(u8_into_imm12, [19], 8)
		22: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(value_reg, [66], 12)
		26: ValueRegs	constructor(value_reg, [55], 13)
		27: InstOutput	constructor(output_pair, [25, 26], 14)
		28: Option(InstOutput)	some(27)
		29: Option(Option(InstOutput))	some(28)
		34: ALUOp3	make_variant(ALUOp3::MAdd, [])
		39: ALUOp	make_variant(ALUOp::UMulH, [])
		43: OperandSize	make_variant(OperandSize::Size64, [])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSet, [47, 22])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [48, 49])
		53: ValueRegs	constructor(with_flags, [83, 50], 1)
		54: usize	const_int(0, usize)
		55: Reg	constructor(value_regs_get, [53, 54], 2)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: OperandSize	constructor(operand_size, [14], 2)
		64: MInst	make_variant(MInst::AluRRRR, [34, 63, 62, 10, 12, 13])
		65: Unit	constructor(emit, [64], 3)
		66: Reg	constructor(writable_reg_to_reg, [62], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: OperandSize	constructor(operand_size, [14], 2)
		74: MInst	make_variant(MInst::AluRRR, [39, 73, 72, 16, 17])
		75: Unit	constructor(emit, [74], 3)
		76: Reg	constructor(writable_reg_to_reg, [72], 0)
		80: WritableReg	constructor(writable_zero_reg, [], 1)
		81: ALUOp	make_variant(ALUOp::SubS, [])
		82: MInst	make_variant(MInst::AluRRImm12, [81, 43, 80, 76, 20])
		83: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [82])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2799
		../../codegen/src/isa/aarch64/inst.isle line 2489
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umul_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: ExtendOp	make_variant(ExtendOp::UXTW, [])
		18: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(value_reg, [61], 8)
		22: ValueRegs	constructor(value_reg, [50], 9)
		23: InstOutput	constructor(output_pair, [21, 22], 10)
		24: Option(InstOutput)	some(23)
		25: Option(Option(InstOutput))	some(24)
		29: ALUOp3	make_variant(ALUOp3::UMAddL, [])
		30: Type	const_prim(I32)
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRRExtend, [37, 15, 36, 61, 61, 16])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: MInst	make_variant(MInst::CSet, [42, 18])
		44: Reg	constructor(writable_reg_to_reg, [42], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 44])
		48: ValueRegs	constructor(with_flags, [39, 45], 1)
		49: usize	const_int(0, usize)
		50: Reg	constructor(value_regs_get, [48, 49], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [30], 2)
		59: MInst	make_variant(MInst::AluRRRR, [29, 58, 57, 10, 12, 13])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2783
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umul_overflow, 7)
		9: Type	match_some(6)
		10: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		11: ExtendOp	constructor(lower_extend_op, [9, 10], 1)
		12: (Value, Value)	match_some(8)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg_zext32, [13], 2)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg_zext32, [15], 3)
		17: Reg	constructor(zero_reg, [], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		21: Cond	make_variant(Cond::Ne, [])
		24: ValueRegs	constructor(value_reg, [64], 9)
		25: ValueRegs	constructor(value_reg, [53], 10)
		26: InstOutput	constructor(output_pair, [24, 25], 11)
		27: Option(InstOutput)	some(26)
		28: Option(Option(InstOutput))	some(27)
		33: ALUOp3	make_variant(ALUOp3::MAdd, [])
		39: WritableReg	constructor(writable_zero_reg, [], 1)
		40: ALUOp	make_variant(ALUOp::SubS, [])
		41: MInst	make_variant(MInst::AluRRRExtend, [40, 19, 39, 64, 64, 11])
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [41])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::CSet, [45, 21])
		47: Reg	constructor(writable_reg_to_reg, [45], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [46, 47])
		51: ValueRegs	constructor(with_flags, [42, 48], 1)
		52: usize	const_int(0, usize)
		53: Reg	constructor(value_regs_get, [51, 52], 2)
		59: Type	const_prim(I64)
		60: WritableReg	constructor(temp_writable_reg, [59], 1)
		61: OperandSize	constructor(operand_size, [9], 2)
		62: MInst	make_variant(MInst::AluRRRR, [33, 61, 60, 14, 16, 17])
		63: Unit	constructor(emit, [62], 3)
		64: Reg	constructor(writable_reg_to_reg, [60], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2773
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ssub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(68)
		16: Option(Option(InstOutput))	some(15)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [22, 25], 3)
		27: ValueRegs	constructor(put_in_regs, [10], 4)
		28: Reg	constructor(value_regs_get, [27, 23], 5)
		29: Reg	constructor(value_regs_get, [27, 25], 6)
		30: Type	const_prim(I64)
		34: MultiReg	constructor(with_flags_chained, [45, 55, 61], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [30], 2)
		43: MInst	make_variant(MInst::AluRRR, [11, 42, 41, 24, 28])
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
		45: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [43, 44])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [30], 2)
		53: MInst	make_variant(MInst::AluRRR, [12, 52, 51, 26, 29])
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		55: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [53, 54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 13])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [59, 60])
		63: Reg	match_variant(34, MultiReg::Three, a)
		64: Reg	match_variant(34, MultiReg::Three, b)
		65: ValueRegs	constructor(value_regs, [63, 64], 1)
		66: Reg	match_variant(34, MultiReg::Three, c)
		67: ValueRegs	constructor(value_reg, [66], 2)
		68: InstOutput	constructor(output_pair, [65, 67], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		34:	variant(MultiReg::Three)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2767
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: Reg	constructor(put_in_reg, [11], 1)
		24: Reg	constructor(put_in_reg, [12], 2)
		27: ValueRegs	constructor(with_flags, [44, 50], 5)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [27, 28], 6)
		30: ValueRegs	constructor(value_reg, [29], 7)
		31: usize	const_int(1, usize)
		32: Reg	constructor(value_regs_get, [27, 31], 8)
		33: ValueRegs	constructor(value_reg, [32], 9)
		34: InstOutput	constructor(output_pair, [30, 33], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [9], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 23, 24])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSet, [47, 14])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2762
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg_ext32, [11, 13], 2)
		25: Reg	constructor(put_in_reg, [12], 3)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [45], 8)
		33: ValueRegs	constructor(value_reg, [64], 9)
		34: InstOutput	constructor(output_pair, [32, 33], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [9], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [14, 42, 41, 24, 25, 23])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 27, 50, 45, 45, 23])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 29])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2753
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(usub_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::SubS, [])
		12: ALUOp	make_variant(ALUOp::SbcS, [])
		13: Cond	make_variant(Cond::Lo, [])
		15: Option(InstOutput)	some(68)
		16: Option(Option(InstOutput))	some(15)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [22, 25], 3)
		27: ValueRegs	constructor(put_in_regs, [10], 4)
		28: Reg	constructor(value_regs_get, [27, 23], 5)
		29: Reg	constructor(value_regs_get, [27, 25], 6)
		30: Type	const_prim(I64)
		34: MultiReg	constructor(with_flags_chained, [45, 55, 61], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [30], 2)
		43: MInst	make_variant(MInst::AluRRR, [11, 42, 41, 24, 28])
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
		45: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [43, 44])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [30], 2)
		53: MInst	make_variant(MInst::AluRRR, [12, 52, 51, 26, 29])
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		55: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [53, 54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 13])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [59, 60])
		63: Reg	match_variant(34, MultiReg::Three, a)
		64: Reg	match_variant(34, MultiReg::Three, b)
		65: ValueRegs	constructor(value_regs, [63, 64], 1)
		66: Reg	match_variant(34, MultiReg::Three, c)
		67: ValueRegs	constructor(value_reg, [66], 2)
		68: InstOutput	constructor(output_pair, [65, 67], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		34:	variant(MultiReg::Three)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2747
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::SubS, [])
		14: Cond	make_variant(Cond::Lo, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: Reg	constructor(put_in_reg, [11], 1)
		24: Reg	constructor(put_in_reg, [12], 2)
		27: ValueRegs	constructor(with_flags, [44, 50], 5)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [27, 28], 6)
		30: ValueRegs	constructor(value_reg, [29], 7)
		31: usize	const_int(1, usize)
		32: Reg	constructor(value_regs_get, [27, 31], 8)
		33: ValueRegs	constructor(value_reg, [32], 9)
		34: InstOutput	constructor(output_pair, [30, 33], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [9], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 23, 24])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSet, [47, 14])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2742
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Sub, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg_ext32, [11, 13], 2)
		25: Reg	constructor(put_in_reg, [12], 3)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [45], 8)
		33: ValueRegs	constructor(value_reg, [64], 9)
		34: InstOutput	constructor(output_pair, [32, 33], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [9], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [14, 42, 41, 24, 25, 23])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 27, 50, 45, 45, 23])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 29])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2733
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Vs, [])
		15: Option(InstOutput)	some(68)
		16: Option(Option(InstOutput))	some(15)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [22, 25], 3)
		27: ValueRegs	constructor(put_in_regs, [10], 4)
		28: Reg	constructor(value_regs_get, [27, 23], 5)
		29: Reg	constructor(value_regs_get, [27, 25], 6)
		30: Type	const_prim(I64)
		34: MultiReg	constructor(with_flags_chained, [45, 55, 61], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [30], 2)
		43: MInst	make_variant(MInst::AluRRR, [11, 42, 41, 24, 28])
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
		45: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [43, 44])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [30], 2)
		53: MInst	make_variant(MInst::AluRRR, [12, 52, 51, 26, 29])
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		55: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [53, 54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 13])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [59, 60])
		63: Reg	match_variant(34, MultiReg::Three, a)
		64: Reg	match_variant(34, MultiReg::Three, b)
		65: ValueRegs	constructor(value_regs, [63, 64], 1)
		66: Reg	match_variant(34, MultiReg::Three, c)
		67: ValueRegs	constructor(value_reg, [66], 2)
		68: InstOutput	constructor(output_pair, [65, 67], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		34:	variant(MultiReg::Three)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2727
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_32_or_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Vs, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: Reg	constructor(put_in_reg, [11], 1)
		24: Reg	constructor(put_in_reg, [12], 2)
		27: ValueRegs	constructor(with_flags, [44, 50], 5)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [27, 28], 6)
		30: ValueRegs	constructor(value_reg, [29], 7)
		31: usize	const_int(1, usize)
		32: Reg	constructor(value_regs_get, [27, 31], 8)
		33: ValueRegs	constructor(value_reg, [32], 9)
		34: InstOutput	constructor(output_pair, [30, 33], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [9], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 23, 24])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSet, [47, 14])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2722
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg_ext32, [11, 13], 2)
		25: Reg	constructor(put_in_reg, [12], 3)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [45], 8)
		33: ValueRegs	constructor(value_reg, [64], 9)
		34: InstOutput	constructor(output_pair, [32, 33], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [9], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [14, 42, 41, 24, 25, 23])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 27, 50, 45, 45, 23])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 29])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2713
		../../codegen/src/isa/aarch64/lower.isle line 2680
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2058
		../../codegen/src/isa/aarch64/inst.isle line 2384
		../../codegen/src/prelude_lower.isle line 168
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(uadd_overflow, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Value	match_tuple(8, 1)
		11: ALUOp	make_variant(ALUOp::AddS, [])
		12: ALUOp	make_variant(ALUOp::AdcS, [])
		13: Cond	make_variant(Cond::Hs, [])
		15: Option(InstOutput)	some(68)
		16: Option(Option(InstOutput))	some(15)
		22: ValueRegs	constructor(put_in_regs, [9], 1)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 2)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [22, 25], 3)
		27: ValueRegs	constructor(put_in_regs, [10], 4)
		28: Reg	constructor(value_regs_get, [27, 23], 5)
		29: Reg	constructor(value_regs_get, [27, 25], 6)
		30: Type	const_prim(I64)
		34: MultiReg	constructor(with_flags_chained, [45, 55, 61], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [30], 2)
		43: MInst	make_variant(MInst::AluRRR, [11, 42, 41, 24, 28])
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
		45: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [43, 44])
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [30], 2)
		53: MInst	make_variant(MInst::AluRRR, [12, 52, 51, 26, 29])
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		55: ConsumesAndProducesFlags	make_variant(ConsumesAndProducesFlags::ReturnsReg, [53, 54])
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: MInst	make_variant(MInst::CSet, [58, 13])
		60: Reg	constructor(writable_reg_to_reg, [58], 0)
		61: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [59, 60])
		63: Reg	match_variant(34, MultiReg::Three, a)
		64: Reg	match_variant(34, MultiReg::Three, b)
		65: ValueRegs	constructor(value_regs, [63, 64], 1)
		66: Reg	match_variant(34, MultiReg::Three, c)
		67: ValueRegs	constructor(value_reg, [66], 2)
		68: InstOutput	constructor(output_pair, [65, 67], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		34:	variant(MultiReg::Three)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2709
		../../codegen/src/isa/aarch64/lower.isle line 2669
		../../codegen/src/isa/aarch64/inst.isle line 2050
		../../codegen/src/isa/aarch64/inst.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(uadd_overflow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: (Value, Value)	match_some(6)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ALUOp	make_variant(ALUOp::AddS, [])
		14: Cond	make_variant(Cond::Hs, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: Reg	constructor(put_in_reg, [11], 1)
		24: Reg	constructor(put_in_reg, [12], 2)
		27: ValueRegs	constructor(with_flags, [44, 50], 5)
		28: usize	const_int(0, usize)
		29: Reg	constructor(value_regs_get, [27, 28], 6)
		30: ValueRegs	constructor(value_reg, [29], 7)
		31: usize	const_int(1, usize)
		32: Reg	constructor(value_regs_get, [27, 31], 8)
		33: ValueRegs	constructor(value_reg, [32], 9)
		34: InstOutput	constructor(output_pair, [30, 33], 10)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [9], 2)
		42: MInst	make_variant(MInst::AluRRR, [13, 41, 40, 23, 24])
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		44: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [42, 43])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::CSet, [47, 14])
		49: Reg	constructor(writable_reg_to_reg, [47], 0)
		50: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [48, 49])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
		../../codegen/src/isa/aarch64/lower.isle line 2640
		../../codegen/src/isa/aarch64/inst.isle line 2028
		../../codegen/src/isa/aarch64/inst.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 2377
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_overflow, 7)
		9: Type	match_some(6)
		10: (Value, Value)	match_some(8)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		13: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		14: ALUOp	make_variant(ALUOp::Add, [])
		16: Option(InstOutput)	some(34)
		17: Option(Option(InstOutput))	some(16)
		23: ExtendOp	constructor(lower_extend_op, [9, 13], 1)
		24: Reg	constructor(put_in_reg_ext32, [11, 13], 2)
		25: Reg	constructor(put_in_reg, [12], 3)
		27: OperandSize	make_variant(OperandSize::Size32, [])
		29: Cond	make_variant(Cond::Ne, [])
		32: ValueRegs	constructor(value_reg, [45], 8)
		33: ValueRegs	constructor(value_reg, [64], 9)
		34: InstOutput	constructor(output_pair, [32, 33], 10)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [9], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [14, 42, 41, 24, 25, 23])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: WritableReg	constructor(writable_zero_reg, [], 1)
		51: ALUOp	make_variant(ALUOp::SubS, [])
		52: MInst	make_variant(MInst::AluRRRExtend, [51, 27, 50, 45, 45, 23])
		53: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [52])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: MInst	make_variant(MInst::CSet, [56, 29])
		58: Reg	constructor(writable_reg_to_reg, [56], 0)
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [57, 58])
		62: ValueRegs	constructor(with_flags, [53, 59], 1)
		63: usize	const_int(0, usize)
		64: Reg	constructor(value_regs_get, [62, 63], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2625
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 3026
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/prelude_lower.isle line 568
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, TrapCode))	extractor(uadd_overflow_trap, 7)
		9: (Value, Value, TrapCode)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		16: TrapCode	match_tuple(9, 2)
		19: Option(InstOutput)	some(40)
		20: Option(Option(InstOutput))	some(19)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [14], 2)
		27: ALUOp	make_variant(ALUOp::AddS, [])
		28: MInst	make_variant(MInst::AluRRR, [27, 26, 25, 11, 13])
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [28, 29])
		33: Cond	make_variant(Cond::Hs, [])
		34: CondBrKind	constructor(cond_br_cond, [33], 1)
		35: MInst	make_variant(MInst::TrapIf, [34, 16])
		36: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsSideEffect, [35])
		39: ValueRegs	constructor(value_reg, [45], 1)
		40: InstOutput	constructor(output, [39], 2)
		43: ValueRegs	constructor(with_flags, [30, 36], 1)
		44: usize	const_int(0, usize)
		45: Reg	constructor(value_regs_get, [43, 44], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2611
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2437
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(1, u8)
		8: ScalarSize	make_variant(ScalarSize::Size64, [])
		10: Reg	constructor(put_in_reg, [4], 3)
		11: u8	const_int(0, u8)
		13: u8	const_int(63, u8)
		14: ImmShift	constructor(imm_shift_from_u8, [13], 5)
		15: Type	const_prim(I64)
		17: ImmShift	constructor(imm_shift_from_u8, [13], 7)
		19: u64	const_int(1, u64)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_u64, [15, 19], 0)
		21: ShiftOpAndAmt	match_some(20)
		24: Option(InstOutput)	some(60)
		25: Option(Option(InstOutput))	some(24)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::MovFromVec, [30, 6, 7, 8])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::MovFromVec, [38, 10, 11, 8])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		45: ALUOp	make_variant(ALUOp::Lsr, [])
		50: ALUOp	make_variant(ALUOp::Lsr, [])
		56: ALUOp	make_variant(ALUOp::Add, [])
		59: ValueRegs	constructor(value_reg, [91], 1)
		60: InstOutput	constructor(output, [59], 2)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [15], 2)
		68: MInst	make_variant(MInst::AluRRImmShift, [45, 67, 66, 33, 14])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: OperandSize	constructor(operand_size, [15], 2)
		78: MInst	make_variant(MInst::AluRRImmShift, [50, 77, 76, 41, 17])
		79: Unit	constructor(emit, [78], 3)
		80: Reg	constructor(writable_reg_to_reg, [76], 0)
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: OperandSize	constructor(operand_size, [15], 2)
		89: MInst	make_variant(MInst::AluRRRShift, [56, 88, 87, 80, 70, 21])
		90: Unit	constructor(emit, [89], 3)
		91: Reg	constructor(writable_reg_to_reg, [87], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2598
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(31, u8)
		8: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u128	const_int(633825300187901677051779743745, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size32, [])
		18: Option(InstOutput)	some(44)
		19: Option(Option(InstOutput))	some(18)
		23: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		28: VecALUOp	make_variant(VecALUOp::And, [])
		32: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::MovFromVec, [38, 70, 14, 15])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I8X16)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::VecShiftImm, [23, 50, 6, 8, 7])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: MInst	make_variant(MInst::VecRRR, [28, 59, 53, 11, 8])
		61: Unit	constructor(emit, [60], 2)
		62: Reg	constructor(writable_reg_to_reg, [59], 0)
		66: Type	const_prim(I8X16)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::VecLanes, [32, 67, 62, 8])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2585
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(15, u8)
		8: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u128	const_int(664619068533544770747334646890102785, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size16, [])
		18: Option(InstOutput)	some(44)
		19: Option(Option(InstOutput))	some(18)
		23: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		28: VecALUOp	make_variant(VecALUOp::And, [])
		32: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::MovFromVec, [38, 70, 14, 15])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		43: ValueRegs	constructor(value_reg, [41], 1)
		44: InstOutput	constructor(output, [43], 2)
		49: Type	const_prim(I8X16)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::VecShiftImm, [23, 50, 6, 8, 7])
		52: Unit	constructor(emit, [51], 2)
		53: Reg	constructor(writable_reg_to_reg, [50], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: MInst	make_variant(MInst::VecRRR, [28, 59, 53, 11, 8])
		61: Unit	constructor(emit, [60], 2)
		62: Reg	constructor(writable_reg_to_reg, [59], 0)
		66: Type	const_prim(I8X16)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::VecLanes, [32, 67, 62, 8])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2561
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/isa/aarch64/inst.isle line 2592
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vhigh_bits, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: u8	const_int(7, u8)
		8: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u128	const_int(-169808226154284360427508033573982305791, u128)
		11: Reg	constructor(constant_f128, [10], 3)
		13: u8	const_int(8, u8)
		16: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: u8	const_int(0, u8)
		19: ScalarSize	make_variant(ScalarSize::Size16, [])
		22: Option(InstOutput)	some(61)
		23: Option(Option(InstOutput))	some(22)
		27: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		32: VecALUOp	make_variant(VecALUOp::And, [])
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecExtract, [38, 79, 79, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		45: VecALUOp	make_variant(VecALUOp::Zip1, [])
		49: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::MovFromVec, [55, 96, 18, 19])
		57: Unit	constructor(emit, [56], 2)
		58: Reg	constructor(writable_reg_to_reg, [55], 0)
		60: ValueRegs	constructor(value_reg, [58], 1)
		61: InstOutput	constructor(output, [60], 2)
		66: Type	const_prim(I8X16)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: MInst	make_variant(MInst::VecShiftImm, [27, 67, 6, 8, 7])
		69: Unit	constructor(emit, [68], 2)
		70: Reg	constructor(writable_reg_to_reg, [67], 0)
		75: Type	const_prim(I8X16)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: MInst	make_variant(MInst::VecRRR, [32, 76, 70, 11, 8])
		78: Unit	constructor(emit, [77], 2)
		79: Reg	constructor(writable_reg_to_reg, [76], 0)
		84: Type	const_prim(I8X16)
		85: WritableReg	constructor(temp_writable_reg, [84], 1)
		86: MInst	make_variant(MInst::VecRRR, [45, 85, 79, 41, 8])
		87: Unit	constructor(emit, [86], 2)
		88: Reg	constructor(writable_reg_to_reg, [85], 0)
		92: Type	const_prim(I8X16)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::VecLanes, [49, 93, 88, 16])
		95: Unit	constructor(emit, [94], 2)
		96: Reg	constructor(writable_reg_to_reg, [93], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2547
		../../codegen/src/isa/aarch64/inst.isle line 3702
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((StackSlot, Offset32))	extractor(stack_addr, 0)
		4: (StackSlot, Offset32)	match_some(3)
		5: StackSlot	match_tuple(4, 0)
		6: Offset32	match_tuple(4, 1)
		9: Option(InstOutput)	some(20)
		10: Option(Option(InstOutput))	some(9)
		13: Type	const_prim(I64)
		14: WritableReg	constructor(temp_writable_reg, [13], 1)
		15: MInst	constructor(abi_stackslot_addr, [14, 5, 6], 2)
		16: Unit	constructor(emit, [15], 3)
		17: Reg	constructor(writable_reg_to_reg, [14], 0)
		19: ValueRegs	constructor(value_reg, [17], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2540
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Type	extractor(value_type, 8)
		12: VectorSize	constructor(vector_size, [11], 3)
		13: Uimm8	match_tuple(4, 2)
		14: u8	extractor(u8_from_uimm8, 13)
		15: u8	const_int(0, u8)
		18: Option(InstOutput)	some(32)
		19: Option(Option(InstOutput))	some(18)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMovElement, [26, 9, 10, 14, 15, 12])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2535
		../../codegen/src/isa/aarch64/inst.isle line 2278
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Uimm8))	extractor(insertlane, 0)
		4: (Value, Value, Uimm8)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_int, 6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(put_in_reg, [5], 2)
		11: Type	extractor(value_type, 8)
		12: VectorSize	constructor(vector_size, [11], 3)
		13: Uimm8	match_tuple(4, 2)
		14: u8	extractor(u8_from_uimm8, 13)
		17: Option(InstOutput)	some(30)
		18: Option(Option(InstOutput))	some(17)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::MovToVec, [24, 9, 10, 14, 12])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2528
		../../codegen/src/isa/aarch64/inst.isle line 2305
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	extractor(value_type, 10)
		13: VectorSize	constructor(vector_size, [12], 2)
		14: Uimm8	match_tuple(9, 1)
		15: u8	extractor(u8_from_uimm8, 14)
		18: Option(InstOutput)	some(30)
		19: Option(Option(InstOutput))	some(18)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::FpuMoveFromVec, [24, 11, 15, 13])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2523
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		14: Uimm8	match_tuple(9, 1)
		15: u8	extractor(u8_from_uimm8, 14)
		18: Option(InstOutput)	some(30)
		19: Option(Option(InstOutput))	some(18)
		23: Type	const_prim(I64)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::MovFromVec, [24, 11, 15, 13])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2520
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Uimm8))	extractor(extractlane, 7)
		9: (Value, Uimm8)	match_some(8)
		10: Uimm8	match_tuple(9, 1)
		11: u8	extractor(u8_from_uimm8, 10)
		12: Value	match_tuple(9, 0)
		14: Option(InstOutput)	some(18)
		15: Option(Option(InstOutput))	some(14)
		17: ValueRegs	constructor(put_in_regs, [12], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	const_int(0)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2514
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value))	extractor(bitcast, 6)
		8: (MemFlags, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Type	extractor(value_type, 9)
		12: Option(InstOutput)	some(16)
		13: Option(Option(InstOutput))	some(12)
		15: ValueRegs	constructor(put_in_regs, [9], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	const_prim(I128)
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2510
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		14: Option(InstOutput)	some(18)
		15: Option(Option(InstOutput))	some(14)
		17: ValueRegs	constructor(put_in_regs, [10], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2502
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		13: bool	constructor(is_ref_type, [11], 0)
		14: bool	constructor(is_ref_type, [5], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		16: Reg	constructor(copy_reg, [11, 15], 2)
		18: Option(InstOutput)	some(22)
		19: Option(Option(InstOutput))	some(18)
		21: ValueRegs	constructor(value_reg, [16], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
		13:	const_prim(false)
		14:	const_prim(true)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2496
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		13: bool	constructor(is_ref_type, [11], 0)
		14: bool	constructor(is_ref_type, [5], 0)
		15: Reg	constructor(put_in_reg, [10], 1)
		16: Reg	constructor(copy_reg, [5, 15], 2)
		18: Option(InstOutput)	some(22)
		19: Option(Option(InstOutput))	some(18)
		21: ValueRegs	constructor(value_reg, [16], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
		13:	const_prim(true)
		14:	const_prim(false)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2489
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(fits_in_64, 11)
		13: Type	match_some(12)
		14: Option(Type)	extractor(ty_float_or_vec, 13)
		15: Reg	constructor(put_in_reg, [10], 1)
		16: ScalarSize	constructor(scalar_size, [5], 2)
		17: u8	const_int(0, u8)
		20: Option(InstOutput)	some(32)
		21: Option(Option(InstOutput))	some(20)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::MovFromVec, [26, 15, 17, 16])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
		14:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2484
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	constructor(ty_int_ref_scalar_64, [11], 0)
		13: Reg	constructor(put_in_reg, [10], 1)
		14: ScalarSize	constructor(scalar_size, [11], 2)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::MovToFpu, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_float_or_vec, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(bitcast, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_float_or_vec, 11)
		14: Option(InstOutput)	some(18)
		15: Option(Option(InstOutput))	some(14)
		17: ValueRegs	constructor(put_in_regs, [10], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		12:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
		../../codegen/src/isa/aarch64/inst.isle line 3696
		../../codegen/src/prelude_lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 3486
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(set_pinned_reg, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		8: Option(InstOutput)	some(15)
		9: Option(Option(InstOutput))	some(8)
		11: PReg	constructor(preg_pinned, [], 1)
		14: Unit	constructor(emit_side_effect, [19], 1)
		15: InstOutput	constructor(output_none, [], 2)
		18: MInst	make_variant(MInst::MovToPReg, [11, 5])
		19: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [18])
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2471
		../../codegen/src/isa/aarch64/inst.isle line 3480
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_pinned_reg, 0)
		4: PReg	constructor(preg_pinned, [], 1)
		7: Option(InstOutput)	some(17)
		8: Option(Option(InstOutput))	some(7)
		10: Type	const_prim(I64)
		11: WritableReg	constructor(temp_writable_reg, [10], 1)
		12: MInst	make_variant(MInst::MovFromPReg, [11, 4])
		13: Unit	constructor(emit, [12], 2)
		14: Reg	constructor(writable_reg_to_reg, [11], 0)
		16: ValueRegs	constructor(value_reg, [14], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2464
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: MInst	make_variant(MInst::FpuStore128, [13, 12, 14])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: Unit	constructor(emit_side_effect, [23], 1)
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_dyn_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: MInst	make_variant(MInst::FpuStore64, [13, 12, 14])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: Unit	constructor(emit_side_effect, [23], 1)
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2456
		../../codegen/src/isa/aarch64/inst.isle line 2892
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Type	const_prim(I8X16)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: MInst	make_variant(MInst::FpuStore128, [13, 12, 14])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: Unit	constructor(emit_side_effect, [23], 1)
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec64, 6)
		8: Type	const_prim(F64)
		9: Value	match_tuple(4, 2)
		10: Offset32	match_tuple(4, 3)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: Reg	constructor(put_in_reg, [5], 2)
		14: MemFlags	match_tuple(4, 0)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: MInst	make_variant(MInst::FpuStore64, [13, 12, 14])
		23: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [22])
		25: Unit	constructor(emit_side_effect, [23], 1)
		26: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2895
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Value	match_tuple(4, 2)
		8: Offset32	match_tuple(4, 3)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: PairAMode	constructor(pair_amode, [7, 9], 1)
		11: ValueRegs	constructor(put_in_regs, [5], 2)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 3)
		14: ValueRegs	constructor(put_in_regs, [5], 4)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		17: MemFlags	match_tuple(4, 0)
		20: Option(InstOutput)	some(30)
		21: Option(Option(InstOutput))	some(20)
		26: MInst	make_variant(MInst::StoreP64, [13, 16, 10, 17])
		27: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [26])
		29: Unit	constructor(emit_side_effect, [27], 1)
		30: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I128)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 2889
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::FpuStore64, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2436
		../../codegen/src/isa/aarch64/inst.isle line 2886
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(F32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::FpuStore32, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2431
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: MInst	make_variant(MInst::Store32, [11, 9, 12])
		21: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [20])
		23: Unit	constructor(emit_side_effect, [21], 1)
		24: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2427
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: MInst	make_variant(MInst::Store16, [11, 9, 12])
		21: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [20])
		23: Unit	constructor(emit_side_effect, [21], 1)
		24: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(istore8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 2)
		7: Offset32	match_tuple(5, 3)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: Value	match_tuple(5, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: MemFlags	match_tuple(5, 0)
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: MInst	make_variant(MInst::Store8, [11, 9, 12])
		21: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [20])
		23: Unit	constructor(emit_side_effect, [21], 1)
		24: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::Store64, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(R64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
		../../codegen/src/isa/aarch64/inst.isle line 2883
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::Store64, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2410
		../../codegen/src/isa/aarch64/inst.isle line 2880
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I32)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::Store32, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2406
		../../codegen/src/isa/aarch64/inst.isle line 2877
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I16)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::Store16, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I16)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2402
		../../codegen/src/isa/aarch64/inst.isle line 2874
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value, Offset32))	extractor(store, 0)
		4: (MemFlags, Value, Value, Offset32)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I8)
		8: Value	match_tuple(4, 2)
		9: Offset32	match_tuple(4, 3)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [7, 8, 10], 1)
		12: Reg	constructor(put_in_reg, [5], 2)
		13: MemFlags	match_tuple(4, 0)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: MInst	make_variant(MInst::Store8, [12, 11, 13])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	const_prim(I8)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2393
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(37)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecExtend, [12, 31, 25, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2387
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32x2, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Option(InstOutput)	some(37)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecExtend, [12, 31, 25, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2381
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(37)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecExtend, [12, 31, 25, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2375
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16x4, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Option(InstOutput)	some(37)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecExtend, [12, 31, 25, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(37)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecExtend, [12, 31, 25, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2363
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8x8, 0)
		4: Type	const_prim(F64)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		12: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Option(InstOutput)	some(37)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 9, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecExtend, [12, 31, 25, 13, 14])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
		../../codegen/src/isa/aarch64/inst.isle line 2840
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::SLoad32, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2356
		../../codegen/src/isa/aarch64/inst.isle line 2835
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload32, 0)
		4: Type	const_prim(I32)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::ULoad32, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
		../../codegen/src/isa/aarch64/inst.isle line 2830
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::SLoad16, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2350
		../../codegen/src/isa/aarch64/inst.isle line 2825
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload16, 0)
		4: Type	const_prim(I16)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::ULoad16, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
		../../codegen/src/isa/aarch64/inst.isle line 2820
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(sload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::SLoad8, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2344
		../../codegen/src/isa/aarch64/inst.isle line 2815
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Offset32))	extractor(uload8, 0)
		4: Type	const_prim(I8)
		5: (MemFlags, Value, Offset32)	match_some(3)
		6: Value	match_tuple(5, 1)
		7: Offset32	match_tuple(5, 2)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [4, 6, 8], 1)
		10: MemFlags	match_tuple(5, 0)
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(I64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::ULoad8, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2339
		../../codegen/src/isa/aarch64/inst.isle line 2860
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [9, 11, 13], 1)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(29)
		19: Option(Option(InstOutput))	some(18)
		22: Type	const_prim(F64X2)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::FpuLoad128, [23, 14, 15])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2335
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [9, 11, 13], 1)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(29)
		19: Option(Option(InstOutput))	some(18)
		22: Type	const_prim(F64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::FpuLoad64, [23, 14, 15])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
		../../codegen/src/isa/aarch64/inst.isle line 2860
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Offset32))	extractor(load, 7)
		9: Type	const_prim(I8X16)
		10: (MemFlags, Value, Offset32)	match_some(8)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [9, 11, 13], 1)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(29)
		19: Option(Option(InstOutput))	some(18)
		22: Type	const_prim(F64X2)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::FpuLoad128, [23, 14, 15])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2327
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((MemFlags, Value, Offset32))	extractor(load, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: (MemFlags, Value, Offset32)	match_some(6)
		11: Value	match_tuple(10, 1)
		12: Offset32	match_tuple(10, 2)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [9, 11, 13], 1)
		15: MemFlags	match_tuple(10, 0)
		18: Option(InstOutput)	some(29)
		19: Option(Option(InstOutput))	some(18)
		22: Type	const_prim(F64)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::FpuLoad64, [23, 14, 15])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		28: ValueRegs	constructor(value_reg, [26], 1)
		29: InstOutput	constructor(output, [28], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2324
		../../codegen/src/isa/aarch64/inst.isle line 2865
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: (MemFlags, Value, Offset32)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Offset32	match_tuple(8, 2)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: PairAMode	constructor(pair_amode, [9, 11], 1)
		13: MemFlags	match_tuple(8, 0)
		15: InstOutput	constructor(output, [27], 3)
		16: Option(InstOutput)	some(15)
		17: Option(Option(InstOutput))	some(16)
		20: Type	const_prim(I64)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: WritableReg	constructor(temp_writable_reg, [20], 2)
		23: MInst	make_variant(MInst::LoadP64, [21, 22, 12, 13])
		24: Unit	constructor(emit, [23], 3)
		25: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_regs, [25, 26], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2321
		../../codegen/src/isa/aarch64/inst.isle line 2855
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad64, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2318
		../../codegen/src/isa/aarch64/inst.isle line 2850
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(F32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuLoad32, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2315
		../../codegen/src/isa/aarch64/inst.isle line 2845
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::ULoad64, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2312
		../../codegen/src/isa/aarch64/inst.isle line 2845
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I64)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::ULoad64, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
		../../codegen/src/isa/aarch64/inst.isle line 2835
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I32)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::ULoad32, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2306
		../../codegen/src/isa/aarch64/inst.isle line 2825
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I16)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::ULoad16, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2303
		../../codegen/src/isa/aarch64/inst.isle line 2815
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((MemFlags, Value, Offset32))	extractor(load, 6)
		8: Type	const_prim(I8)
		9: (MemFlags, Value, Offset32)	match_some(7)
		10: Value	match_tuple(9, 1)
		11: Offset32	match_tuple(9, 2)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [8, 10, 12], 1)
		14: MemFlags	match_tuple(9, 0)
		17: Option(InstOutput)	some(28)
		18: Option(Option(InstOutput))	some(17)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::ULoad8, [22, 13, 14])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2298
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(return_call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_return_call_indirect, [5, 6, 7], 1)
		9: Option(InstOutput)	some(8)
		10: Option(Option(InstOutput))	some(9)
	]
	constraints = [
		3:	some
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2295
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(return_call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_return_call, [7, 8, 9, 10], 1)
		12: Option(InstOutput)	some(11)
		13: Option(Option(InstOutput))	some(12)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
		../../codegen/src/prelude_lower.isle line 1044
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(ValueSlice)	extractor(return, 0)
		4: ValueSlice	match_some(3)
		6: Option(InstOutput)	some(10)
		7: Option(Option(InstOutput))	some(6)
		9: Unit	constructor(gen_return, [4], 1)
		10: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((SigRef, Value, ValueSlice))	extractor(call_indirect, 0)
		4: (SigRef, Value, ValueSlice)	match_some(3)
		5: SigRef	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: ValueSlice	match_tuple(4, 2)
		8: InstOutput	constructor(gen_call_indirect, [5, 6, 7], 1)
		9: Option(InstOutput)	some(8)
		10: Option(Option(InstOutput))	some(9)
	]
	constraints = [
		3:	some
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((FuncRef, ValueSlice))	extractor(call, 0)
		4: (FuncRef, ValueSlice)	match_some(3)
		5: FuncRef	match_tuple(4, 0)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueSlice	match_tuple(4, 1)
		11: InstOutput	constructor(gen_call, [7, 8, 9, 10], 1)
		12: Option(InstOutput)	some(11)
		13: Option(Option(InstOutput))	some(12)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2276
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_return_address, 0)
		4: Reg	constructor(aarch64_link, [], 1)
		6: Option(InstOutput)	some(10)
		7: Option(Option(InstOutput))	some(6)
		9: ValueRegs	constructor(value_reg, [4], 1)
		10: InstOutput	constructor(output, [9], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2273
		../../codegen/src/isa/aarch64/inst.isle line 3502
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3480
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_stack_pointer, 0)
		6: Option(InstOutput)	some(12)
		7: Option(Option(InstOutput))	some(6)
		8: PReg	constructor(preg_sp, [], 1)
		11: ValueRegs	constructor(value_reg, [18], 1)
		12: InstOutput	constructor(output, [11], 2)
		14: Type	const_prim(I64)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: MInst	make_variant(MInst::MovFromPReg, [15, 8])
		17: Unit	constructor(emit, [16], 2)
		18: Reg	constructor(writable_reg_to_reg, [15], 0)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2270
		../../codegen/src/isa/aarch64/inst.isle line 3506
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3480
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(get_frame_pointer, 0)
		6: Option(InstOutput)	some(12)
		7: Option(Option(InstOutput))	some(6)
		8: PReg	constructor(preg_fp, [], 1)
		11: ValueRegs	constructor(value_reg, [18], 1)
		12: InstOutput	constructor(output, [11], 2)
		14: Type	const_prim(I64)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: MInst	make_variant(MInst::MovFromPReg, [15, 8])
		17: Unit	constructor(emit, [16], 2)
		18: Reg	constructor(writable_reg_to_reg, [15], 0)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2265
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(GlobalValue)	extractor(symbol_value, 0)
		4: GlobalValue	match_some(3)
		5: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 4)
		6: (ExternalName, RelocDistance, i64)	match_some(5)
		7: ExternalName	match_tuple(6, 0)
		8: BoxExternalName	constructor(box_external_name, [7], 1)
		9: i64	match_tuple(6, 2)
		12: Option(InstOutput)	some(23)
		13: Option(Option(InstOutput))	some(12)
		16: Type	const_prim(I64)
		17: WritableReg	constructor(temp_writable_reg, [16], 1)
		18: MInst	make_variant(MInst::LoadExtName, [17, 8, 9])
		19: Unit	constructor(emit, [18], 2)
		20: Reg	constructor(writable_reg_to_reg, [17], 0)
		22: ValueRegs	constructor(value_reg, [20], 1)
		23: InstOutput	constructor(output, [22], 2)
	]
	constraints = [
		3:	some
		5:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2260
		../../codegen/src/isa/aarch64/inst.isle line 3101
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(FuncRef)	extractor(func_addr, 0)
		4: FuncRef	match_some(3)
		5: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 4)
		6: ExternalName	match_tuple(5, 1)
		7: BoxExternalName	constructor(box_external_name, [6], 1)
		8: i64	const_int(0, i64)
		11: Option(InstOutput)	some(22)
		12: Option(Option(InstOutput))	some(11)
		15: Type	const_prim(I64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: MInst	make_variant(MInst::LoadExtName, [16, 7, 8])
		18: Unit	constructor(emit, [17], 2)
		19: Reg	constructor(writable_reg_to_reg, [16], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2255
		../../codegen/src/isa/aarch64/inst.isle line 2583
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(debugtrap, 0)
		6: Option(InstOutput)	some(12)
		7: Option(Option(InstOutput))	some(6)
		8: MInst	make_variant(MInst::Brk, [])
		9: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [8])
		11: Unit	constructor(emit_side_effect, [9], 1)
		12: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2249
		../../codegen/src/isa/aarch64/inst.isle line 2105
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_invalid, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: OperandSize	constructor(operand_size, [5], 1)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(1, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [23, 29], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
		20: WritableReg	constructor(writable_zero_reg, [], 1)
		21: ALUOp	make_variant(ALUOp::AddS, [])
		22: MInst	make_variant(MInst::AluRRImm12, [21, 6, 20, 7, 9])
		23: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [22])
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::CSet, [26, 11])
		28: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [27, 28])
	]
	constraints = [
		3:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2243
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(is_null, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: OperandSize	constructor(operand_size, [5], 1)
		7: Reg	constructor(put_in_reg, [4], 2)
		8: u8	const_int(0, u8)
		9: Imm12	constructor(u8_into_imm12, [8], 3)
		11: Cond	make_variant(Cond::Eq, [])
		13: ValueRegs	constructor(with_flags, [23, 29], 6)
		14: InstOutput	constructor(output, [13], 7)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
		20: WritableReg	constructor(writable_zero_reg, [], 1)
		21: ALUOp	make_variant(ALUOp::SubS, [])
		22: MInst	make_variant(MInst::AluRRImm12, [21, 6, 20, 7, 9])
		23: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [22])
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::CSet, [26, 11])
		28: Reg	constructor(writable_reg_to_reg, [26], 0)
		29: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [27, 28])
	]
	constraints = [
		3:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2238
		../../codegen/src/isa/aarch64/inst.isle line 2573
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(fence, 0)
		6: Option(InstOutput)	some(12)
		7: Option(Option(InstOutput))	some(6)
		8: MInst	make_variant(MInst::Fence, [])
		9: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [8])
		11: Unit	constructor(emit_side_effect, [9], 1)
		12: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2231
		../../codegen/src/isa/aarch64/inst.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: u8	const_int(1, u8)
		12: VectorSize	make_variant(VectorSize::Size32x2, [])
		14: ScalarSize	constructor(lane_size, [5], 3)
		15: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		16: bool	const_prim(false)
		19: Option(InstOutput)	some(40)
		20: Option(Option(InstOutput))	some(19)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuMoveFromVec, [25, 10, 11, 12])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [15, 34, 28, 16, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2228
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uwiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		14: bool	const_prim(true)
		17: Option(InstOutput)	some(30)
		18: Option(Option(InstOutput))	some(17)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecExtend, [13, 24, 10, 14, 12])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2223
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(uwiden_low, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		12: bool	const_prim(false)
		15: Option(InstOutput)	some(28)
		16: Option(Option(InstOutput))	some(15)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecExtend, [11, 22, 8, 12, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2216
		../../codegen/src/isa/aarch64/inst.isle line 2305
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_vec64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: u8	const_int(1, u8)
		12: VectorSize	make_variant(VectorSize::Size32x2, [])
		14: ScalarSize	constructor(lane_size, [5], 3)
		15: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		16: bool	const_prim(false)
		19: Option(InstOutput)	some(40)
		20: Option(Option(InstOutput))	some(19)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::FpuMoveFromVec, [25, 10, 11, 12])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecExtend, [15, 34, 28, 16, 14])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
		39: ValueRegs	constructor(value_reg, [37], 1)
		40: InstOutput	constructor(output, [39], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2213
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(swiden_high, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		14: bool	const_prim(true)
		17: Option(InstOutput)	some(30)
		18: Option(Option(InstOutput))	some(17)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::VecExtend, [13, 24, 10, 14, 12])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		29: ValueRegs	constructor(value_reg, [27], 1)
		30: InstOutput	constructor(output, [29], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2208
		../../codegen/src/isa/aarch64/inst.isle line 2326
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(swiden_low, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		10: ScalarSize	constructor(lane_size, [9], 2)
		11: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		12: bool	const_prim(false)
		15: Option(InstOutput)	some(28)
		16: Option(Option(InstOutput))	some(15)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecExtend, [11, 22, 8, 12, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/isa/aarch64/inst.isle line 2569
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(33)
		21: Option(Option(InstOutput))	some(20)
		24: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		29: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		32: ValueRegs	constructor(value_reg, [50], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecRRNarrowLow, [24, 38, 11, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRNarrowHigh, [29, 47, 41, 16, 17])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2197
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(40)
		23: Option(Option(InstOutput))	some(22)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecMovElement, [30, 11, 13, 14, 15, 16])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		39: ValueRegs	constructor(value_reg, [48], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecRRNarrowLow, [36, 45, 33, 19])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2193
		../../codegen/src/isa/aarch64/inst.isle line 2565
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uunarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(26)
		19: Option(Option(InstOutput))	some(18)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Uqxtn, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRNarrowLow, [22, 31, 13, 15])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2185
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/isa/aarch64/inst.isle line 2561
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(33)
		21: Option(Option(InstOutput))	some(20)
		24: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		29: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		32: ValueRegs	constructor(value_reg, [50], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecRRNarrowLow, [24, 38, 11, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRNarrowHigh, [29, 47, 41, 16, 17])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2181
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec64_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(6)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(40)
		23: Option(Option(InstOutput))	some(22)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecMovElement, [30, 11, 13, 14, 15, 16])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		39: ValueRegs	constructor(value_reg, [48], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecRRNarrowLow, [36, 45, 33, 19])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2177
		../../codegen/src/isa/aarch64/inst.isle line 2557
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(unarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(26)
		19: Option(Option(InstOutput))	some(18)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtun, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRNarrowLow, [22, 31, 13, 15])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2170
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/isa/aarch64/inst.isle line 2553
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: ScalarSize	constructor(lane_size, [12], 2)
		15: Value	match_tuple(9, 1)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: ScalarSize	constructor(lane_size, [12], 5)
		20: Option(InstOutput)	some(33)
		21: Option(Option(InstOutput))	some(20)
		24: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		29: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		32: ValueRegs	constructor(value_reg, [50], 1)
		33: InstOutput	constructor(output, [32], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecRRNarrowLow, [24, 38, 11, 13])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
		46: Type	const_prim(I8X16)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: MInst	make_variant(MInst::VecRRNarrowHigh, [29, 47, 41, 16, 17])
		49: Unit	constructor(emit, [48], 2)
		50: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2166
		../../codegen/src/isa/aarch64/inst.isle line 2285
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(snarrow, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: u8	const_int(1, u8)
		15: u8	const_int(0, u8)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Type	match_some(8)
		19: ScalarSize	constructor(lane_size, [18], 4)
		22: Option(InstOutput)	some(40)
		23: Option(Option(InstOutput))	some(22)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecMovElement, [30, 11, 13, 14, 15, 16])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
		36: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		39: ValueRegs	constructor(value_reg, [48], 1)
		40: InstOutput	constructor(output, [39], 2)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::VecRRNarrowLow, [36, 45, 33, 19])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2162
		../../codegen/src/isa/aarch64/inst.isle line 2549
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128_int, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(snarrow, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ScalarSize	constructor(lane_size, [14], 2)
		18: Option(InstOutput)	some(26)
		19: Option(Option(InstOutput))	some(18)
		22: VecRRNarrowOp	make_variant(VecRRNarrowOp::Sqxtn, [])
		25: ValueRegs	constructor(value_reg, [34], 1)
		26: InstOutput	constructor(output, [25], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRNarrowLow, [22, 31, 13, 15])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2157
		../../codegen/src/isa/aarch64/inst.isle line 2545
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(fvdemote, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: ScalarSize	make_variant(ScalarSize::Size32, [])
		9: Option(InstOutput)	some(17)
		10: Option(Option(InstOutput))	some(9)
		13: VecRRNarrowOp	make_variant(VecRRNarrowOp::Fcvtn, [])
		16: ValueRegs	constructor(value_reg, [25], 1)
		17: InstOutput	constructor(output, [16], 2)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecRRNarrowLow, [13, 22, 5, 6])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
	]
	constraints = [
		3:	some
	]
	result = 10
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2152
		../../codegen/src/isa/aarch64/inst.isle line 3451
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 7)
		9: (MemFlags, Value, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(9, 3)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(35)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: MInst	make_variant(MInst::AtomicCASLoop, [16, 17, 11, 13, 15, 28, 29])
		31: Unit	constructor(emit, [30], 3)
		32: Reg	constructor(writable_reg_to_reg, [28], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2147
		../../codegen/src/isa/aarch64/inst.isle line 3423
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, Value, Value, Value))	extractor(atomic_cas, 8)
		10: (MemFlags, Value, Value, Value)	match_some(9)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 2)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 3)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Type	match_some(6)
		18: MemFlags	match_tuple(10, 0)
		21: Option(InstOutput)	some(34)
		22: Option(Option(InstOutput))	some(21)
		28: WritableReg	constructor(temp_writable_reg, [17], 1)
		29: MInst	make_variant(MInst::AtomicCAS, [28, 14, 16, 12, 17, 18])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Xchg, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xchg)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2139
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umax, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umax)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2136
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umin, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Umin)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2133
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smax, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smax)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2130
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smin, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Smin)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2127
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Eor, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Xor)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2124
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Orr, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Or)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2121
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Nand, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Nand)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2118
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::And, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::And)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2115
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Sub, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Sub)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2112
		../../codegen/src/isa/aarch64/inst.isle line 3437
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 7)
		9: (MemFlags, AtomicRmwOp, Value, Value)	match_some(8)
		10: AtomicRmwOp	match_tuple(9, 1)
		11: Value	match_tuple(9, 2)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(9, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Add, [])
		16: Type	match_some(6)
		17: MemFlags	match_tuple(9, 0)
		20: Option(InstOutput)	some(36)
		21: Option(Option(InstOutput))	some(20)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: WritableReg	constructor(temp_writable_reg, [27], 2)
		30: WritableReg	constructor(temp_writable_reg, [27], 3)
		31: MInst	make_variant(MInst::AtomicRMWLoop, [16, 15, 17, 12, 14, 28, 29, 30])
		32: Unit	constructor(emit, [31], 4)
		33: Reg	constructor(writable_reg_to_reg, [28], 0)
		35: ValueRegs	constructor(value_reg, [33], 1)
		36: InstOutput	constructor(output, [35], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	variant(AtomicRmwOp::Add)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2106
		../../codegen/src/isa/aarch64/inst.isle line 2793
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Reg	constructor(zero_reg, [], 2)
		15: Type	match_some(6)
		17: AtomicRMWOp	make_variant(AtomicRMWOp::Clr, [])
		18: Value	match_tuple(10, 2)
		19: MemFlags	match_tuple(10, 0)
		22: Option(InstOutput)	some(41)
		23: Option(Option(InstOutput))	some(22)
		27: ALUOp	make_variant(ALUOp::EorNot, [])
		34: Reg	constructor(put_in_reg, [18], 1)
		35: WritableReg	constructor(temp_writable_reg, [15], 2)
		36: MInst	make_variant(MInst::AtomicRMW, [17, 51, 35, 34, 15, 19])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [15], 2)
		49: MInst	make_variant(MInst::AluRRR, [27, 48, 47, 13, 14])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::And)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2102
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Reg	constructor(zero_reg, [], 1)
		13: Value	match_tuple(10, 3)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(6)
		17: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		18: Value	match_tuple(10, 2)
		19: MemFlags	match_tuple(10, 0)
		22: Option(InstOutput)	some(41)
		23: Option(Option(InstOutput))	some(22)
		27: ALUOp	make_variant(ALUOp::Sub, [])
		34: Reg	constructor(put_in_reg, [18], 1)
		35: WritableReg	constructor(temp_writable_reg, [15], 2)
		36: MInst	make_variant(MInst::AtomicRMW, [17, 51, 35, 34, 15, 19])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [15], 2)
		49: MInst	make_variant(MInst::AluRRR, [27, 48, 47, 12, 14])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Sub)
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2098
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Umin, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umin)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2094
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Umax, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Umax)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2090
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Smin, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smin)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2086
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Smax, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Smax)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2082
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Set, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Or)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2078
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Eor, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Xor)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2074
		../../codegen/src/isa/aarch64/inst.isle line 3413
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Option(())	extractor(use_lse, 0)
		8: Inst	match_tuple(4, 1)
		9: Option((MemFlags, AtomicRmwOp, Value, Value))	extractor(atomic_rmw, 8)
		10: (MemFlags, AtomicRmwOp, Value, Value)	match_some(9)
		11: AtomicRmwOp	match_tuple(10, 1)
		12: Value	match_tuple(10, 3)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		15: Value	match_tuple(10, 2)
		16: Type	match_some(6)
		17: MemFlags	match_tuple(10, 0)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		27: Reg	constructor(put_in_reg, [15], 1)
		28: WritableReg	constructor(temp_writable_reg, [16], 2)
		29: MInst	make_variant(MInst::AtomicRMW, [14, 13, 28, 27, 16, 17])
		30: Unit	constructor(emit, [29], 3)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
		11:	variant(AtomicRmwOp::Add)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2067
		../../codegen/src/isa/aarch64/inst.isle line 2347
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((MemFlags, Value, Value))	extractor(atomic_store, 0)
		4: (MemFlags, Value, Value)	match_some(3)
		5: Value	match_tuple(4, 1)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Reg	constructor(put_in_reg, [5], 1)
		9: Value	match_tuple(4, 2)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: Type	match_some(7)
		12: MemFlags	match_tuple(4, 0)
		15: Option(InstOutput)	some(25)
		16: Option(Option(InstOutput))	some(15)
		21: MInst	make_variant(MInst::StoreRelease, [11, 8, 10, 12])
		22: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [21])
		24: Unit	constructor(emit_side_effect, [22], 1)
		25: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2062
		../../codegen/src/isa/aarch64/inst.isle line 2340
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(valid_atomic_transaction, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((MemFlags, Value))	extractor(atomic_load, 7)
		9: (MemFlags, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(6)
		13: MemFlags	match_tuple(9, 0)
		16: Option(InstOutput)	some(28)
		17: Option(Option(InstOutput))	some(16)
		21: Type	const_prim(I64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::LoadAcquire, [12, 22, 11, 13])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3094
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option((MemFlags, Value, Offset32))	extractor(load, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [7], 0)
		12: Type	match_tuple(4, 0)
		13: Type	constructor(lane_type, [12], 0)
		14: Inst	match_some(11)
		16: VectorSize	constructor(vector_size, [12], 2)
		17: (MemFlags, Value, Offset32)	match_some(10)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(45)
		22: Option(Option(InstOutput))	some(21)
		25: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		26: Unit	constructor(sink_inst, [14], 1)
		27: (MemFlags, Value, Offset32)	match_some(25)
		28: Value	match_tuple(27, 1)
		29: Reg	constructor(put_in_reg, [28], 2)
		30: Offset32	match_tuple(27, 2)
		31: i32	extractor(offset32, 30)
		32: i64	constructor(i32_as_i64, [31], 0)
		33: u64	constructor(i64_as_u64, [32], 0)
		34: Reg	constructor(add_imm_to_addr, [29, 33], 3)
		38: Type	const_prim(I8X16)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::VecLoadReplicate, [39, 34, 16, 18])
		41: Unit	constructor(emit, [40], 2)
		42: Reg	constructor(writable_reg_to_reg, [39], 0)
		44: ValueRegs	constructor(value_reg, [42], 1)
		45: InstOutput	constructor(output, [44], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		25:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2053
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Value)	extractor(ireduce, 9)
		11: Value	match_some(10)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: Option(Imm64)	extractor(iconst, 13)
		15: Type	match_tuple(4, 0)
		16: VectorSize	constructor(vector_size, [15], 1)
		17: Imm64	match_some(14)
		18: u64	extractor(u64_from_imm64, 17)
		19: Reg	constructor(splat_const, [18, 16], 2)
		21: Option(InstOutput)	some(25)
		22: Option(Option(InstOutput))	some(21)
		24: ValueRegs	constructor(value_reg, [19], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		14:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2050
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Imm64)	extractor(iconst, 9)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 1)
		13: Imm64	match_some(10)
		14: u64	extractor(u64_from_imm64, 13)
		15: Reg	constructor(splat_const, [14, 12], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2047
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee64)	extractor(f64const, 9)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 1)
		13: Ieee64	match_some(10)
		14: u64	extractor(u64_from_ieee64, 13)
		15: Reg	constructor(splat_const, [14, 12], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2044
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Option(Inst)	extractor(def_inst, 7)
		9: Inst	match_some(8)
		10: Option(Ieee32)	extractor(f32const, 9)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 1)
		13: Ieee32	match_some(10)
		14: u32	extractor(u32_from_ieee32, 13)
		15: u64	constructor(u32_as_u64, [14], 0)
		16: Reg	constructor(splat_const, [15, 12], 2)
		18: Option(InstOutput)	some(22)
		19: Option(Option(InstOutput))	some(18)
		21: ValueRegs	constructor(value_reg, [16], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2041
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_scalar_float, 8)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: u8	const_int(0, u8)
		16: Option(InstOutput)	some(28)
		17: Option(Option(InstOutput))	some(16)
		21: Type	const_prim(I8X16)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::VecDupFromFpu, [22, 10, 12, 13])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2037
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(splat, 5)
		7: Value	match_some(6)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	constructor(ty_int_ref_scalar_64, [8], 0)
		10: Reg	constructor(put_in_reg, [7], 1)
		11: Type	match_tuple(4, 0)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(26)
		16: Option(Option(InstOutput))	some(15)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecDup, [20, 10, 12])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2031
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Constant)	extractor(vconst, 5)
		7: Constant	match_some(6)
		8: Option(u64)	extractor(u64_from_constant, 7)
		9: Type	match_tuple(4, 0)
		10: Option(Type)	constructor(ty_vec64, [9], 0)
		11: u64	match_some(8)
		12: Reg	constructor(constant_f64, [11], 1)
		14: Option(InstOutput)	some(18)
		15: Option(Option(InstOutput))	some(14)
		17: ValueRegs	constructor(value_reg, [12], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2028
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Constant)	extractor(vconst, 7)
		9: Constant	match_some(8)
		10: Option(u128)	extractor(u128_from_constant, 9)
		11: u128	match_some(10)
		12: Reg	constructor(constant_f128, [11], 1)
		14: Option(InstOutput)	some(18)
		15: Option(Option(InstOutput))	some(14)
		17: ValueRegs	constructor(value_reg, [12], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2017
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Type	const_prim(I64)
		17: Reg	constructor(zero_reg, [], 5)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [39, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		26: Option(InstOutput)	some(25)
		27: Option(Option(InstOutput))	some(26)
		31: ALUOp	make_variant(ALUOp::Orr, [])
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRR, [37, 18, 36, 49, 17])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [15], 2)
		47: MInst	make_variant(MInst::AluRRR, [31, 46, 45, 12, 14])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2011
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: Reg	constructor(put_in_reg_zext64, [8], 1)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size64, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [29, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: WritableReg	constructor(writable_zero_reg, [], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: MInst	make_variant(MInst::AluRRR, [27, 13, 26, 11, 12])
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [28])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1997
		../../codegen/src/isa/aarch64/inst.isle line 3835
		../../codegen/src/isa/aarch64/inst.isle line 3839
		../../codegen/src/isa/aarch64/inst.isle line 2578
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select_spectre_guard, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [35], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [33, 22, 23, 24, 25], 5)
		29: InstOutput	constructor(output, [26], 8)
		30: Option(InstOutput)	some(29)
		31: Option(Option(InstOutput))	some(30)
		33: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		35: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
		36: MInst	make_variant(MInst::Csdb, [])
		37: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [36])
		39: Unit	constructor(emit_side_effect, [37], 1)
		40: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 31
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1986
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2111
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Type	const_prim(I64)
		17: Reg	constructor(zero_reg, [], 5)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		20: Cond	make_variant(Cond::Ne, [])
		21: Type	match_tuple(4, 0)
		22: Value	match_tuple(7, 1)
		23: Value	match_tuple(7, 2)
		24: ValueRegs	constructor(lower_select, [39, 20, 21, 22, 23], 7)
		25: InstOutput	constructor(output, [24], 8)
		26: Option(InstOutput)	some(25)
		27: Option(Option(InstOutput))	some(26)
		31: ALUOp	make_variant(ALUOp::Orr, [])
		36: WritableReg	constructor(writable_zero_reg, [], 1)
		37: ALUOp	make_variant(ALUOp::SubS, [])
		38: MInst	make_variant(MInst::AluRRR, [37, 18, 36, 49, 17])
		39: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [38])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [15], 2)
		47: MInst	make_variant(MInst::AluRRR, [31, 46, 45, 12, 14])
		48: Unit	constructor(emit, [47], 3)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I128)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1980
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: Reg	constructor(put_in_reg_zext64, [8], 1)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size64, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [29, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: WritableReg	constructor(writable_zero_reg, [], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: MInst	make_variant(MInst::AluRRR, [27, 13, 26, 11, 12])
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [28])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1974
		../../codegen/src/isa/aarch64/inst.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: Reg	constructor(put_in_reg_zext32, [8], 1)
		12: Reg	constructor(zero_reg, [], 2)
		13: OperandSize	make_variant(OperandSize::Size32, [])
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [29, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: WritableReg	constructor(writable_zero_reg, [], 1)
		27: ALUOp	make_variant(ALUOp::SubS, [])
		28: MInst	make_variant(MInst::AluRRR, [27, 13, 26, 11, 12])
		29: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [28])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 2355
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: Type	const_prim(I32)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [11, 12], 2)
		15: Cond	make_variant(Cond::Ne, [])
		16: Type	match_tuple(4, 0)
		17: Value	match_tuple(7, 1)
		18: Value	match_tuple(7, 2)
		19: ValueRegs	constructor(lower_select, [30, 15, 16, 17, 18], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: OperandSize	constructor(operand_size, [11], 1)
		27: WritableReg	constructor(writable_zero_reg, [], 2)
		28: ALUOp	make_variant(ALUOp::AndS, [])
		29: MInst	make_variant(MInst::AluRRImmLogic, [28, 26, 27, 10, 13])
		30: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [29])
	]
	constraints = [
		3:	some
		6:	some
		9:	const_prim(I8)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1959
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((FloatCC, Value, Value))	extractor(fcmp, 12)
		14: (FloatCC, Value, Value)	match_some(13)
		15: FloatCC	match_tuple(14, 0)
		16: Cond	constructor(fp_cond_code, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Type	extractor(value_type, 17)
		19: ScalarSize	constructor(scalar_size, [18], 2)
		20: Reg	constructor(put_in_reg, [17], 3)
		21: Value	match_tuple(14, 2)
		22: Reg	constructor(put_in_reg, [21], 4)
		24: Type	match_tuple(4, 0)
		25: Value	match_tuple(7, 1)
		26: Value	match_tuple(7, 2)
		27: ValueRegs	constructor(lower_select, [35, 16, 24, 25, 26], 6)
		28: InstOutput	constructor(output, [27], 7)
		29: Option(InstOutput)	some(28)
		30: Option(Option(InstOutput))	some(29)
		34: MInst	make_variant(MInst::FpuCmp, [19, 20, 22])
		35: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [34])
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
	]
	result = 30
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
		../../codegen/src/isa/aarch64/inst.isle line 3835
		../../codegen/src/isa/aarch64/inst.isle line 3839
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(select, 5)
		7: (Value, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((IntCC, Value, Value))	extractor(icmp, 12)
		14: (IntCC, Value, Value)	match_some(13)
		15: IntCC	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: Value	match_tuple(14, 2)
		18: Type	extractor(value_type, 16)
		19: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 16, 17, 18], 1)
		22: Cond	constructor(cond_code, [33], 4)
		23: Type	match_tuple(4, 0)
		24: Value	match_tuple(7, 1)
		25: Value	match_tuple(7, 2)
		26: ValueRegs	constructor(lower_select, [31, 22, 23, 24, 25], 5)
		27: InstOutput	constructor(output, [26], 6)
		28: Option(InstOutput)	some(27)
		29: Option(Option(InstOutput))	some(28)
		31: ProducesFlags	match_variant(19, FlagsAndCC::FlagsAndCC, flags)
		33: IntCC	match_variant(19, FlagsAndCC::FlagsAndCC, cc)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
		11:	some
		13:	some
		19:	variant(FlagsAndCC::FlagsAndCC)
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1941
		../../codegen/src/isa/aarch64/inst.isle line 2809
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(resumable_trap, 0)
		4: TrapCode	match_some(3)
		7: Option(InstOutput)	some(14)
		8: Option(Option(InstOutput))	some(7)
		10: MInst	make_variant(MInst::Udf, [4])
		11: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [10])
		13: Unit	constructor(emit_side_effect, [11], 1)
		14: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1936
		../../codegen/src/isa/aarch64/inst.isle line 2809
		../../codegen/src/prelude_lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(TrapCode)	extractor(trap, 0)
		4: TrapCode	match_some(3)
		7: Option(InstOutput)	some(14)
		8: Option(Option(InstOutput))	some(7)
		10: MInst	make_variant(MInst::Udf, [4])
		11: SideEffectNoResult	make_variant(SideEffectNoResult::Inst, [10])
		13: Unit	constructor(emit_side_effect, [11], 1)
		14: InstOutput	constructor(output_none, [], 2)
	]
	constraints = [
		3:	some
	]
	result = 8
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1931
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((IntCC, Value, Value))	extractor(icmp, 0)
		4: (IntCC, Value, Value)	match_some(3)
		5: IntCC	match_tuple(4, 0)
		6: Value	match_tuple(4, 1)
		7: Value	match_tuple(4, 2)
		8: Type	extractor(value_type, 6)
		9: Type	const_prim(I8)
		10: ValueRegs	constructor(lower_icmp_into_reg, [5, 6, 7, 8, 9], 1)
		11: InstOutput	constructor(output, [10], 2)
		12: Option(InstOutput)	some(11)
		13: Option(Option(InstOutput))	some(12)
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1925
		../../codegen/src/isa/aarch64/inst.isle line 3403
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: IntCC	match_some(11)
		19: ValueRegs	constructor(value_reg, [35], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op_swap, [17], 1)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecMisc, [26, 32, 15, 16])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1919
		../../codegen/src/isa/aarch64/inst.isle line 3408
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [46], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		25: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		29: VecMisc2	make_variant(VecMisc2::Not, [])
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::VecMisc, [25, 35, 15, 16])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::VecMisc, [29, 43, 38, 16])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1913
		../../codegen/src/isa/aarch64/inst.isle line 3398
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: IntCC	match_tuple(9, 0)
		13: Option(IntCC)	extractor(icmp_zero_cond, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: IntCC	match_some(13)
		19: ValueRegs	constructor(value_reg, [35], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: VecMisc2	constructor(int_cc_cmp_zero_to_vec_misc_op, [17], 1)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecMisc, [26, 32, 15, 16])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1907
		../../codegen/src/isa/aarch64/inst.isle line 3408
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((IntCC, Value, Value))	extractor(icmp, 7)
		9: (IntCC, Value, Value)	match_some(8)
		10: IntCC	match_tuple(9, 0)
		11: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [46], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		25: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		29: VecMisc2	make_variant(VecMisc2::Not, [])
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::VecMisc, [25, 35, 15, 16])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::VecMisc, [29, 43, 38, 16])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1901
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	constructor(ty_vector_float, [9], 0)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Value	match_tuple(7, 2)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: FloatCC	match_tuple(7, 0)
		15: Cond	constructor(fp_cond_code, [14], 3)
		16: Reg	constructor(vec_cmp, [11, 13, 9, 15], 4)
		18: Option(InstOutput)	some(22)
		19: Option(Option(InstOutput))	some(18)
		21: ValueRegs	constructor(value_reg, [16], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1896
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((FloatCC, Value, Value))	extractor(fcmp, 5)
		7: (FloatCC, Value, Value)	match_some(6)
		8: Value	match_tuple(7, 1)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(ty_scalar_float, 9)
		11: Type	match_some(10)
		12: ScalarSize	constructor(scalar_size, [11], 1)
		13: Reg	constructor(put_in_reg, [8], 2)
		14: Value	match_tuple(7, 2)
		15: Reg	constructor(put_in_reg, [14], 3)
		17: FloatCC	match_tuple(7, 0)
		18: Cond	constructor(fp_cond_code, [17], 5)
		20: ValueRegs	constructor(with_flags, [28, 34], 7)
		21: InstOutput	constructor(output, [20], 8)
		22: Option(InstOutput)	some(21)
		23: Option(Option(InstOutput))	some(22)
		27: MInst	make_variant(MInst::FpuCmp, [12, 13, 15])
		28: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [27])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::CSet, [31, 18])
		33: Reg	constructor(writable_reg_to_reg, [31], 0)
		34: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [32, 33])
	]
	constraints = [
		3:	some
		6:	some
		10:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1890
		../../codegen/src/isa/aarch64/inst.isle line 3373
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: FloatCC	match_some(11)
		19: ValueRegs	constructor(value_reg, [35], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op_swap, [17], 1)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecMisc, [26, 32, 15, 16])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1884
		../../codegen/src/isa/aarch64/inst.isle line 3378
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 1)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [46], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		25: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		29: VecMisc2	make_variant(VecMisc2::Not, [])
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::VecMisc, [25, 35, 15, 16])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::VecMisc, [29, 43, 38, 16])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 3368
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 2)
		11: Option(Value)	constructor(zero_value, [10], 0)
		12: FloatCC	match_tuple(9, 0)
		13: Option(FloatCC)	extractor(fcmp_zero_cond, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		17: FloatCC	match_some(13)
		19: ValueRegs	constructor(value_reg, [35], 4)
		20: InstOutput	constructor(output, [19], 5)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: VecMisc2	constructor(float_cc_cmp_zero_to_vec_misc_op, [17], 1)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecMisc, [26, 32, 15, 16])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1872
		../../codegen/src/isa/aarch64/inst.isle line 3378
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((FloatCC, Value, Value))	extractor(fcmp, 7)
		9: (FloatCC, Value, Value)	match_some(8)
		10: FloatCC	match_tuple(9, 0)
		11: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 10)
		12: Value	match_tuple(9, 2)
		13: Option(Value)	constructor(zero_value, [12], 0)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: VectorSize	constructor(vector_size, [5], 2)
		19: ValueRegs	constructor(value_reg, [46], 5)
		20: InstOutput	constructor(output, [19], 6)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		25: VecMisc2	make_variant(VecMisc2::Fcmeq0, [])
		29: VecMisc2	make_variant(VecMisc2::Not, [])
		34: Type	const_prim(I8X16)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::VecMisc, [25, 35, 15, 16])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		42: Type	const_prim(I8X16)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MInst	make_variant(MInst::VecMisc, [29, 43, 38, 16])
		45: Unit	constructor(emit, [44], 2)
		46: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1866
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	constructor(ty_int_ref_scalar_64, [5], 0)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ireduce, 7)
		9: Value	match_some(8)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		14: Option(InstOutput)	some(18)
		15: Option(Option(InstOutput))	some(14)
		17: ValueRegs	constructor(value_reg, [12], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1858
		../../codegen/src/isa/aarch64/inst.isle line 2803
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(bitselect, 7)
		9: (Value, Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(9, 2)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_some(6)
		19: Option(InstOutput)	some(30)
		20: Option(Option(InstOutput))	some(19)
		25: VectorSize	constructor(vector_size, [16], 1)
		26: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRRMod, [26, 37, 11, 13, 15, 25])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1852
		../../codegen/src/isa/aarch64/inst.isle line 2713
		../../codegen/src/isa/aarch64/inst.isle line 2731
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Value))	extractor(bitselect, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: (Value, Value, Value)	match_some(6)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		15: Value	match_tuple(9, 2)
		16: Reg	constructor(put_in_reg, [15], 4)
		17: Reg	constructor(put_in_reg, [12], 5)
		21: Option(InstOutput)	some(40)
		22: Option(Option(InstOutput))	some(21)
		26: ALUOp	make_variant(ALUOp::And, [])
		31: ALUOp	make_variant(ALUOp::AndNot, [])
		36: ALUOp	make_variant(ALUOp::Orr, [])
		39: ValueRegs	constructor(value_reg, [70], 1)
		40: InstOutput	constructor(output, [39], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [7], 2)
		48: MInst	make_variant(MInst::AluRRR, [26, 47, 46, 11, 13])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [7], 2)
		58: MInst	make_variant(MInst::AluRRR, [31, 57, 56, 16, 17])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [7], 2)
		68: MInst	make_variant(MInst::AluRRR, [36, 67, 66, 50, 60])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1847
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Cnt, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1839
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2278
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		16: u8	const_int(1, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		19: VectorSize	make_variant(VectorSize::Size8x16, [])
		22: u8	const_int(0, u8)
		23: ScalarSize	make_variant(ScalarSize::Size8, [])
		25: Type	const_prim(I64)
		26: ImmExtend	make_variant(ImmExtend::Zero, [])
		27: u64	const_int(0, u64)
		28: Reg	constructor(imm, [25, 26, 27], 9)
		29: ValueRegs	constructor(value_regs, [64, 28], 10)
		30: InstOutput	constructor(output, [29], 11)
		31: Option(InstOutput)	some(30)
		32: Option(Option(InstOutput))	some(31)
		35: Type	const_prim(I8X16)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: MInst	make_variant(MInst::MovToFpu, [36, 11, 12])
		38: Unit	constructor(emit, [37], 2)
		39: Reg	constructor(writable_reg_to_reg, [36], 0)
		44: Type	const_prim(I8X16)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MInst	make_variant(MInst::MovToVec, [45, 39, 15, 16, 17])
		47: Unit	constructor(emit, [46], 2)
		48: Reg	constructor(writable_reg_to_reg, [45], 0)
		51: VecMisc2	make_variant(VecMisc2::Cnt, [])
		55: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		60: Type	const_prim(I64)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::MovFromVec, [61, 80, 22, 23])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
		68: Type	const_prim(I8X16)
		69: WritableReg	constructor(temp_writable_reg, [68], 1)
		70: MInst	make_variant(MInst::VecMisc, [51, 69, 48, 19])
		71: Unit	constructor(emit, [70], 2)
		72: Reg	constructor(writable_reg_to_reg, [69], 0)
		76: Type	const_prim(I8X16)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: MInst	make_variant(MInst::VecLanes, [55, 77, 72, 19])
		79: Unit	constructor(emit, [78], 2)
		80: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 32
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1833
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(46)
		20: Option(Option(InstOutput))	some(19)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::MovToFpu, [24, 9, 10])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: VecMisc2	make_variant(VecMisc2::Cnt, [])
		34: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::MovFromVec, [40, 62, 15, 16])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
		50: Type	const_prim(I8X16)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::VecMisc, [30, 51, 27, 12])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: MInst	make_variant(MInst::VecLanes, [34, 59, 54, 12])
		61: Unit	constructor(emit, [60], 2)
		62: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1827
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2607
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1961
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(46)
		20: Option(Option(InstOutput))	some(19)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::MovToFpu, [24, 9, 10])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: VecMisc2	make_variant(VecMisc2::Cnt, [])
		34: VecLanesOp	make_variant(VecLanesOp::Addv, [])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::MovFromVec, [40, 62, 15, 16])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ValueRegs	constructor(value_reg, [43], 1)
		46: InstOutput	constructor(output, [45], 2)
		50: Type	const_prim(I8X16)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: MInst	make_variant(MInst::VecMisc, [30, 51, 27, 12])
		53: Unit	constructor(emit, [52], 2)
		54: Reg	constructor(writable_reg_to_reg, [51], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: MInst	make_variant(MInst::VecLanes, [34, 59, 54, 12])
		61: Unit	constructor(emit, [60], 2)
		62: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1821
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		19: Option(InstOutput)	some(47)
		20: Option(Option(InstOutput))	some(19)
		23: Type	const_prim(I8X16)
		24: WritableReg	constructor(temp_writable_reg, [23], 1)
		25: MInst	make_variant(MInst::MovToFpu, [24, 9, 10])
		26: Unit	constructor(emit, [25], 2)
		27: Reg	constructor(writable_reg_to_reg, [24], 0)
		30: VecMisc2	make_variant(VecMisc2::Cnt, [])
		35: VecALUOp	make_variant(VecALUOp::Addp, [])
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::MovFromVec, [41, 64, 15, 16])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
		46: ValueRegs	constructor(value_reg, [44], 1)
		47: InstOutput	constructor(output, [46], 2)
		51: Type	const_prim(I8X16)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: MInst	make_variant(MInst::VecMisc, [30, 52, 27, 12])
		54: Unit	constructor(emit, [53], 2)
		55: Reg	constructor(writable_reg_to_reg, [52], 0)
		60: Type	const_prim(I8X16)
		61: WritableReg	constructor(temp_writable_reg, [60], 1)
		62: MInst	make_variant(MInst::VecRRR, [35, 61, 55, 55, 12])
		63: Unit	constructor(emit, [62], 2)
		64: Reg	constructor(writable_reg_to_reg, [61], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1815
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/isa/aarch64/inst.isle line 2798
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(popcnt, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size8, [])
		18: Option(InstOutput)	some(41)
		19: Option(Option(InstOutput))	some(18)
		22: Type	const_prim(I8X16)
		23: WritableReg	constructor(temp_writable_reg, [22], 1)
		24: MInst	make_variant(MInst::MovToFpu, [23, 9, 10])
		25: Unit	constructor(emit, [24], 2)
		26: Reg	constructor(writable_reg_to_reg, [23], 0)
		29: VecMisc2	make_variant(VecMisc2::Cnt, [])
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::MovFromVec, [35, 49, 14, 15])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		40: ValueRegs	constructor(value_reg, [38], 1)
		41: InstOutput	constructor(output, [40], 2)
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecMisc, [29, 46, 26, 12])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1793
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bmask, 5)
		7: Value	match_some(6)
		8: ValueRegs	constructor(put_in_regs, [7], 1)
		9: Type	match_tuple(4, 0)
		10: Type	extractor(value_type, 7)
		11: ValueRegs	constructor(lower_bmask, [9, 10, 8], 2)
		12: InstOutput	constructor(output, [11], 3)
		13: Option(InstOutput)	some(12)
		14: Option(Option(InstOutput))	some(13)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1785
		../../codegen/src/isa/aarch64/inst.isle line 2788
		../../codegen/src/isa/aarch64/inst.isle line 2788
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(1, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: Type	const_prim(I64)
		14: ValueRegs	constructor(put_in_regs, [8], 4)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		18: ValueRegs	constructor(value_regs, [38, 47], 7)
		19: InstOutput	constructor(output, [18], 8)
		20: Option(InstOutput)	some(19)
		21: Option(Option(InstOutput))	some(20)
		24: BitOp	make_variant(BitOp::Rev64, [])
		28: BitOp	make_variant(BitOp::Rev64, [])
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [12], 2)
		36: MInst	make_variant(MInst::BitRR, [24, 35, 34, 11])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [12], 2)
		45: MInst	make_variant(MInst::BitRR, [28, 44, 43, 16])
		46: Unit	constructor(emit, [45], 3)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1782
		../../codegen/src/isa/aarch64/inst.isle line 2788
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I64)
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: BitOp	make_variant(BitOp::Rev64, [])
		20: ValueRegs	constructor(value_reg, [30], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	constructor(operand_size, [10], 2)
		28: MInst	make_variant(MInst::BitRR, [17, 27, 26, 9])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1779
		../../codegen/src/isa/aarch64/inst.isle line 2785
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: BitOp	make_variant(BitOp::Rev32, [])
		20: ValueRegs	constructor(value_reg, [30], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	constructor(operand_size, [10], 2)
		28: MInst	make_variant(MInst::BitRR, [17, 27, 26, 9])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1776
		../../codegen/src/isa/aarch64/inst.isle line 2782
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bswap, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I16)
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: BitOp	make_variant(BitOp::Rev16, [])
		20: ValueRegs	constructor(value_reg, [30], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: OperandSize	constructor(operand_size, [10], 2)
		28: MInst	make_variant(MInst::BitRR, [17, 27, 26, 9])
		29: Unit	constructor(emit, [28], 3)
		30: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1771
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(cls, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		12: Option(InstOutput)	some(20)
		13: Option(Option(InstOutput))	some(12)
		16: BitOp	make_variant(BitOp::Cls, [])
		19: ValueRegs	constructor(value_reg, [29], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [9], 2)
		27: MInst	make_variant(MInst::BitRR, [16, 26, 25, 8])
		28: Unit	constructor(emit, [27], 3)
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1757
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2793
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2123
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/prelude_lower.isle line 568
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: usize	const_int(1, usize)
		13: Reg	constructor(value_regs_get, [9, 12], 3)
		14: Type	const_prim(I64)
		18: u8	const_int(63, u8)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 7)
		22: Imm12	constructor(u8_into_imm12, [18], 10)
		24: Reg	constructor(zero_reg, [], 12)
		25: Cond	make_variant(Cond::Eq, [])
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	const_int(0, u64)
		31: Reg	constructor(imm, [14, 29, 30], 16)
		32: ValueRegs	constructor(value_regs, [147, 31], 17)
		33: InstOutput	constructor(output, [32], 18)
		34: Option(InstOutput)	some(33)
		35: Option(Option(InstOutput))	some(34)
		38: BitOp	make_variant(BitOp::Cls, [])
		42: BitOp	make_variant(BitOp::Cls, [])
		47: ALUOp	make_variant(ALUOp::EorNot, [])
		52: ALUOp	make_variant(ALUOp::Lsr, [])
		58: ALUOp3	make_variant(ALUOp3::MAdd, [])
		62: OperandSize	make_variant(OperandSize::Size64, [])
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: MInst	make_variant(MInst::CSel, [68, 25, 130, 24])
		70: Reg	constructor(writable_reg_to_reg, [68], 0)
		71: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [69, 70])
		74: ValueRegs	constructor(with_flags, [137, 71], 1)
		75: usize	const_int(0, usize)
		76: Reg	constructor(value_regs_get, [74, 75], 2)
		80: ALUOp	make_variant(ALUOp::Add, [])
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: OperandSize	constructor(operand_size, [14], 2)
		88: MInst	make_variant(MInst::BitRR, [38, 87, 86, 11])
		89: Unit	constructor(emit, [88], 3)
		90: Reg	constructor(writable_reg_to_reg, [86], 0)
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: OperandSize	constructor(operand_size, [14], 2)
		97: MInst	make_variant(MInst::BitRR, [42, 96, 95, 13])
		98: Unit	constructor(emit, [97], 3)
		99: Reg	constructor(writable_reg_to_reg, [95], 0)
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: OperandSize	constructor(operand_size, [14], 2)
		107: MInst	make_variant(MInst::AluRRR, [47, 106, 105, 13, 11])
		108: Unit	constructor(emit, [107], 3)
		109: Reg	constructor(writable_reg_to_reg, [105], 0)
		114: Type	const_prim(I64)
		115: WritableReg	constructor(temp_writable_reg, [114], 1)
		116: OperandSize	constructor(operand_size, [14], 2)
		117: MInst	make_variant(MInst::AluRRImmShift, [52, 116, 115, 109, 19])
		118: Unit	constructor(emit, [117], 3)
		119: Reg	constructor(writable_reg_to_reg, [115], 0)
		125: Type	const_prim(I64)
		126: WritableReg	constructor(temp_writable_reg, [125], 1)
		127: OperandSize	constructor(operand_size, [14], 2)
		128: MInst	make_variant(MInst::AluRRRR, [58, 127, 126, 90, 119, 119])
		129: Unit	constructor(emit, [128], 3)
		130: Reg	constructor(writable_reg_to_reg, [126], 0)
		134: WritableReg	constructor(writable_zero_reg, [], 1)
		135: ALUOp	make_variant(ALUOp::SubS, [])
		136: MInst	make_variant(MInst::AluRRImm12, [135, 62, 134, 99, 22])
		137: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [136])
		142: Type	const_prim(I64)
		143: WritableReg	constructor(temp_writable_reg, [142], 1)
		144: OperandSize	constructor(operand_size, [14], 2)
		145: MInst	make_variant(MInst::AluRRR, [80, 144, 143, 76, 99])
		146: Unit	constructor(emit, [145], 3)
		147: Reg	constructor(writable_reg_to_reg, [143], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 35
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1745
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg_sext32, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(29)
		17: Option(Option(InstOutput))	some(16)
		20: BitOp	make_variant(BitOp::Cls, [])
		25: ALUOp	make_variant(ALUOp::Sub, [])
		28: ValueRegs	constructor(value_reg, [48], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [10], 2)
		36: MInst	make_variant(MInst::BitRR, [20, 35, 34, 9])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [10], 2)
		46: MInst	make_variant(MInst::AluRRImm12, [25, 45, 44, 38, 13])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1742
		../../codegen/src/isa/aarch64/inst.isle line 2777
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(cls, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg_sext32, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(29)
		17: Option(Option(InstOutput))	some(16)
		20: BitOp	make_variant(BitOp::Cls, [])
		25: ALUOp	make_variant(ALUOp::Sub, [])
		28: ValueRegs	constructor(value_reg, [48], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [10], 2)
		36: MInst	make_variant(MInst::BitRR, [20, 35, 34, 9])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [10], 2)
		46: MInst	make_variant(MInst::AluRRImm12, [25, 45, 44, 38, 13])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1737
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(ctz, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		13: Option(InstOutput)	some(25)
		14: Option(Option(InstOutput))	some(13)
		17: BitOp	make_variant(BitOp::RBit, [])
		21: BitOp	make_variant(BitOp::Clz, [])
		24: ValueRegs	constructor(value_reg, [43], 1)
		25: InstOutput	constructor(output, [24], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [9], 2)
		32: MInst	make_variant(MInst::BitRR, [17, 31, 30, 8])
		33: Unit	constructor(emit, [32], 3)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [9], 2)
		41: MInst	make_variant(MInst::BitRR, [21, 40, 39, 34])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1731
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/lower.isle line 1713
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: Type	const_prim(I64)
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		17: ValueRegs	constructor(value_regs, [63, 54], 6)
		19: InstOutput	constructor(output, [45], 8)
		20: Option(InstOutput)	some(19)
		21: Option(Option(InstOutput))	some(20)
		24: BitOp	make_variant(BitOp::RBit, [])
		28: BitOp	make_variant(BitOp::RBit, [])
		31: usize	const_int(1, usize)
		32: Reg	constructor(value_regs_get, [17, 31], 1)
		33: Type	const_prim(I64)
		35: usize	const_int(0, usize)
		36: Reg	constructor(value_regs_get, [17, 35], 3)
		38: u8	const_int(6, u8)
		39: ImmShift	constructor(imm_shift_from_u8, [38], 5)
		42: ImmExtend	make_variant(ImmExtend::Zero, [])
		43: u64	const_int(0, u64)
		44: Reg	constructor(imm, [33, 42, 43], 8)
		45: ValueRegs	constructor(value_regs, [121, 44], 9)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [12], 2)
		52: MInst	make_variant(MInst::BitRR, [24, 51, 50, 11])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
		58: Type	const_prim(I64)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: OperandSize	constructor(operand_size, [12], 2)
		61: MInst	make_variant(MInst::BitRR, [28, 60, 59, 15])
		62: Unit	constructor(emit, [61], 3)
		63: Reg	constructor(writable_reg_to_reg, [59], 0)
		66: BitOp	make_variant(BitOp::Clz, [])
		70: BitOp	make_variant(BitOp::Clz, [])
		75: ALUOp	make_variant(ALUOp::Lsr, [])
		81: ALUOp3	make_variant(ALUOp3::MAdd, [])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: OperandSize	constructor(operand_size, [33], 2)
		89: MInst	make_variant(MInst::BitRR, [66, 88, 87, 32])
		90: Unit	constructor(emit, [89], 3)
		91: Reg	constructor(writable_reg_to_reg, [87], 0)
		95: Type	const_prim(I64)
		96: WritableReg	constructor(temp_writable_reg, [95], 1)
		97: OperandSize	constructor(operand_size, [33], 2)
		98: MInst	make_variant(MInst::BitRR, [70, 97, 96, 36])
		99: Unit	constructor(emit, [98], 3)
		100: Reg	constructor(writable_reg_to_reg, [96], 0)
		105: Type	const_prim(I64)
		106: WritableReg	constructor(temp_writable_reg, [105], 1)
		107: OperandSize	constructor(operand_size, [33], 2)
		108: MInst	make_variant(MInst::AluRRImmShift, [75, 107, 106, 91, 39])
		109: Unit	constructor(emit, [108], 3)
		110: Reg	constructor(writable_reg_to_reg, [106], 0)
		116: Type	const_prim(I64)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: OperandSize	constructor(operand_size, [33], 2)
		119: MInst	make_variant(MInst::AluRRRR, [81, 118, 117, 100, 110, 91])
		120: Unit	constructor(emit, [119], 3)
		121: Reg	constructor(writable_reg_to_reg, [117], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1728
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u64	const_int(32768, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 3)
		17: Option(InstOutput)	some(34)
		18: Option(Option(InstOutput))	some(17)
		21: BitOp	make_variant(BitOp::RBit, [])
		26: ALUOp	make_variant(ALUOp::Orr, [])
		30: BitOp	make_variant(BitOp::Clz, [])
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [10], 2)
		41: MInst	make_variant(MInst::BitRR, [21, 40, 39, 9])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [10], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [26, 50, 49, 43, 13])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [10], 2)
		60: MInst	make_variant(MInst::BitRR, [30, 59, 58, 53])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1725
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ctz, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u64	const_int(8388608, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 3)
		17: Option(InstOutput)	some(34)
		18: Option(Option(InstOutput))	some(17)
		21: BitOp	make_variant(BitOp::RBit, [])
		26: ALUOp	make_variant(ALUOp::Orr, [])
		30: BitOp	make_variant(BitOp::Clz, [])
		33: ValueRegs	constructor(value_reg, [62], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [10], 2)
		41: MInst	make_variant(MInst::BitRR, [21, 40, 39, 9])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [10], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [26, 50, 49, 43, 13])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		59: OperandSize	constructor(operand_size, [10], 2)
		60: MInst	make_variant(MInst::BitRR, [30, 59, 58, 53])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1704
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(clz, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		12: Option(InstOutput)	some(20)
		13: Option(Option(InstOutput))	some(12)
		16: BitOp	make_variant(BitOp::Clz, [])
		19: ValueRegs	constructor(value_reg, [29], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [9], 2)
		27: MInst	make_variant(MInst::BitRR, [16, 26, 25, 8])
		28: Unit	constructor(emit, [27], 3)
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1701
		../../codegen/src/isa/aarch64/lower.isle line 1713
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		11: InstOutput	constructor(output, [29], 3)
		12: Option(InstOutput)	some(11)
		13: Option(Option(InstOutput))	some(12)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [9, 15], 1)
		17: Type	const_prim(I64)
		19: usize	const_int(0, usize)
		20: Reg	constructor(value_regs_get, [9, 19], 3)
		22: u8	const_int(6, u8)
		23: ImmShift	constructor(imm_shift_from_u8, [22], 5)
		26: ImmExtend	make_variant(ImmExtend::Zero, [])
		27: u64	const_int(0, u64)
		28: Reg	constructor(imm, [17, 26, 27], 8)
		29: ValueRegs	constructor(value_regs, [87, 28], 9)
		32: BitOp	make_variant(BitOp::Clz, [])
		36: BitOp	make_variant(BitOp::Clz, [])
		41: ALUOp	make_variant(ALUOp::Lsr, [])
		47: ALUOp3	make_variant(ALUOp3::MAdd, [])
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		54: OperandSize	constructor(operand_size, [17], 2)
		55: MInst	make_variant(MInst::BitRR, [32, 54, 53, 16])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: OperandSize	constructor(operand_size, [17], 2)
		64: MInst	make_variant(MInst::BitRR, [36, 63, 62, 20])
		65: Unit	constructor(emit, [64], 3)
		66: Reg	constructor(writable_reg_to_reg, [62], 0)
		71: Type	const_prim(I64)
		72: WritableReg	constructor(temp_writable_reg, [71], 1)
		73: OperandSize	constructor(operand_size, [17], 2)
		74: MInst	make_variant(MInst::AluRRImmShift, [41, 73, 72, 57, 23])
		75: Unit	constructor(emit, [74], 3)
		76: Reg	constructor(writable_reg_to_reg, [72], 0)
		82: Type	const_prim(I64)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: OperandSize	constructor(operand_size, [17], 2)
		85: MInst	make_variant(MInst::AluRRRR, [47, 84, 83, 66, 76, 57])
		86: Unit	constructor(emit, [85], 3)
		87: Reg	constructor(writable_reg_to_reg, [83], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1698
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg_zext32, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(29)
		17: Option(Option(InstOutput))	some(16)
		20: BitOp	make_variant(BitOp::Clz, [])
		25: ALUOp	make_variant(ALUOp::Sub, [])
		28: ValueRegs	constructor(value_reg, [48], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [10], 2)
		36: MInst	make_variant(MInst::BitRR, [20, 35, 34, 9])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [10], 2)
		46: MInst	make_variant(MInst::AluRRImm12, [25, 45, 44, 38, 13])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1695
		../../codegen/src/isa/aarch64/inst.isle line 2772
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(clz, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg_zext32, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		16: Option(InstOutput)	some(29)
		17: Option(Option(InstOutput))	some(16)
		20: BitOp	make_variant(BitOp::Clz, [])
		25: ALUOp	make_variant(ALUOp::Sub, [])
		28: ValueRegs	constructor(value_reg, [48], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [10], 2)
		36: MInst	make_variant(MInst::BitRR, [20, 35, 34, 9])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [10], 2)
		46: MInst	make_variant(MInst::AluRRImm12, [25, 45, 44, 38, 13])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1689
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(bitrev, 5)
		7: Value	match_some(6)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Type	match_tuple(4, 0)
		12: Option(InstOutput)	some(20)
		13: Option(Option(InstOutput))	some(12)
		16: BitOp	make_variant(BitOp::RBit, [])
		19: ValueRegs	constructor(value_reg, [29], 1)
		20: InstOutput	constructor(output, [19], 2)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: OperandSize	constructor(operand_size, [9], 2)
		27: MInst	make_variant(MInst::BitRR, [16, 26, 25, 8])
		28: Unit	constructor(emit, [27], 3)
		29: Reg	constructor(writable_reg_to_reg, [25], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1683
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 2066
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: Type	const_prim(I64)
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		17: ValueRegs	constructor(value_regs, [46, 37], 6)
		18: InstOutput	constructor(output, [17], 7)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		23: BitOp	make_variant(BitOp::RBit, [])
		27: BitOp	make_variant(BitOp::RBit, [])
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [12], 2)
		35: MInst	make_variant(MInst::BitRR, [23, 34, 33, 11])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: OperandSize	constructor(operand_size, [12], 2)
		44: MInst	make_variant(MInst::BitRR, [27, 43, 42, 15])
		45: Unit	constructor(emit, [44], 3)
		46: Reg	constructor(writable_reg_to_reg, [42], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1680
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(16, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		16: Option(InstOutput)	some(29)
		17: Option(Option(InstOutput))	some(16)
		20: BitOp	make_variant(BitOp::RBit, [])
		25: ALUOp	make_variant(ALUOp::Lsr, [])
		28: ValueRegs	constructor(value_reg, [48], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [10], 2)
		36: MInst	make_variant(MInst::BitRR, [20, 35, 34, 9])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [10], 2)
		46: MInst	make_variant(MInst::AluRRImmShift, [25, 45, 44, 38, 13])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1674
		../../codegen/src/isa/aarch64/inst.isle line 2767
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2066
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bitrev, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Type	const_prim(I32)
		12: u8	const_int(24, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		16: Option(InstOutput)	some(29)
		17: Option(Option(InstOutput))	some(16)
		20: BitOp	make_variant(BitOp::RBit, [])
		25: ALUOp	make_variant(ALUOp::Lsr, [])
		28: ValueRegs	constructor(value_reg, [48], 1)
		29: InstOutput	constructor(output, [28], 2)
		33: Type	const_prim(I64)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: OperandSize	constructor(operand_size, [10], 2)
		36: MInst	make_variant(MInst::BitRR, [20, 35, 34, 9])
		37: Unit	constructor(emit, [36], 3)
		38: Reg	constructor(writable_reg_to_reg, [34], 0)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [10], 2)
		46: MInst	make_variant(MInst::AluRRImmShift, [25, 45, 44, 38, 13])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1659
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/lower.isle line 1449
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I64)
		16: ImmExtend	make_variant(ImmExtend::Zero, [])
		17: u64	const_int(128, u64)
		18: Reg	constructor(imm, [15, 16, 17], 4)
		22: usize	const_int(1, usize)
		23: Reg	constructor(value_regs_get, [63, 22], 8)
		24: Reg	constructor(value_regs_get, [89, 22], 9)
		26: Reg	constructor(value_regs_get, [63, 13], 11)
		27: Reg	constructor(value_regs_get, [89, 13], 12)
		29: ValueRegs	constructor(value_regs, [237, 227], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		32: Option(Option(InstOutput))	some(31)
		36: ALUOp	make_variant(ALUOp::Sub, [])
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [10, 40], 1)
		42: usize	const_int(1, usize)
		43: Reg	constructor(value_regs_get, [10, 42], 2)
		44: Type	const_prim(I64)
		47: Reg	constructor(zero_reg, [], 5)
		48: Type	const_prim(I32)
		50: u8	const_int(1, u8)
		51: ImmShift	constructor(imm_shift_from_u8, [50], 7)
		55: u64	const_int(64, u64)
		56: ImmLogic	constructor(u64_into_imm_logic, [44, 55], 11)
		58: Cond	make_variant(Cond::Ne, [])
		60: Reg	constructor(zero_reg, [], 14)
		62: ConsumesFlags	constructor(consumes_flags_concat, [155, 163], 16)
		63: ValueRegs	constructor(with_flags, [147, 62], 17)
		66: usize	const_int(0, usize)
		67: Reg	constructor(value_regs_get, [10, 66], 1)
		68: usize	const_int(1, usize)
		69: Reg	constructor(value_regs_get, [10, 68], 2)
		70: Type	const_prim(I64)
		73: Reg	constructor(zero_reg, [], 5)
		74: Type	const_prim(I32)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		81: u64	const_int(64, u64)
		82: ImmLogic	constructor(u64_into_imm_logic, [70, 81], 11)
		84: Reg	constructor(zero_reg, [], 13)
		85: Cond	make_variant(Cond::Ne, [])
		88: ConsumesFlags	constructor(consumes_flags_concat, [209, 217], 16)
		89: ValueRegs	constructor(with_flags, [201, 88], 17)
		93: ALUOp	make_variant(ALUOp::Orr, [])
		98: ALUOp	make_variant(ALUOp::Orr, [])
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: OperandSize	constructor(operand_size, [15], 2)
		107: MInst	make_variant(MInst::AluRRR, [36, 106, 105, 18, 14])
		108: Unit	constructor(emit, [107], 3)
		109: Reg	constructor(writable_reg_to_reg, [105], 0)
		113: ALUOp	make_variant(ALUOp::Lsr, [])
		118: ALUOp	make_variant(ALUOp::Lsr, [])
		123: ALUOp	make_variant(ALUOp::OrrNot, [])
		128: ALUOp	make_variant(ALUOp::Lsl, [])
		133: ALUOp	make_variant(ALUOp::Lsl, [])
		138: ALUOp	make_variant(ALUOp::Orr, [])
		143: OperandSize	constructor(operand_size, [44], 1)
		144: WritableReg	constructor(writable_zero_reg, [], 2)
		145: ALUOp	make_variant(ALUOp::AndS, [])
		146: MInst	make_variant(MInst::AluRRImmLogic, [145, 143, 144, 14, 56])
		147: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [146])
		151: Type	const_prim(I64)
		152: WritableReg	constructor(temp_writable_reg, [151], 1)
		153: MInst	make_variant(MInst::CSel, [152, 58, 257, 297])
		154: Reg	constructor(writable_reg_to_reg, [152], 0)
		155: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [153, 154])
		159: Type	const_prim(I64)
		160: WritableReg	constructor(temp_writable_reg, [159], 1)
		161: MInst	make_variant(MInst::CSel, [160, 58, 60, 257])
		162: Reg	constructor(writable_reg_to_reg, [160], 0)
		163: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [161, 162])
		167: ALUOp	make_variant(ALUOp::Lsl, [])
		172: ALUOp	make_variant(ALUOp::Lsl, [])
		177: ALUOp	make_variant(ALUOp::OrrNot, [])
		182: ALUOp	make_variant(ALUOp::Lsr, [])
		187: ALUOp	make_variant(ALUOp::Lsr, [])
		192: ALUOp	make_variant(ALUOp::Orr, [])
		197: OperandSize	constructor(operand_size, [70], 1)
		198: WritableReg	constructor(writable_zero_reg, [], 2)
		199: ALUOp	make_variant(ALUOp::AndS, [])
		200: MInst	make_variant(MInst::AluRRImmLogic, [199, 197, 198, 109, 82])
		201: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [200])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 85, 84, 307])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 85, 307, 357])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		222: Type	const_prim(I64)
		223: WritableReg	constructor(temp_writable_reg, [222], 1)
		224: OperandSize	constructor(operand_size, [15], 2)
		225: MInst	make_variant(MInst::AluRRR, [93, 224, 223, 23, 24])
		226: Unit	constructor(emit, [225], 3)
		227: Reg	constructor(writable_reg_to_reg, [223], 0)
		232: Type	const_prim(I64)
		233: WritableReg	constructor(temp_writable_reg, [232], 1)
		234: OperandSize	constructor(operand_size, [15], 2)
		235: MInst	make_variant(MInst::AluRRR, [98, 234, 233, 26, 27])
		236: Unit	constructor(emit, [235], 3)
		237: Reg	constructor(writable_reg_to_reg, [233], 0)
		242: Type	const_prim(I64)
		243: WritableReg	constructor(temp_writable_reg, [242], 1)
		244: OperandSize	constructor(operand_size, [44], 2)
		245: MInst	make_variant(MInst::AluRRR, [113, 244, 243, 41, 14])
		246: Unit	constructor(emit, [245], 3)
		247: Reg	constructor(writable_reg_to_reg, [243], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: OperandSize	constructor(operand_size, [44], 2)
		255: MInst	make_variant(MInst::AluRRR, [118, 254, 253, 43, 14])
		256: Unit	constructor(emit, [255], 3)
		257: Reg	constructor(writable_reg_to_reg, [253], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: OperandSize	constructor(operand_size, [48], 2)
		265: MInst	make_variant(MInst::AluRRR, [123, 264, 263, 47, 14])
		266: Unit	constructor(emit, [265], 3)
		267: Reg	constructor(writable_reg_to_reg, [263], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: OperandSize	constructor(operand_size, [44], 2)
		275: MInst	make_variant(MInst::AluRRImmShift, [128, 274, 273, 43, 51])
		276: Unit	constructor(emit, [275], 3)
		277: Reg	constructor(writable_reg_to_reg, [273], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: OperandSize	constructor(operand_size, [44], 2)
		285: MInst	make_variant(MInst::AluRRR, [133, 284, 283, 277, 267])
		286: Unit	constructor(emit, [285], 3)
		287: Reg	constructor(writable_reg_to_reg, [283], 0)
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: OperandSize	constructor(operand_size, [44], 2)
		295: MInst	make_variant(MInst::AluRRR, [138, 294, 293, 247, 287])
		296: Unit	constructor(emit, [295], 3)
		297: Reg	constructor(writable_reg_to_reg, [293], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: OperandSize	constructor(operand_size, [70], 2)
		305: MInst	make_variant(MInst::AluRRR, [167, 304, 303, 67, 109])
		306: Unit	constructor(emit, [305], 3)
		307: Reg	constructor(writable_reg_to_reg, [303], 0)
		312: Type	const_prim(I64)
		313: WritableReg	constructor(temp_writable_reg, [312], 1)
		314: OperandSize	constructor(operand_size, [70], 2)
		315: MInst	make_variant(MInst::AluRRR, [172, 314, 313, 69, 109])
		316: Unit	constructor(emit, [315], 3)
		317: Reg	constructor(writable_reg_to_reg, [313], 0)
		322: Type	const_prim(I64)
		323: WritableReg	constructor(temp_writable_reg, [322], 1)
		324: OperandSize	constructor(operand_size, [74], 2)
		325: MInst	make_variant(MInst::AluRRR, [177, 324, 323, 73, 109])
		326: Unit	constructor(emit, [325], 3)
		327: Reg	constructor(writable_reg_to_reg, [323], 0)
		332: Type	const_prim(I64)
		333: WritableReg	constructor(temp_writable_reg, [332], 1)
		334: OperandSize	constructor(operand_size, [70], 2)
		335: MInst	make_variant(MInst::AluRRImmShift, [182, 334, 333, 67, 77])
		336: Unit	constructor(emit, [335], 3)
		337: Reg	constructor(writable_reg_to_reg, [333], 0)
		342: Type	const_prim(I64)
		343: WritableReg	constructor(temp_writable_reg, [342], 1)
		344: OperandSize	constructor(operand_size, [70], 2)
		345: MInst	make_variant(MInst::AluRRR, [187, 344, 343, 337, 327])
		346: Unit	constructor(emit, [345], 3)
		347: Reg	constructor(writable_reg_to_reg, [343], 0)
		352: Type	const_prim(I64)
		353: WritableReg	constructor(temp_writable_reg, [352], 1)
		354: OperandSize	constructor(operand_size, [70], 2)
		355: MInst	make_variant(MInst::AluRRR, [192, 354, 353, 317, 347])
		356: Unit	constructor(emit, [355], 3)
		357: Reg	constructor(writable_reg_to_reg, [353], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 32
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1610
		../../codegen/src/isa/aarch64/inst.isle line 2762
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		21: Option(InstOutput)	some(30)
		22: Option(Option(InstOutput))	some(21)
		26: ALUOp	make_variant(ALUOp::RotR, [])
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [13], 2)
		38: MInst	make_variant(MInst::AluRRImmShift, [26, 37, 36, 17, 18])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1605
		../../codegen/src/isa/aarch64/inst.isle line 2762
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		21: Option(InstOutput)	some(30)
		22: Option(Option(InstOutput))	some(21)
		26: ALUOp	make_variant(ALUOp::RotR, [])
		29: ValueRegs	constructor(value_reg, [40], 1)
		30: InstOutput	constructor(output, [29], 2)
		35: Type	const_prim(I64)
		36: WritableReg	constructor(temp_writable_reg, [35], 1)
		37: OperandSize	constructor(operand_size, [13], 2)
		38: MInst	make_variant(MInst::AluRRImmShift, [26, 37, 36, 17, 18])
		39: Unit	constructor(emit, [38], 3)
		40: Reg	constructor(writable_reg_to_reg, [36], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1600
		../../codegen/src/isa/aarch64/lower.isle line 1648
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		18: Reg	constructor(put_in_reg_zext32, [17], 1)
		19: ImmShift	match_some(16)
		22: Option(InstOutput)	some(34)
		23: Option(Option(InstOutput))	some(22)
		27: Type	const_prim(I32)
		29: ImmShift	constructor(rotr_opposite_amount, [14, 19], 2)
		33: ValueRegs	constructor(value_reg, [79], 1)
		34: InstOutput	constructor(output, [33], 2)
		38: ALUOp	make_variant(ALUOp::Lsr, [])
		43: ALUOp	make_variant(ALUOp::Lsl, [])
		48: ALUOp	make_variant(ALUOp::Orr, [])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: OperandSize	constructor(operand_size, [27], 2)
		57: MInst	make_variant(MInst::AluRRImmShift, [38, 56, 55, 18, 19])
		58: Unit	constructor(emit, [57], 3)
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		64: Type	const_prim(I64)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: OperandSize	constructor(operand_size, [27], 2)
		67: MInst	make_variant(MInst::AluRRImmShift, [43, 66, 65, 18, 29])
		68: Unit	constructor(emit, [67], 3)
		69: Reg	constructor(writable_reg_to_reg, [65], 0)
		74: Type	const_prim(I64)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: OperandSize	constructor(operand_size, [27], 2)
		77: MInst	make_variant(MInst::AluRRR, [48, 76, 75, 69, 59])
		78: Unit	constructor(emit, [77], 3)
		79: Reg	constructor(writable_reg_to_reg, [75], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1596
		../../codegen/src/isa/aarch64/inst.isle line 2759
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I64)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::RotR, [])
		26: ValueRegs	constructor(value_reg, [37], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [15], 2)
		35: MInst	make_variant(MInst::AluRRR, [23, 34, 33, 10, 14])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1592
		../../codegen/src/isa/aarch64/inst.isle line 2759
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I32)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::RotR, [])
		26: ValueRegs	constructor(value_reg, [37], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [15], 2)
		35: MInst	make_variant(MInst::AluRRR, [23, 34, 33, 10, 14])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
		../../codegen/src/isa/aarch64/lower.isle line 1627
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_zext32, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: Type	match_some(6)
		19: Option(InstOutput)	some(37)
		20: Option(Option(InstOutput))	some(19)
		24: ImmLogic	constructor(rotr_mask, [16], 1)
		25: Type	const_prim(I32)
		27: u8	constructor(ty_bits, [16], 0)
		28: Imm12	constructor(u8_into_imm12, [27], 3)
		30: Reg	constructor(zero_reg, [], 5)
		36: ValueRegs	constructor(value_reg, [127], 1)
		37: InstOutput	constructor(output, [36], 2)
		41: ALUOp	make_variant(ALUOp::And, [])
		46: ALUOp	make_variant(ALUOp::Sub, [])
		51: ALUOp	make_variant(ALUOp::Sub, [])
		56: ALUOp	make_variant(ALUOp::Lsr, [])
		61: ALUOp	make_variant(ALUOp::Lsl, [])
		66: ALUOp	make_variant(ALUOp::Orr, [])
		72: Type	const_prim(I64)
		73: WritableReg	constructor(temp_writable_reg, [72], 1)
		74: OperandSize	constructor(operand_size, [25], 2)
		75: MInst	make_variant(MInst::AluRRImmLogic, [41, 74, 73, 15, 24])
		76: Unit	constructor(emit, [75], 3)
		77: Reg	constructor(writable_reg_to_reg, [73], 0)
		82: Type	const_prim(I64)
		83: WritableReg	constructor(temp_writable_reg, [82], 1)
		84: OperandSize	constructor(operand_size, [25], 2)
		85: MInst	make_variant(MInst::AluRRImm12, [46, 84, 83, 77, 28])
		86: Unit	constructor(emit, [85], 3)
		87: Reg	constructor(writable_reg_to_reg, [83], 0)
		92: Type	const_prim(I64)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: OperandSize	constructor(operand_size, [25], 2)
		95: MInst	make_variant(MInst::AluRRR, [51, 94, 93, 30, 87])
		96: Unit	constructor(emit, [95], 3)
		97: Reg	constructor(writable_reg_to_reg, [93], 0)
		102: Type	const_prim(I64)
		103: WritableReg	constructor(temp_writable_reg, [102], 1)
		104: OperandSize	constructor(operand_size, [25], 2)
		105: MInst	make_variant(MInst::AluRRR, [56, 104, 103, 11, 77])
		106: Unit	constructor(emit, [105], 3)
		107: Reg	constructor(writable_reg_to_reg, [103], 0)
		112: Type	const_prim(I64)
		113: WritableReg	constructor(temp_writable_reg, [112], 1)
		114: OperandSize	constructor(operand_size, [25], 2)
		115: MInst	make_variant(MInst::AluRRR, [61, 114, 113, 11, 97])
		116: Unit	constructor(emit, [115], 3)
		117: Reg	constructor(writable_reg_to_reg, [113], 0)
		122: Type	const_prim(I64)
		123: WritableReg	constructor(temp_writable_reg, [122], 1)
		124: OperandSize	constructor(operand_size, [25], 2)
		125: MInst	make_variant(MInst::AluRRR, [66, 124, 123, 117, 107])
		126: Unit	constructor(emit, [125], 3)
		127: Reg	constructor(writable_reg_to_reg, [123], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1575
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/lower.isle line 1449
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		15: Type	const_prim(I64)
		16: ImmExtend	make_variant(ImmExtend::Zero, [])
		17: u64	const_int(128, u64)
		18: Reg	constructor(imm, [15, 16, 17], 4)
		22: Reg	constructor(value_regs_get, [63, 13], 8)
		23: Reg	constructor(value_regs_get, [89, 13], 9)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [63, 25], 11)
		27: Reg	constructor(value_regs_get, [89, 25], 12)
		29: ValueRegs	constructor(value_regs, [227, 237], 14)
		30: InstOutput	constructor(output, [29], 15)
		31: Option(InstOutput)	some(30)
		32: Option(Option(InstOutput))	some(31)
		36: ALUOp	make_variant(ALUOp::Sub, [])
		40: usize	const_int(0, usize)
		41: Reg	constructor(value_regs_get, [10, 40], 1)
		42: usize	const_int(1, usize)
		43: Reg	constructor(value_regs_get, [10, 42], 2)
		44: Type	const_prim(I64)
		47: Reg	constructor(zero_reg, [], 5)
		48: Type	const_prim(I32)
		50: u8	const_int(1, u8)
		51: ImmShift	constructor(imm_shift_from_u8, [50], 7)
		55: u64	const_int(64, u64)
		56: ImmLogic	constructor(u64_into_imm_logic, [44, 55], 11)
		58: Reg	constructor(zero_reg, [], 13)
		59: Cond	make_variant(Cond::Ne, [])
		62: ConsumesFlags	constructor(consumes_flags_concat, [155, 163], 16)
		63: ValueRegs	constructor(with_flags, [147, 62], 17)
		66: usize	const_int(0, usize)
		67: Reg	constructor(value_regs_get, [10, 66], 1)
		68: usize	const_int(1, usize)
		69: Reg	constructor(value_regs_get, [10, 68], 2)
		70: Type	const_prim(I64)
		73: Reg	constructor(zero_reg, [], 5)
		74: Type	const_prim(I32)
		76: u8	const_int(1, u8)
		77: ImmShift	constructor(imm_shift_from_u8, [76], 7)
		81: u64	const_int(64, u64)
		82: ImmLogic	constructor(u64_into_imm_logic, [70, 81], 11)
		84: Cond	make_variant(Cond::Ne, [])
		86: Reg	constructor(zero_reg, [], 14)
		88: ConsumesFlags	constructor(consumes_flags_concat, [209, 217], 16)
		89: ValueRegs	constructor(with_flags, [201, 88], 17)
		93: ALUOp	make_variant(ALUOp::Orr, [])
		98: ALUOp	make_variant(ALUOp::Orr, [])
		104: Type	const_prim(I64)
		105: WritableReg	constructor(temp_writable_reg, [104], 1)
		106: OperandSize	constructor(operand_size, [15], 2)
		107: MInst	make_variant(MInst::AluRRR, [36, 106, 105, 18, 14])
		108: Unit	constructor(emit, [107], 3)
		109: Reg	constructor(writable_reg_to_reg, [105], 0)
		113: ALUOp	make_variant(ALUOp::Lsl, [])
		118: ALUOp	make_variant(ALUOp::Lsl, [])
		123: ALUOp	make_variant(ALUOp::OrrNot, [])
		128: ALUOp	make_variant(ALUOp::Lsr, [])
		133: ALUOp	make_variant(ALUOp::Lsr, [])
		138: ALUOp	make_variant(ALUOp::Orr, [])
		143: OperandSize	constructor(operand_size, [44], 1)
		144: WritableReg	constructor(writable_zero_reg, [], 2)
		145: ALUOp	make_variant(ALUOp::AndS, [])
		146: MInst	make_variant(MInst::AluRRImmLogic, [145, 143, 144, 14, 56])
		147: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [146])
		151: Type	const_prim(I64)
		152: WritableReg	constructor(temp_writable_reg, [151], 1)
		153: MInst	make_variant(MInst::CSel, [152, 59, 58, 247])
		154: Reg	constructor(writable_reg_to_reg, [152], 0)
		155: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [153, 154])
		159: Type	const_prim(I64)
		160: WritableReg	constructor(temp_writable_reg, [159], 1)
		161: MInst	make_variant(MInst::CSel, [160, 59, 247, 297])
		162: Reg	constructor(writable_reg_to_reg, [160], 0)
		163: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [161, 162])
		167: ALUOp	make_variant(ALUOp::Lsr, [])
		172: ALUOp	make_variant(ALUOp::Lsr, [])
		177: ALUOp	make_variant(ALUOp::OrrNot, [])
		182: ALUOp	make_variant(ALUOp::Lsl, [])
		187: ALUOp	make_variant(ALUOp::Lsl, [])
		192: ALUOp	make_variant(ALUOp::Orr, [])
		197: OperandSize	constructor(operand_size, [70], 1)
		198: WritableReg	constructor(writable_zero_reg, [], 2)
		199: ALUOp	make_variant(ALUOp::AndS, [])
		200: MInst	make_variant(MInst::AluRRImmLogic, [199, 197, 198, 109, 82])
		201: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [200])
		205: Type	const_prim(I64)
		206: WritableReg	constructor(temp_writable_reg, [205], 1)
		207: MInst	make_variant(MInst::CSel, [206, 84, 317, 357])
		208: Reg	constructor(writable_reg_to_reg, [206], 0)
		209: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [207, 208])
		213: Type	const_prim(I64)
		214: WritableReg	constructor(temp_writable_reg, [213], 1)
		215: MInst	make_variant(MInst::CSel, [214, 84, 86, 317])
		216: Reg	constructor(writable_reg_to_reg, [214], 0)
		217: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [215, 216])
		222: Type	const_prim(I64)
		223: WritableReg	constructor(temp_writable_reg, [222], 1)
		224: OperandSize	constructor(operand_size, [15], 2)
		225: MInst	make_variant(MInst::AluRRR, [93, 224, 223, 22, 23])
		226: Unit	constructor(emit, [225], 3)
		227: Reg	constructor(writable_reg_to_reg, [223], 0)
		232: Type	const_prim(I64)
		233: WritableReg	constructor(temp_writable_reg, [232], 1)
		234: OperandSize	constructor(operand_size, [15], 2)
		235: MInst	make_variant(MInst::AluRRR, [98, 234, 233, 26, 27])
		236: Unit	constructor(emit, [235], 3)
		237: Reg	constructor(writable_reg_to_reg, [233], 0)
		242: Type	const_prim(I64)
		243: WritableReg	constructor(temp_writable_reg, [242], 1)
		244: OperandSize	constructor(operand_size, [44], 2)
		245: MInst	make_variant(MInst::AluRRR, [113, 244, 243, 41, 14])
		246: Unit	constructor(emit, [245], 3)
		247: Reg	constructor(writable_reg_to_reg, [243], 0)
		252: Type	const_prim(I64)
		253: WritableReg	constructor(temp_writable_reg, [252], 1)
		254: OperandSize	constructor(operand_size, [44], 2)
		255: MInst	make_variant(MInst::AluRRR, [118, 254, 253, 43, 14])
		256: Unit	constructor(emit, [255], 3)
		257: Reg	constructor(writable_reg_to_reg, [253], 0)
		262: Type	const_prim(I64)
		263: WritableReg	constructor(temp_writable_reg, [262], 1)
		264: OperandSize	constructor(operand_size, [48], 2)
		265: MInst	make_variant(MInst::AluRRR, [123, 264, 263, 47, 14])
		266: Unit	constructor(emit, [265], 3)
		267: Reg	constructor(writable_reg_to_reg, [263], 0)
		272: Type	const_prim(I64)
		273: WritableReg	constructor(temp_writable_reg, [272], 1)
		274: OperandSize	constructor(operand_size, [44], 2)
		275: MInst	make_variant(MInst::AluRRImmShift, [128, 274, 273, 41, 51])
		276: Unit	constructor(emit, [275], 3)
		277: Reg	constructor(writable_reg_to_reg, [273], 0)
		282: Type	const_prim(I64)
		283: WritableReg	constructor(temp_writable_reg, [282], 1)
		284: OperandSize	constructor(operand_size, [44], 2)
		285: MInst	make_variant(MInst::AluRRR, [133, 284, 283, 277, 267])
		286: Unit	constructor(emit, [285], 3)
		287: Reg	constructor(writable_reg_to_reg, [283], 0)
		292: Type	const_prim(I64)
		293: WritableReg	constructor(temp_writable_reg, [292], 1)
		294: OperandSize	constructor(operand_size, [44], 2)
		295: MInst	make_variant(MInst::AluRRR, [138, 294, 293, 257, 287])
		296: Unit	constructor(emit, [295], 3)
		297: Reg	constructor(writable_reg_to_reg, [293], 0)
		302: Type	const_prim(I64)
		303: WritableReg	constructor(temp_writable_reg, [302], 1)
		304: OperandSize	constructor(operand_size, [70], 2)
		305: MInst	make_variant(MInst::AluRRR, [167, 304, 303, 67, 109])
		306: Unit	constructor(emit, [305], 3)
		307: Reg	constructor(writable_reg_to_reg, [303], 0)
		312: Type	const_prim(I64)
		313: WritableReg	constructor(temp_writable_reg, [312], 1)
		314: OperandSize	constructor(operand_size, [70], 2)
		315: MInst	make_variant(MInst::AluRRR, [172, 314, 313, 69, 109])
		316: Unit	constructor(emit, [315], 3)
		317: Reg	constructor(writable_reg_to_reg, [313], 0)
		322: Type	const_prim(I64)
		323: WritableReg	constructor(temp_writable_reg, [322], 1)
		324: OperandSize	constructor(operand_size, [74], 2)
		325: MInst	make_variant(MInst::AluRRR, [177, 324, 323, 73, 109])
		326: Unit	constructor(emit, [325], 3)
		327: Reg	constructor(writable_reg_to_reg, [323], 0)
		332: Type	const_prim(I64)
		333: WritableReg	constructor(temp_writable_reg, [332], 1)
		334: OperandSize	constructor(operand_size, [70], 2)
		335: MInst	make_variant(MInst::AluRRImmShift, [182, 334, 333, 69, 77])
		336: Unit	constructor(emit, [335], 3)
		337: Reg	constructor(writable_reg_to_reg, [333], 0)
		342: Type	const_prim(I64)
		343: WritableReg	constructor(temp_writable_reg, [342], 1)
		344: OperandSize	constructor(operand_size, [70], 2)
		345: MInst	make_variant(MInst::AluRRR, [187, 344, 343, 337, 327])
		346: Unit	constructor(emit, [345], 3)
		347: Reg	constructor(writable_reg_to_reg, [343], 0)
		352: Type	const_prim(I64)
		353: WritableReg	constructor(temp_writable_reg, [352], 1)
		354: OperandSize	constructor(operand_size, [70], 2)
		355: MInst	make_variant(MInst::AluRRR, [192, 354, 353, 307, 347])
		356: Unit	constructor(emit, [355], 3)
		357: Reg	constructor(writable_reg_to_reg, [353], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 32
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1565
		../../codegen/src/isa/aarch64/inst.isle line 2762
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I64)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		22: Option(InstOutput)	some(31)
		23: Option(Option(InstOutput))	some(22)
		27: ALUOp	make_variant(ALUOp::RotR, [])
		30: ValueRegs	constructor(value_reg, [41], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [13], 2)
		39: MInst	make_variant(MInst::AluRRImmShift, [27, 38, 37, 17, 19])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1560
		../../codegen/src/isa/aarch64/inst.isle line 2762
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Imm64)	extractor(iconst, 11)
		13: Type	const_prim(I32)
		14: Imm64	match_some(12)
		15: Option(ImmShift)	constructor(imm_shift_from_imm64, [13, 14], 0)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: ImmShift	match_some(15)
		19: ImmShift	constructor(negate_imm_shift, [13, 18], 2)
		22: Option(InstOutput)	some(31)
		23: Option(Option(InstOutput))	some(22)
		27: ALUOp	make_variant(ALUOp::RotR, [])
		30: ValueRegs	constructor(value_reg, [41], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [13], 2)
		39: MInst	make_variant(MInst::AluRRImmShift, [27, 38, 37, 17, 19])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
		10:	some
		12:	some
		15:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1554
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2759
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I64)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 5)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		25: ALUOp	make_variant(ALUOp::Sub, [])
		30: ALUOp	make_variant(ALUOp::RotR, [])
		33: ValueRegs	constructor(value_reg, [54], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [25, 41, 40, 13, 12])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [30, 51, 50, 17, 44])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1548
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2759
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(rotl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: Reg	constructor(zero_reg, [], 3)
		14: Type	const_prim(I32)
		16: Value	match_tuple(8, 0)
		17: Reg	constructor(put_in_reg, [16], 5)
		20: Option(InstOutput)	some(34)
		21: Option(Option(InstOutput))	some(20)
		25: ALUOp	make_variant(ALUOp::Sub, [])
		30: ALUOp	make_variant(ALUOp::RotR, [])
		33: ValueRegs	constructor(value_reg, [54], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [14], 2)
		42: MInst	make_variant(MInst::AluRRR, [25, 41, 40, 13, 12])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRR, [30, 51, 50, 17, 44])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		7:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1535
		../../codegen/src/isa/aarch64/lower.isle line 1648
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(ImmShift)	constructor(imm_shift_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		18: Reg	constructor(put_in_reg_zext32, [17], 1)
		19: ImmShift	match_some(16)
		20: ImmShift	constructor(negate_imm_shift, [14, 19], 2)
		23: Option(InstOutput)	some(35)
		24: Option(Option(InstOutput))	some(23)
		28: Type	const_prim(I32)
		30: ImmShift	constructor(rotr_opposite_amount, [14, 20], 2)
		34: ValueRegs	constructor(value_reg, [80], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: ALUOp	make_variant(ALUOp::Lsr, [])
		44: ALUOp	make_variant(ALUOp::Lsl, [])
		49: ALUOp	make_variant(ALUOp::Orr, [])
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [28], 2)
		58: MInst	make_variant(MInst::AluRRImmShift, [39, 57, 56, 18, 20])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [28], 2)
		68: MInst	make_variant(MInst::AluRRImmShift, [44, 67, 66, 18, 30])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: OperandSize	constructor(operand_size, [28], 2)
		78: MInst	make_variant(MInst::AluRRR, [49, 77, 76, 70, 60])
		79: Unit	constructor(emit, [78], 3)
		80: Reg	constructor(writable_reg_to_reg, [76], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1529
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/lower.isle line 1627
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1996
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_16, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(rotl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I32)
		17: Value	match_tuple(9, 0)
		18: Reg	constructor(put_in_reg_zext32, [17], 5)
		19: Type	match_some(6)
		22: Option(InstOutput)	some(45)
		23: Option(Option(InstOutput))	some(22)
		27: ALUOp	make_variant(ALUOp::Sub, [])
		32: ImmLogic	constructor(rotr_mask, [19], 1)
		33: Type	const_prim(I32)
		35: u8	constructor(ty_bits, [19], 0)
		36: Imm12	constructor(u8_into_imm12, [35], 3)
		38: Reg	constructor(zero_reg, [], 5)
		44: ValueRegs	constructor(value_reg, [145], 1)
		45: InstOutput	constructor(output, [44], 2)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [15], 2)
		53: MInst	make_variant(MInst::AluRRR, [27, 52, 51, 14, 13])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
		59: ALUOp	make_variant(ALUOp::And, [])
		64: ALUOp	make_variant(ALUOp::Sub, [])
		69: ALUOp	make_variant(ALUOp::Sub, [])
		74: ALUOp	make_variant(ALUOp::Lsr, [])
		79: ALUOp	make_variant(ALUOp::Lsl, [])
		84: ALUOp	make_variant(ALUOp::Orr, [])
		90: Type	const_prim(I64)
		91: WritableReg	constructor(temp_writable_reg, [90], 1)
		92: OperandSize	constructor(operand_size, [33], 2)
		93: MInst	make_variant(MInst::AluRRImmLogic, [59, 92, 91, 55, 32])
		94: Unit	constructor(emit, [93], 3)
		95: Reg	constructor(writable_reg_to_reg, [91], 0)
		100: Type	const_prim(I64)
		101: WritableReg	constructor(temp_writable_reg, [100], 1)
		102: OperandSize	constructor(operand_size, [33], 2)
		103: MInst	make_variant(MInst::AluRRImm12, [64, 102, 101, 95, 36])
		104: Unit	constructor(emit, [103], 3)
		105: Reg	constructor(writable_reg_to_reg, [101], 0)
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: OperandSize	constructor(operand_size, [33], 2)
		113: MInst	make_variant(MInst::AluRRR, [69, 112, 111, 38, 105])
		114: Unit	constructor(emit, [113], 3)
		115: Reg	constructor(writable_reg_to_reg, [111], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: OperandSize	constructor(operand_size, [33], 2)
		123: MInst	make_variant(MInst::AluRRR, [74, 122, 121, 18, 95])
		124: Unit	constructor(emit, [123], 3)
		125: Reg	constructor(writable_reg_to_reg, [121], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: OperandSize	constructor(operand_size, [33], 2)
		133: MInst	make_variant(MInst::AluRRR, [79, 132, 131, 18, 115])
		134: Unit	constructor(emit, [133], 3)
		135: Reg	constructor(writable_reg_to_reg, [131], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: OperandSize	constructor(operand_size, [33], 2)
		143: MInst	make_variant(MInst::AluRRR, [84, 142, 141, 135, 125])
		144: Unit	constructor(emit, [143], 3)
		145: Reg	constructor(writable_reg_to_reg, [141], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1493
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(put_in_regs, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1491
		../../codegen/src/isa/aarch64/inst.isle line 2754
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Imm64	match_some(13)
		19: u64	extractor(u64_from_imm64, 18)
		20: u8	constructor(shift_masked_imm, [16, 19], 0)
		23: Option(InstOutput)	some(32)
		24: Option(Option(InstOutput))	some(23)
		28: VecShiftImmOp	make_variant(VecShiftImmOp::Sshr, [])
		31: ValueRegs	constructor(value_reg, [41], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecShiftImm, [28, 38, 15, 17, 20])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1486
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 2738
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: Type	match_some(6)
		10: VectorSize	constructor(vector_size, [9], 1)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ImmLogic	constructor(shift_mask, [9], 3)
		15: Type	const_prim(I32)
		17: Reg	constructor(zero_reg, [], 5)
		18: Type	const_prim(I64)
		21: Value	match_tuple(11, 0)
		22: Reg	constructor(put_in_reg, [21], 8)
		25: Option(InstOutput)	some(51)
		26: Option(Option(InstOutput))	some(25)
		30: ALUOp	make_variant(ALUOp::And, [])
		35: ALUOp	make_variant(ALUOp::Sub, [])
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecDup, [40, 71, 10])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		47: VecALUOp	make_variant(VecALUOp::Sshl, [])
		50: ValueRegs	constructor(value_reg, [80], 1)
		51: InstOutput	constructor(output, [50], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [15], 2)
		59: MInst	make_variant(MInst::AluRRImmLogic, [30, 58, 57, 13, 14])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [18], 2)
		69: MInst	make_variant(MInst::AluRRR, [35, 68, 67, 17, 61])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		76: Type	const_prim(I8X16)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: MInst	make_variant(MInst::VecRRR, [47, 77, 22, 43, 10])
		79: Unit	constructor(emit, [78], 2)
		80: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1477
		../../codegen/src/isa/aarch64/lower.isle line 1508
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2657
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [46], 5)
		17: Option(InstOutput)	some(16)
		18: Option(Option(InstOutput))	some(17)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [10, 21], 1)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Type	const_prim(I64)
		28: Reg	constructor(zero_reg, [], 5)
		29: Type	const_prim(I32)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		35: u8	const_int(63, u8)
		36: ImmShift	constructor(imm_shift_from_u8, [35], 10)
		39: u64	const_int(64, u64)
		40: ImmLogic	constructor(u64_into_imm_logic, [25, 39], 13)
		42: Cond	make_variant(Cond::Ne, [])
		45: ConsumesFlags	constructor(consumes_flags_concat, [97, 105], 17)
		46: ValueRegs	constructor(with_flags, [89, 45], 18)
		50: ALUOp	make_variant(ALUOp::Lsr, [])
		55: ALUOp	make_variant(ALUOp::Asr, [])
		60: ALUOp	make_variant(ALUOp::OrrNot, [])
		65: ALUOp	make_variant(ALUOp::Lsl, [])
		70: ALUOp	make_variant(ALUOp::Lsl, [])
		75: ALUOp	make_variant(ALUOp::Asr, [])
		80: ALUOp	make_variant(ALUOp::Orr, [])
		85: OperandSize	constructor(operand_size, [25], 1)
		86: WritableReg	constructor(writable_zero_reg, [], 2)
		87: ALUOp	make_variant(ALUOp::AndS, [])
		88: MInst	make_variant(MInst::AluRRImmLogic, [87, 85, 86, 14, 40])
		89: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [88])
		93: Type	const_prim(I64)
		94: WritableReg	constructor(temp_writable_reg, [93], 1)
		95: MInst	make_variant(MInst::CSel, [94, 42, 125, 175])
		96: Reg	constructor(writable_reg_to_reg, [94], 0)
		97: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [95, 96])
		101: Type	const_prim(I64)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: MInst	make_variant(MInst::CSel, [102, 42, 165, 125])
		104: Reg	constructor(writable_reg_to_reg, [102], 0)
		105: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [103, 104])
		110: Type	const_prim(I64)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: OperandSize	constructor(operand_size, [25], 2)
		113: MInst	make_variant(MInst::AluRRR, [50, 112, 111, 22, 14])
		114: Unit	constructor(emit, [113], 3)
		115: Reg	constructor(writable_reg_to_reg, [111], 0)
		120: Type	const_prim(I64)
		121: WritableReg	constructor(temp_writable_reg, [120], 1)
		122: OperandSize	constructor(operand_size, [25], 2)
		123: MInst	make_variant(MInst::AluRRR, [55, 122, 121, 24, 14])
		124: Unit	constructor(emit, [123], 3)
		125: Reg	constructor(writable_reg_to_reg, [121], 0)
		130: Type	const_prim(I64)
		131: WritableReg	constructor(temp_writable_reg, [130], 1)
		132: OperandSize	constructor(operand_size, [29], 2)
		133: MInst	make_variant(MInst::AluRRR, [60, 132, 131, 28, 14])
		134: Unit	constructor(emit, [133], 3)
		135: Reg	constructor(writable_reg_to_reg, [131], 0)
		140: Type	const_prim(I64)
		141: WritableReg	constructor(temp_writable_reg, [140], 1)
		142: OperandSize	constructor(operand_size, [25], 2)
		143: MInst	make_variant(MInst::AluRRImmShift, [65, 142, 141, 24, 32])
		144: Unit	constructor(emit, [143], 3)
		145: Reg	constructor(writable_reg_to_reg, [141], 0)
		150: Type	const_prim(I64)
		151: WritableReg	constructor(temp_writable_reg, [150], 1)
		152: OperandSize	constructor(operand_size, [25], 2)
		153: MInst	make_variant(MInst::AluRRR, [70, 152, 151, 145, 135])
		154: Unit	constructor(emit, [153], 3)
		155: Reg	constructor(writable_reg_to_reg, [151], 0)
		160: Type	const_prim(I64)
		161: WritableReg	constructor(temp_writable_reg, [160], 1)
		162: OperandSize	constructor(operand_size, [25], 2)
		163: MInst	make_variant(MInst::AluRRImmShift, [75, 162, 161, 24, 36])
		164: Unit	constructor(emit, [163], 3)
		165: Reg	constructor(writable_reg_to_reg, [161], 0)
		170: Type	const_prim(I64)
		171: WritableReg	constructor(temp_writable_reg, [170], 1)
		172: OperandSize	constructor(operand_size, [25], 2)
		173: MInst	make_variant(MInst::AluRRR, [80, 172, 171, 115, 155])
		174: Unit	constructor(emit, [173], 3)
		175: Reg	constructor(writable_reg_to_reg, [171], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1473
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(sshr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg_sext64, [9], 1)
		11: ALUOp	make_variant(ALUOp::Asr, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 10, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sshr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_sext32, [10], 1)
		12: ALUOp	make_variant(ALUOp::Asr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 11, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1435
		../../codegen/src/prelude_lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: u64	extractor(u64_from_imm64, 15)
		17: u8	constructor(shift_masked_imm, [14, 16], 0)
		18: Value	match_tuple(9, 0)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(put_in_regs, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		17:	const_int(0)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1433
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Imm64	match_some(13)
		19: u64	extractor(u64_from_imm64, 18)
		20: u8	constructor(shift_masked_imm, [16, 19], 0)
		23: Option(InstOutput)	some(32)
		24: Option(Option(InstOutput))	some(23)
		28: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		31: ValueRegs	constructor(value_reg, [41], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecShiftImm, [28, 38, 15, 17, 20])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1428
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 2742
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: Type	match_some(6)
		10: VectorSize	constructor(vector_size, [9], 1)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ImmLogic	constructor(shift_mask, [9], 3)
		15: Type	const_prim(I32)
		17: Reg	constructor(zero_reg, [], 5)
		18: Type	const_prim(I64)
		21: Value	match_tuple(11, 0)
		22: Reg	constructor(put_in_reg, [21], 8)
		25: Option(InstOutput)	some(51)
		26: Option(Option(InstOutput))	some(25)
		30: ALUOp	make_variant(ALUOp::And, [])
		35: ALUOp	make_variant(ALUOp::Sub, [])
		39: Type	const_prim(I8X16)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::VecDup, [40, 71, 10])
		42: Unit	constructor(emit, [41], 2)
		43: Reg	constructor(writable_reg_to_reg, [40], 0)
		47: VecALUOp	make_variant(VecALUOp::Ushl, [])
		50: ValueRegs	constructor(value_reg, [80], 1)
		51: InstOutput	constructor(output, [50], 2)
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [15], 2)
		59: MInst	make_variant(MInst::AluRRImmLogic, [30, 58, 57, 13, 14])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
		66: Type	const_prim(I64)
		67: WritableReg	constructor(temp_writable_reg, [66], 1)
		68: OperandSize	constructor(operand_size, [18], 2)
		69: MInst	make_variant(MInst::AluRRR, [35, 68, 67, 17, 61])
		70: Unit	constructor(emit, [69], 3)
		71: Reg	constructor(writable_reg_to_reg, [67], 0)
		76: Type	const_prim(I8X16)
		77: WritableReg	constructor(temp_writable_reg, [76], 1)
		78: MInst	make_variant(MInst::VecRRR, [47, 77, 22, 43, 10])
		79: Unit	constructor(emit, [78], 2)
		80: Reg	constructor(writable_reg_to_reg, [77], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1420
		../../codegen/src/isa/aarch64/lower.isle line 1449
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2674
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [44], 5)
		17: Option(InstOutput)	some(16)
		18: Option(Option(InstOutput))	some(17)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [10, 21], 1)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Type	const_prim(I64)
		28: Reg	constructor(zero_reg, [], 5)
		29: Type	const_prim(I32)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		36: u64	const_int(64, u64)
		37: ImmLogic	constructor(u64_into_imm_logic, [25, 36], 11)
		39: Cond	make_variant(Cond::Ne, [])
		41: Reg	constructor(zero_reg, [], 14)
		43: ConsumesFlags	constructor(consumes_flags_concat, [90, 98], 16)
		44: ValueRegs	constructor(with_flags, [82, 43], 17)
		48: ALUOp	make_variant(ALUOp::Lsr, [])
		53: ALUOp	make_variant(ALUOp::Lsr, [])
		58: ALUOp	make_variant(ALUOp::OrrNot, [])
		63: ALUOp	make_variant(ALUOp::Lsl, [])
		68: ALUOp	make_variant(ALUOp::Lsl, [])
		73: ALUOp	make_variant(ALUOp::Orr, [])
		78: OperandSize	constructor(operand_size, [25], 1)
		79: WritableReg	constructor(writable_zero_reg, [], 2)
		80: ALUOp	make_variant(ALUOp::AndS, [])
		81: MInst	make_variant(MInst::AluRRImmLogic, [80, 78, 79, 14, 37])
		82: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [81])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::CSel, [87, 39, 118, 158])
		89: Reg	constructor(writable_reg_to_reg, [87], 0)
		90: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [88, 89])
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: MInst	make_variant(MInst::CSel, [95, 39, 41, 118])
		97: Reg	constructor(writable_reg_to_reg, [95], 0)
		98: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [96, 97])
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: OperandSize	constructor(operand_size, [25], 2)
		106: MInst	make_variant(MInst::AluRRR, [48, 105, 104, 22, 14])
		107: Unit	constructor(emit, [106], 3)
		108: Reg	constructor(writable_reg_to_reg, [104], 0)
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: OperandSize	constructor(operand_size, [25], 2)
		116: MInst	make_variant(MInst::AluRRR, [53, 115, 114, 24, 14])
		117: Unit	constructor(emit, [116], 3)
		118: Reg	constructor(writable_reg_to_reg, [114], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: OperandSize	constructor(operand_size, [29], 2)
		126: MInst	make_variant(MInst::AluRRR, [58, 125, 124, 28, 14])
		127: Unit	constructor(emit, [126], 3)
		128: Reg	constructor(writable_reg_to_reg, [124], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: OperandSize	constructor(operand_size, [25], 2)
		136: MInst	make_variant(MInst::AluRRImmShift, [63, 135, 134, 24, 32])
		137: Unit	constructor(emit, [136], 3)
		138: Reg	constructor(writable_reg_to_reg, [134], 0)
		143: Type	const_prim(I64)
		144: WritableReg	constructor(temp_writable_reg, [143], 1)
		145: OperandSize	constructor(operand_size, [25], 2)
		146: MInst	make_variant(MInst::AluRRR, [68, 145, 144, 138, 128])
		147: Unit	constructor(emit, [146], 3)
		148: Reg	constructor(writable_reg_to_reg, [144], 0)
		153: Type	const_prim(I64)
		154: WritableReg	constructor(temp_writable_reg, [153], 1)
		155: OperandSize	constructor(operand_size, [25], 2)
		156: MInst	make_variant(MInst::AluRRR, [73, 155, 154, 108, 148])
		157: Unit	constructor(emit, [156], 3)
		158: Reg	constructor(writable_reg_to_reg, [154], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1416
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ushr, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg_zext64, [9], 1)
		11: ALUOp	make_variant(ALUOp::Lsr, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 10, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1412
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ushr, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_zext32, [10], 1)
		12: ALUOp	make_variant(ALUOp::Lsr, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 11, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1364
		../../codegen/src/isa/aarch64/inst.isle line 2746
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	match_some(6)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Imm64	match_some(13)
		19: u64	extractor(u64_from_imm64, 18)
		20: u8	constructor(shift_masked_imm, [16, 19], 0)
		23: Option(InstOutput)	some(32)
		24: Option(Option(InstOutput))	some(23)
		28: VecShiftImmOp	make_variant(VecShiftImmOp::Shl, [])
		31: ValueRegs	constructor(value_reg, [41], 1)
		32: InstOutput	constructor(output, [31], 2)
		37: Type	const_prim(I8X16)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::VecShiftImm, [28, 38, 15, 17, 20])
		40: Unit	constructor(emit, [39], 2)
		41: Reg	constructor(writable_reg_to_reg, [38], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1359
		../../codegen/src/isa/aarch64/inst.isle line 2716
		../../codegen/src/isa/aarch64/inst.isle line 1975
		../../codegen/src/isa/aarch64/inst.isle line 2738
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: Type	match_some(6)
		10: VectorSize	constructor(vector_size, [9], 1)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ImmLogic	constructor(shift_mask, [9], 3)
		15: Type	const_prim(I32)
		18: Value	match_tuple(11, 0)
		19: Reg	constructor(put_in_reg, [18], 6)
		22: Option(InstOutput)	some(43)
		23: Option(Option(InstOutput))	some(22)
		27: ALUOp	make_variant(ALUOp::And, [])
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecDup, [32, 53, 10])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
		39: VecALUOp	make_variant(VecALUOp::Sshl, [])
		42: ValueRegs	constructor(value_reg, [62], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [15], 2)
		51: MInst	make_variant(MInst::AluRRImmLogic, [27, 50, 49, 13, 14])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
		58: Type	const_prim(I8X16)
		59: WritableReg	constructor(temp_writable_reg, [58], 1)
		60: MInst	make_variant(MInst::VecRRR, [39, 59, 19, 35, 10])
		61: Unit	constructor(emit, [60], 2)
		62: Reg	constructor(writable_reg_to_reg, [59], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1329
		../../codegen/src/isa/aarch64/lower.isle line 1342
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2671
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2664
		../../codegen/src/isa/aarch64/inst.isle line 2699
		../../codegen/src/isa/aarch64/inst.isle line 2355
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 2369
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 3)
		16: InstOutput	constructor(output, [44], 5)
		17: Option(InstOutput)	some(16)
		18: Option(Option(InstOutput))	some(17)
		21: usize	const_int(0, usize)
		22: Reg	constructor(value_regs_get, [10, 21], 1)
		23: usize	const_int(1, usize)
		24: Reg	constructor(value_regs_get, [10, 23], 2)
		25: Type	const_prim(I64)
		28: Reg	constructor(zero_reg, [], 5)
		29: Type	const_prim(I32)
		31: u8	const_int(1, u8)
		32: ImmShift	constructor(imm_shift_from_u8, [31], 7)
		36: u64	const_int(64, u64)
		37: ImmLogic	constructor(u64_into_imm_logic, [25, 36], 11)
		39: Reg	constructor(zero_reg, [], 13)
		40: Cond	make_variant(Cond::Ne, [])
		43: ConsumesFlags	constructor(consumes_flags_concat, [90, 98], 16)
		44: ValueRegs	constructor(with_flags, [82, 43], 17)
		48: ALUOp	make_variant(ALUOp::Lsl, [])
		53: ALUOp	make_variant(ALUOp::Lsl, [])
		58: ALUOp	make_variant(ALUOp::OrrNot, [])
		63: ALUOp	make_variant(ALUOp::Lsr, [])
		68: ALUOp	make_variant(ALUOp::Lsr, [])
		73: ALUOp	make_variant(ALUOp::Orr, [])
		78: OperandSize	constructor(operand_size, [25], 1)
		79: WritableReg	constructor(writable_zero_reg, [], 2)
		80: ALUOp	make_variant(ALUOp::AndS, [])
		81: MInst	make_variant(MInst::AluRRImmLogic, [80, 78, 79, 14, 37])
		82: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [81])
		86: Type	const_prim(I64)
		87: WritableReg	constructor(temp_writable_reg, [86], 1)
		88: MInst	make_variant(MInst::CSel, [87, 40, 39, 108])
		89: Reg	constructor(writable_reg_to_reg, [87], 0)
		90: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [88, 89])
		94: Type	const_prim(I64)
		95: WritableReg	constructor(temp_writable_reg, [94], 1)
		96: MInst	make_variant(MInst::CSel, [95, 40, 108, 158])
		97: Reg	constructor(writable_reg_to_reg, [95], 0)
		98: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [96, 97])
		103: Type	const_prim(I64)
		104: WritableReg	constructor(temp_writable_reg, [103], 1)
		105: OperandSize	constructor(operand_size, [25], 2)
		106: MInst	make_variant(MInst::AluRRR, [48, 105, 104, 22, 14])
		107: Unit	constructor(emit, [106], 3)
		108: Reg	constructor(writable_reg_to_reg, [104], 0)
		113: Type	const_prim(I64)
		114: WritableReg	constructor(temp_writable_reg, [113], 1)
		115: OperandSize	constructor(operand_size, [25], 2)
		116: MInst	make_variant(MInst::AluRRR, [53, 115, 114, 24, 14])
		117: Unit	constructor(emit, [116], 3)
		118: Reg	constructor(writable_reg_to_reg, [114], 0)
		123: Type	const_prim(I64)
		124: WritableReg	constructor(temp_writable_reg, [123], 1)
		125: OperandSize	constructor(operand_size, [29], 2)
		126: MInst	make_variant(MInst::AluRRR, [58, 125, 124, 28, 14])
		127: Unit	constructor(emit, [126], 3)
		128: Reg	constructor(writable_reg_to_reg, [124], 0)
		133: Type	const_prim(I64)
		134: WritableReg	constructor(temp_writable_reg, [133], 1)
		135: OperandSize	constructor(operand_size, [25], 2)
		136: MInst	make_variant(MInst::AluRRImmShift, [63, 135, 134, 22, 32])
		137: Unit	constructor(emit, [136], 3)
		138: Reg	constructor(writable_reg_to_reg, [134], 0)
		143: Type	const_prim(I64)
		144: WritableReg	constructor(temp_writable_reg, [143], 1)
		145: OperandSize	constructor(operand_size, [25], 2)
		146: MInst	make_variant(MInst::AluRRR, [68, 145, 144, 138, 128])
		147: Unit	constructor(emit, [146], 3)
		148: Reg	constructor(writable_reg_to_reg, [144], 0)
		153: Type	const_prim(I64)
		154: WritableReg	constructor(temp_writable_reg, [153], 1)
		155: OperandSize	constructor(operand_size, [25], 2)
		156: MInst	make_variant(MInst::AluRRR, [73, 155, 154, 118, 148])
		157: Unit	constructor(emit, [156], 3)
		158: Reg	constructor(writable_reg_to_reg, [154], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1325
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(ishl, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ALUOp	make_variant(ALUOp::Lsl, [])
		12: Type	const_prim(I64)
		13: Value	match_tuple(8, 1)
		14: Reg	constructor(do_shift, [11, 12, 10, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1321
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ishl, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: ALUOp	make_variant(ALUOp::Lsl, [])
		13: Type	match_some(6)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(do_shift, [12, 13, 11, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1316
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRR, [13, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [13, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1315
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRR, [13, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [13, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1312
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		18: Reg	constructor(alu_rs_imm_logic, [14, 15, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1310
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		18: Reg	constructor(alu_rs_imm_logic, [14, 15, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1303
		../../codegen/src/isa/aarch64/inst.isle line 2726
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Eor, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1301
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bxor, 6)
		8: ALUOp	make_variant(ALUOp::Eor, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [31], 2)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
		21: ValueRegs	constructor(put_in_regs, [11], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [12], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		31: ValueRegs	constructor(value_regs, [41, 51], 9)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [9], 2)
		39: MInst	make_variant(MInst::AluRRR, [8, 38, 37, 23, 27])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [9], 2)
		49: MInst	make_variant(MInst::AluRRR, [8, 48, 47, 25, 28])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1298
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bxor, 7)
		9: ALUOp	make_variant(ALUOp::Eor, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1294
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRR, [13, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [13, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1293
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::OrrNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRR, [13, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [13, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		18: Reg	constructor(alu_rs_imm_logic, [14, 15, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::OrrNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		18: Reg	constructor(alu_rs_imm_logic, [14, 15, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1281
		../../codegen/src/isa/aarch64/inst.isle line 2708
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Orr, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1279
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(bor, 6)
		8: ALUOp	make_variant(ALUOp::Orr, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [31], 2)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
		21: ValueRegs	constructor(put_in_regs, [11], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [12], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		31: ValueRegs	constructor(value_regs, [41, 51], 9)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [9], 2)
		39: MInst	make_variant(MInst::AluRRR, [8, 38, 37, 23, 27])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [9], 2)
		49: MInst	make_variant(MInst::AluRRR, [8, 48, 47, 25, 28])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1276
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(bor, 7)
		9: ALUOp	make_variant(ALUOp::Orr, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1271
		../../codegen/src/isa/aarch64/inst.isle line 2734
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		22: Option(InstOutput)	some(31)
		23: Option(Option(InstOutput))	some(22)
		27: VecALUOp	make_variant(VecALUOp::Bic, [])
		30: ValueRegs	constructor(value_reg, [40], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRR, [27, 37, 15, 17, 19])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1269
		../../codegen/src/isa/aarch64/inst.isle line 2734
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_some(13)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(6)
		19: VectorSize	constructor(vector_size, [18], 3)
		22: Option(InstOutput)	some(31)
		23: Option(Option(InstOutput))	some(22)
		27: VecALUOp	make_variant(VecALUOp::Bic, [])
		30: ValueRegs	constructor(value_reg, [40], 1)
		31: InstOutput	constructor(output, [30], 2)
		36: Type	const_prim(I8X16)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::VecRRR, [27, 37, 15, 17, 19])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1267
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 1)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRR, [13, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [13, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(bnot, 11)
		13: ALUOp	make_variant(ALUOp::AndNot, [])
		14: Type	const_prim(I64)
		15: Value	match_tuple(8, 0)
		16: Value	match_some(12)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRR, [13, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [14], 2)
		53: MInst	make_variant(MInst::AluRRR, [13, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		10:	some
		12:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1263
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 1)
		17: Value	match_some(13)
		18: Reg	constructor(alu_rs_imm_logic, [14, 15, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1261
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Value)	extractor(bnot, 12)
		14: ALUOp	make_variant(ALUOp::AndNot, [])
		15: Type	match_some(6)
		16: Value	match_tuple(9, 0)
		17: Value	match_some(13)
		18: Reg	constructor(alu_rs_imm_logic, [14, 15, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1254
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::And, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1252
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(band, 6)
		8: ALUOp	make_variant(ALUOp::And, [])
		9: Type	const_prim(I64)
		10: (Value, Value)	match_some(7)
		11: Value	match_tuple(10, 0)
		12: Value	match_tuple(10, 1)
		14: InstOutput	constructor(output, [31], 2)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
		21: ValueRegs	constructor(put_in_regs, [11], 1)
		22: usize	const_int(0, usize)
		23: Reg	constructor(value_regs_get, [21, 22], 2)
		24: usize	const_int(1, usize)
		25: Reg	constructor(value_regs_get, [21, 24], 3)
		26: ValueRegs	constructor(put_in_regs, [12], 4)
		27: Reg	constructor(value_regs_get, [26, 22], 5)
		28: Reg	constructor(value_regs_get, [26, 24], 6)
		31: ValueRegs	constructor(value_regs, [41, 51], 9)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [9], 2)
		39: MInst	make_variant(MInst::AluRRR, [8, 38, 37, 23, 27])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [9], 2)
		49: MInst	make_variant(MInst::AluRRR, [8, 48, 47, 25, 28])
		50: Unit	constructor(emit, [49], 3)
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1249
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(band, 7)
		9: ALUOp	make_variant(ALUOp::And, [])
		10: Type	match_some(6)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 12, 13], 1)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1245
		../../codegen/src/isa/aarch64/inst.isle line 3079
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Value))	extractor(bxor, 10)
		12: ALUOp	make_variant(ALUOp::EorNot, [])
		13: Type	const_prim(I64)
		14: (Value, Value)	match_some(11)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		18: InstOutput	constructor(output, [35], 2)
		19: Option(InstOutput)	some(18)
		20: Option(Option(InstOutput))	some(19)
		25: ValueRegs	constructor(put_in_regs, [15], 1)
		26: usize	const_int(0, usize)
		27: Reg	constructor(value_regs_get, [25, 26], 2)
		28: usize	const_int(1, usize)
		29: Reg	constructor(value_regs_get, [25, 28], 3)
		30: ValueRegs	constructor(put_in_regs, [16], 4)
		31: Reg	constructor(value_regs_get, [30, 26], 5)
		32: Reg	constructor(value_regs_get, [30, 28], 6)
		35: ValueRegs	constructor(value_regs, [45, 55], 9)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [13], 2)
		43: MInst	make_variant(MInst::AluRRR, [12, 42, 41, 27, 31])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
		50: Type	const_prim(I64)
		51: WritableReg	constructor(temp_writable_reg, [50], 1)
		52: OperandSize	constructor(operand_size, [13], 2)
		53: MInst	make_variant(MInst::AluRRR, [12, 52, 51, 29, 32])
		54: Unit	constructor(emit, [53], 3)
		55: Reg	constructor(writable_reg_to_reg, [51], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1243
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(bxor, 11)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	match_some(6)
		15: (Value, Value)	match_some(12)
		16: Value	match_tuple(15, 0)
		17: Value	match_tuple(15, 1)
		18: Reg	constructor(alu_rs_imm_logic, [13, 14, 16, 17], 1)
		20: Option(InstOutput)	some(24)
		21: Option(Option(InstOutput))	some(20)
		23: ValueRegs	constructor(value_reg, [18], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
		../../codegen/src/isa/aarch64/inst.isle line 2686
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(23)
		16: Option(Option(InstOutput))	some(15)
		19: VecMisc2	make_variant(VecMisc2::Not, [])
		22: ValueRegs	constructor(value_reg, [31], 1)
		23: InstOutput	constructor(output, [22], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecMisc, [19, 28, 10, 12])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1230
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(bnot, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: usize	const_int(1, usize)
		13: Reg	constructor(value_regs_get, [9, 12], 3)
		14: Reg	constructor(zero_reg, [], 4)
		15: Type	const_prim(I64)
		17: Reg	constructor(zero_reg, [], 6)
		19: ValueRegs	constructor(value_regs, [42, 52], 8)
		20: InstOutput	constructor(output, [19], 9)
		21: Option(InstOutput)	some(20)
		22: Option(Option(InstOutput))	some(21)
		26: ALUOp	make_variant(ALUOp::OrrNot, [])
		31: ALUOp	make_variant(ALUOp::OrrNot, [])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: OperandSize	constructor(operand_size, [15], 2)
		40: MInst	make_variant(MInst::AluRRR, [26, 39, 38, 14, 11])
		41: Unit	constructor(emit, [40], 3)
		42: Reg	constructor(writable_reg_to_reg, [38], 0)
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: OperandSize	constructor(operand_size, [15], 2)
		50: MInst	make_variant(MInst::AluRRR, [31, 49, 48, 17, 13])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1224
		../../codegen/src/isa/aarch64/inst.isle line 2694
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Value))	extractor(ishl, 11)
		13: (Value, Value)	match_some(12)
		14: Value	match_tuple(13, 1)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: Option(Imm64)	extractor(iconst, 16)
		18: Type	match_some(6)
		19: Imm64	match_some(17)
		20: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [18, 19], 0)
		21: Reg	constructor(zero_reg, [], 1)
		22: Value	match_tuple(13, 0)
		23: Reg	constructor(put_in_reg, [22], 2)
		24: ShiftOpAndAmt	match_some(20)
		27: Option(InstOutput)	some(37)
		28: Option(Option(InstOutput))	some(27)
		33: ALUOp	make_variant(ALUOp::OrrNot, [])
		36: ValueRegs	constructor(value_reg, [48], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [18], 2)
		46: MInst	make_variant(MInst::AluRRRShift, [33, 45, 44, 21, 23, 24])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		17:	some
		20:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 2691
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(bnot, 7)
		9: Reg	constructor(zero_reg, [], 1)
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_some(6)
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: ALUOp	make_variant(ALUOp::OrrNot, [])
		23: ValueRegs	constructor(value_reg, [34], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [12], 2)
		32: MInst	make_variant(MInst::AluRRR, [20, 31, 30, 9, 11])
		33: Unit	constructor(emit, [32], 3)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Type, Inst))	extractor(has_type, 11)
		13: (Type, Inst)	match_some(12)
		14: Inst	match_tuple(13, 1)
		15: Option((MemFlags, Value, Offset32))	extractor(load, 14)
		16: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		17: Inst	match_some(16)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(13, 0)
		20: (MemFlags, Value, Offset32)	match_some(15)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		24: AMode	constructor(amode, [19, 21, 23], 2)
		25: MemFlags	match_tuple(20, 0)
		26: Reg	constructor(aarch64_sload, [19, 24, 25], 3)
		28: Option(InstOutput)	some(32)
		29: Option(Option(InstOutput))	some(28)
		31: ValueRegs	constructor(value_reg, [26], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		15:	some
		16:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1192
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Reg	constructor(put_in_reg, [13], 1)
		16: Uimm8	match_tuple(12, 1)
		17: u8	extractor(u8_from_uimm8, 16)
		18: ScalarSize	make_variant(ScalarSize::Size64, [])
		20: u8	const_int(63, u8)
		21: ImmShift	constructor(imm_shift_from_u8, [20], 3)
		22: Type	const_prim(I64)
		24: ValueRegs	constructor(value_regs, [35, 50], 5)
		25: InstOutput	constructor(output, [24], 6)
		26: Option(InstOutput)	some(25)
		27: Option(Option(InstOutput))	some(26)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::MovFromVec, [32, 15, 17, 18])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
		39: ALUOp	make_variant(ALUOp::Asr, [])
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [22], 2)
		48: MInst	make_variant(MInst::AluRRImmShift, [39, 47, 46, 35, 21])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		14:	const_prim(I64X2)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1181
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: VectorSize	constructor(vector_size, [14], 2)
		18: Type	const_prim(I64)
		19: OperandSize	constructor(size_from_ty, [18], 3)
		20: Uimm8	match_tuple(12, 1)
		21: u8	extractor(u8_from_uimm8, 20)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		26: ValueRegs	constructor(value_regs, [38, 53], 7)
		27: InstOutput	constructor(output, [26], 8)
		28: Option(InstOutput)	some(27)
		29: Option(Option(InstOutput))	some(28)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: MInst	make_variant(MInst::MovFromVecSigned, [35, 16, 21, 17, 19])
		37: Unit	constructor(emit, [36], 2)
		38: Reg	constructor(writable_reg_to_reg, [35], 0)
		42: ALUOp	make_variant(ALUOp::Asr, [])
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [18], 2)
		51: MInst	make_variant(MInst::AluRRImmShift, [42, 50, 49, 38, 24])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
		15:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1171
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(sextend, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg_sext64, [8], 1)
		10: u8	const_int(63, u8)
		11: ImmShift	constructor(imm_shift_from_u8, [10], 2)
		12: Type	const_prim(I64)
		14: ValueRegs	constructor(value_regs, [9, 32], 4)
		15: InstOutput	constructor(output, [14], 5)
		16: Option(InstOutput)	some(15)
		17: Option(Option(InstOutput))	some(16)
		21: ALUOp	make_variant(ALUOp::Asr, [])
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: OperandSize	constructor(operand_size, [12], 2)
		30: MInst	make_variant(MInst::AluRRImmShift, [21, 29, 28, 9, 11])
		31: Unit	constructor(emit, [30], 3)
		32: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1162
		../../codegen/src/isa/aarch64/inst.isle line 2299
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	extractor(value_type, 14)
		17: VectorSize	constructor(vector_size, [16], 2)
		18: Type	match_some(6)
		19: OperandSize	constructor(size_from_ty, [18], 3)
		20: Uimm8	match_tuple(13, 1)
		21: u8	extractor(u8_from_uimm8, 20)
		24: Option(InstOutput)	some(37)
		25: Option(Option(InstOutput))	some(24)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::MovFromVecSigned, [31, 15, 21, 17, 19])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
		36: ValueRegs	constructor(value_reg, [34], 1)
		37: InstOutput	constructor(output, [36], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1157
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(true)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::Extend, [25, 10, 11, 13, 15])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1143
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		12: Inst	match_some(10)
		13: Option((Type, Inst))	extractor(has_type, 12)
		14: (Type, Inst)	match_some(13)
		15: Inst	match_tuple(14, 1)
		16: Option((MemFlags, Value, Offset32))	extractor(load, 15)
		17: Inst	match_some(11)
		18: Unit	constructor(sink_inst, [17], 1)
		19: Type	match_tuple(14, 0)
		20: (MemFlags, Value, Offset32)	match_some(16)
		21: Value	match_tuple(20, 1)
		22: Offset32	match_tuple(20, 2)
		23: i32	constructor(offset32_to_i32, [22], 0)
		24: AMode	constructor(amode, [19, 21, 23], 2)
		25: MemFlags	match_tuple(20, 0)
		26: Reg	constructor(aarch64_uload, [19, 24, 25], 3)
		28: Option(InstOutput)	some(32)
		29: Option(Option(InstOutput))	some(28)
		31: ValueRegs	constructor(value_reg, [26], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		11:	some
		13:	some
		16:	some
	]
	result = 29
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1137
		../../codegen/src/isa/aarch64/inst.isle line 2292
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: Option((Value, Uimm8))	extractor(extractlane, 10)
		12: (Value, Uimm8)	match_some(11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	extractor(value_type, 13)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Uimm8	match_tuple(12, 1)
		18: u8	extractor(u8_from_uimm8, 17)
		20: Type	const_prim(I64)
		21: ImmExtend	make_variant(ImmExtend::Zero, [])
		22: u64	const_int(0, u64)
		23: Reg	constructor(imm, [20, 21, 22], 4)
		24: ValueRegs	constructor(value_regs, [35, 23], 5)
		25: InstOutput	constructor(output, [24], 6)
		26: Option(InstOutput)	some(25)
		27: Option(Option(InstOutput))	some(26)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::MovFromVec, [32, 14, 18, 16])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
		9:	some
		11:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(uextend, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg_zext64, [8], 1)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [9, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
		16: Option(InstOutput)	some(15)
		17: Option(Option(InstOutput))	some(16)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1125
		../../codegen/src/isa/aarch64/inst.isle line 3033
		../../codegen/src/isa/aarch64/inst.isle line 2340
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((MemFlags, Value))	extractor(atomic_load, 11)
		13: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		14: Inst	match_some(13)
		16: Type	extractor(value_type, 9)
		17: (MemFlags, Value)	match_some(12)
		18: MemFlags	match_tuple(17, 0)
		21: Option(InstOutput)	some(39)
		22: Option(Option(InstOutput))	some(21)
		24: Option((MemFlags, Value))	extractor(atomic_load, 14)
		25: Unit	constructor(sink_inst, [14], 1)
		26: (MemFlags, Value)	match_some(24)
		27: Value	match_tuple(26, 1)
		28: Reg	constructor(put_in_reg, [27], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::LoadAcquire, [16, 33, 28, 18])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: ValueRegs	constructor(value_reg, [36], 1)
		39: InstOutput	constructor(output, [38], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
		13:	some
		24:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1118
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option((Value, Uimm8))	extractor(extractlane, 11)
		13: (Value, Uimm8)	match_some(12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Type	extractor(value_type, 14)
		17: ScalarSize	constructor(lane_size, [16], 2)
		18: Uimm8	match_tuple(13, 1)
		19: u8	extractor(u8_from_uimm8, 18)
		22: Option(InstOutput)	some(34)
		23: Option(Option(InstOutput))	some(22)
		27: Type	const_prim(I64)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::MovFromVec, [28, 15, 19, 17])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		33: ValueRegs	constructor(value_reg, [31], 1)
		34: InstOutput	constructor(output, [33], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
		12:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1113
		../../codegen/src/isa/aarch64/inst.isle line 2312
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(uextend, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(false)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(6)
		15: u8	constructor(ty_bits, [14], 0)
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I64)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::Extend, [25, 10, 11, 13, 15])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1106
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umax, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [9], 4)
		17: Reg	constructor(put_in_reg, [11], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(41)
		22: Option(Option(InstOutput))	some(21)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecRRR, [13, 28, 10, 12, 14])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		36: VectorSize	constructor(vector_size, [18], 1)
		37: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecRRRMod, [37, 48, 31, 16, 17, 36])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1103
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Umax, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1100
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smax, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [9], 4)
		17: Reg	constructor(put_in_reg, [11], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(41)
		22: Option(Option(InstOutput))	some(21)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecRRR, [13, 28, 10, 12, 14])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		36: VectorSize	constructor(vector_size, [18], 1)
		37: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecRRRMod, [37, 48, 31, 16, 17, 36])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1097
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smax, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Smax, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1094
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umin, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 0)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [11], 4)
		17: Reg	constructor(put_in_reg, [9], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(41)
		22: Option(Option(InstOutput))	some(21)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecRRR, [13, 28, 10, 12, 14])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		36: VectorSize	constructor(vector_size, [18], 1)
		37: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecRRRMod, [37, 48, 31, 16, 17, 36])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1091
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(umin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Umin, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1088
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2803
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smin, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 1)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 0)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		16: Reg	constructor(put_in_reg, [11], 4)
		17: Reg	constructor(put_in_reg, [9], 5)
		18: Type	const_prim(I64X2)
		21: Option(InstOutput)	some(41)
		22: Option(Option(InstOutput))	some(21)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecRRR, [13, 28, 10, 12, 14])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
		36: VectorSize	constructor(vector_size, [18], 1)
		37: VecALUModOp	make_variant(VecALUModOp::Bsl, [])
		40: ValueRegs	constructor(value_reg, [51], 1)
		41: InstOutput	constructor(output, [40], 2)
		47: Type	const_prim(I8X16)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		49: MInst	make_variant(MInst::VecRRRMod, [37, 48, 31, 16, 17, 36])
		50: Unit	constructor(emit, [49], 2)
		51: Reg	constructor(writable_reg_to_reg, [48], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1085
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(smin, 5)
		7: Type	match_tuple(4, 0)
		8: Option(())	extractor(not_i64x2, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		15: VecALUOp	make_variant(VecALUOp::Smin, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 14, 15], 1)
		17: InstOutput	constructor(output, [16], 2)
		18: Option(InstOutput)	some(17)
		19: Option(Option(InstOutput))	some(18)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umax, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 14, 15], 1)
		17: InstOutput	constructor(output, [16], 2)
		18: Option(InstOutput)	some(17)
		19: Option(Option(InstOutput))	some(18)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(smin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 14, 15], 1)
		17: InstOutput	constructor(output, [16], 2)
		18: Option(InstOutput)	some(17)
		19: Option(Option(InstOutput))	some(18)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Option(Type)	extractor(ty_int, 5)
		8: Inst	match_tuple(4, 1)
		9: Option((Value, Value))	extractor(umin, 8)
		10: Type	match_some(6)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: (Value, Value)	match_some(9)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 14, 15], 1)
		17: InstOutput	constructor(output, [16], 2)
		18: Option(InstOutput)	some(17)
		19: Option(Option(InstOutput))	some(18)
	]
	constraints = [
		3:	some
		6:	some
		7:	some
		9:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/isa/aarch64/inst.isle line 2485
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(srem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_sext64, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_nonzero_in_reg_sext64, [12], 2)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(33)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::SDiv, [])
		29: ALUOp3	make_variant(ALUOp3::MSub, [])
		32: ValueRegs	constructor(value_reg, [54], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [14], 2)
		41: MInst	make_variant(MInst::AluRRR, [23, 40, 39, 11, 13])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRRR, [29, 51, 50, 43, 13, 11])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/isa/aarch64/inst.isle line 2485
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(urem, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_zext64, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_nonzero_in_reg_zext64, [12], 2)
		14: Type	const_prim(I64)
		18: Option(InstOutput)	some(33)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::UDiv, [])
		29: ALUOp3	make_variant(ALUOp3::MSub, [])
		32: ValueRegs	constructor(value_reg, [54], 1)
		33: InstOutput	constructor(output, [32], 2)
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: OperandSize	constructor(operand_size, [14], 2)
		41: MInst	make_variant(MInst::AluRRR, [23, 40, 39, 11, 13])
		42: Unit	constructor(emit, [41], 3)
		43: Reg	constructor(writable_reg_to_reg, [39], 0)
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: OperandSize	constructor(operand_size, [14], 2)
		52: MInst	make_variant(MInst::AluRRRR, [29, 51, 50, 43, 13, 11])
		53: Unit	constructor(emit, [52], 3)
		54: Reg	constructor(writable_reg_to_reg, [50], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option(Imm64)	extractor(iconst, 12)
		14: Type	match_some(6)
		15: Imm64	match_some(13)
		16: Option(u64)	constructor(safe_divisor_from_imm64, [14, 15], 0)
		17: Value	match_tuple(9, 0)
		18: Reg	constructor(put_in_reg_sext64, [17], 1)
		19: ImmExtend	make_variant(ImmExtend::Sign, [])
		20: u64	match_some(16)
		21: Reg	constructor(imm, [14, 19, 20], 2)
		22: Type	const_prim(I64)
		25: Option(InstOutput)	some(34)
		26: Option(Option(InstOutput))	some(25)
		30: ALUOp	make_variant(ALUOp::SDiv, [])
		33: ValueRegs	constructor(value_reg, [44], 1)
		34: InstOutput	constructor(output, [33], 2)
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [22], 2)
		42: MInst	make_variant(MInst::AluRRR, [30, 41, 40, 18, 21])
		43: Unit	constructor(emit, [42], 3)
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
	]
	result = 26
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
		../../codegen/src/isa/aarch64/inst.isle line 3007
		../../codegen/src/isa/aarch64/inst.isle line 2682
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_sext64, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_nonzero_in_reg_sext64, [12], 2)
		14: Type	match_some(6)
		16: Type	const_prim(I64)
		19: Option(InstOutput)	some(50)
		20: Option(Option(InstOutput))	some(19)
		24: OperandSize	constructor(operand_size, [14], 1)
		25: WritableReg	constructor(writable_zero_reg, [], 2)
		26: u8	const_int(1, u8)
		27: Imm12	constructor(u8_into_imm12, [26], 3)
		28: ALUOp	make_variant(ALUOp::AddS, [])
		29: MInst	make_variant(MInst::AluRRImm12, [28, 24, 25, 13, 27])
		30: Unit	constructor(emit, [29], 4)
		31: OperandSize	constructor(size_from_ty, [14], 5)
		32: UImm5	constructor(u8_into_uimm5, [26], 6)
		33: bool	const_prim(false)
		34: NZCV	constructor(nzcv, [33, 33, 33, 33], 7)
		35: Cond	make_variant(Cond::Eq, [])
		36: MInst	make_variant(MInst::CCmpImm, [31, 11, 32, 34, 35])
		37: Unit	constructor(emit, [36], 8)
		38: Cond	make_variant(Cond::Vs, [])
		39: CondBrKind	constructor(cond_br_cond, [38], 9)
		40: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		41: MInst	make_variant(MInst::TrapIf, [39, 40])
		42: Unit	constructor(emit, [41], 10)
		46: ALUOp	make_variant(ALUOp::SDiv, [])
		49: ValueRegs	constructor(value_reg, [60], 1)
		50: InstOutput	constructor(output, [49], 2)
		55: Type	const_prim(I64)
		56: WritableReg	constructor(temp_writable_reg, [55], 1)
		57: OperandSize	constructor(operand_size, [16], 2)
		58: MInst	make_variant(MInst::AluRRR, [46, 57, 56, 11, 13])
		59: Unit	constructor(emit, [58], 3)
		60: Reg	constructor(writable_reg_to_reg, [56], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
		../../codegen/src/isa/aarch64/inst.isle line 2678
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(udiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_zext64, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_nonzero_in_reg_zext64, [12], 2)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: ALUOp	make_variant(ALUOp::UDiv, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [14], 2)
		34: MInst	make_variant(MInst::AluRRR, [22, 33, 32, 11, 13])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2667
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(umulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_zext64, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg_zext64, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		21: ValueRegs	constructor(value_reg, [56], 7)
		22: InstOutput	constructor(output, [21], 8)
		23: Option(InstOutput)	some(22)
		24: Option(Option(InstOutput))	some(23)
		29: ALUOp3	make_variant(ALUOp3::MAdd, [])
		34: ALUOp	make_variant(ALUOp::Lsr, [])
		41: Type	const_prim(I64)
		42: WritableReg	constructor(temp_writable_reg, [41], 1)
		43: OperandSize	constructor(operand_size, [15], 2)
		44: MInst	make_variant(MInst::AluRRRR, [29, 43, 42, 11, 13, 14])
		45: Unit	constructor(emit, [44], 3)
		46: Reg	constructor(writable_reg_to_reg, [42], 0)
		51: Type	const_prim(I64)
		52: WritableReg	constructor(temp_writable_reg, [51], 1)
		53: OperandSize	constructor(operand_size, [15], 2)
		54: MInst	make_variant(MInst::AluRRImmShift, [34, 53, 52, 46, 19])
		55: Unit	constructor(emit, [54], 3)
		56: Reg	constructor(writable_reg_to_reg, [52], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 949
		../../codegen/src/isa/aarch64/inst.isle line 2513
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(umulhi, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Type	const_prim(I64)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: ALUOp	make_variant(ALUOp::UMulH, [])
		24: ValueRegs	constructor(value_reg, [35], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: OperandSize	constructor(operand_size, [13], 2)
		33: MInst	make_variant(MInst::AluRRR, [21, 32, 31, 10, 12])
		34: Unit	constructor(emit, [33], 3)
		35: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(smulhi, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg_sext64, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg_sext64, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	const_prim(I64)
		17: Type	match_some(6)
		18: u8	constructor(ty_bits, [17], 0)
		19: ImmShift	constructor(imm_shift_from_u8, [18], 5)
		22: Option(InstOutput)	some(37)
		23: Option(Option(InstOutput))	some(22)
		28: ALUOp3	make_variant(ALUOp3::MAdd, [])
		33: ALUOp	make_variant(ALUOp::Asr, [])
		36: ValueRegs	constructor(value_reg, [58], 1)
		37: InstOutput	constructor(output, [36], 2)
		43: Type	const_prim(I64)
		44: WritableReg	constructor(temp_writable_reg, [43], 1)
		45: OperandSize	constructor(operand_size, [15], 2)
		46: MInst	make_variant(MInst::AluRRRR, [28, 45, 44, 11, 13, 14])
		47: Unit	constructor(emit, [46], 3)
		48: Reg	constructor(writable_reg_to_reg, [44], 0)
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: OperandSize	constructor(operand_size, [15], 2)
		56: MInst	make_variant(MInst::AluRRImmShift, [33, 55, 54, 48, 19])
		57: Unit	constructor(emit, [56], 3)
		58: Reg	constructor(writable_reg_to_reg, [54], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 937
		../../codegen/src/isa/aarch64/inst.isle line 2517
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(smulhi, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Type	const_prim(I64)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: ALUOp	make_variant(ALUOp::SMulH, [])
		24: ValueRegs	constructor(value_reg, [35], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: OperandSize	constructor(operand_size, [13], 2)
		33: MInst	make_variant(MInst::AluRRR, [21, 32, 31, 10, 12])
		34: Unit	constructor(emit, [33], 3)
		35: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 930
		../../codegen/src/isa/aarch64/inst.isle line 2653
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 924
		../../codegen/src/isa/aarch64/inst.isle line 2653
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Umull32, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 918
		../../codegen/src/isa/aarch64/inst.isle line 2649
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I32X4)
		18:	some
		20:	const_prim(I32X4)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 912
		../../codegen/src/isa/aarch64/inst.isle line 2649
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Smull32, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I32X4)
		16:	some
		18:	some
		20:	const_prim(I32X4)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 906
		../../codegen/src/isa/aarch64/inst.isle line 2645
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 900
		../../codegen/src/isa/aarch64/inst.isle line 2645
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Umull16, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 894
		../../codegen/src/isa/aarch64/inst.isle line 2641
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I16X8)
		18:	some
		20:	const_prim(I16X8)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 888
		../../codegen/src/isa/aarch64/inst.isle line 2641
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Smull16, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I16X8)
		16:	some
		18:	some
		20:	const_prim(I16X8)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 882
		../../codegen/src/isa/aarch64/inst.isle line 2637
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 876
		../../codegen/src/isa/aarch64/inst.isle line 2637
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(uwiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Umull8, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 870
		../../codegen/src/isa/aarch64/inst.isle line 2633
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(swiden_high, 13)
		15: Value	match_some(14)
		16: Type	extractor(value_type, 15)
		17: Inst	match_some(12)
		18: Option(Value)	extractor(swiden_high, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [15], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(true)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	const_prim(I8X16)
		18:	some
		20:	const_prim(I8X16)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 864
		../../codegen/src/isa/aarch64/inst.isle line 2633
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2180
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_some(12)
		14: Type	extractor(value_type, 13)
		15: Value	match_tuple(8, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Value)	extractor(swiden_low, 17)
		19: Value	match_some(18)
		20: Type	extractor(value_type, 19)
		21: Reg	constructor(put_in_reg, [13], 1)
		22: Reg	constructor(put_in_reg, [19], 2)
		23: bool	const_prim(false)
		26: Option(InstOutput)	some(35)
		27: Option(Option(InstOutput))	some(26)
		31: VecRRRLongOp	make_variant(VecRRRLongOp::Smull8, [])
		34: ValueRegs	constructor(value_reg, [44], 1)
		35: InstOutput	constructor(output, [34], 2)
		40: Type	const_prim(I8X16)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: MInst	make_variant(MInst::VecRRRLong, [31, 41, 21, 22, 23])
		43: Unit	constructor(emit, [42], 2)
		44: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	const_prim(I8X16)
		16:	some
		18:	some
		20:	const_prim(I8X16)
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 825
		../../codegen/src/isa/aarch64/inst.isle line 2537
		../../codegen/src/isa/aarch64/inst.isle line 2521
		../../codegen/src/isa/aarch64/inst.isle line 2541
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/isa/aarch64/inst.isle line 2541
		../../codegen/src/isa/aarch64/inst.isle line 2611
		../../codegen/src/isa/aarch64/inst.isle line 2629
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 2201
		../../codegen/src/isa/aarch64/inst.isle line 2216
		../../codegen/src/isa/aarch64/inst.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: VectorSize	make_variant(VectorSize::Size32x4, [])
		16: ScalarSize	make_variant(ScalarSize::Size32, [])
		20: bool	const_prim(false)
		24: Option(InstOutput)	some(60)
		25: Option(Option(InstOutput))	some(24)
		28: VecMisc2	make_variant(VecMisc2::Rev64, [])
		33: VecALUOp	make_variant(VecALUOp::Mul, [])
		37: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		42: VecALUOp	make_variant(VecALUOp::Addp, [])
		46: VecRRNarrowOp	make_variant(VecRRNarrowOp::Xtn, [])
		50: VecRRLongOp	make_variant(VecRRLongOp::Shll32, [])
		56: VecRRRLongModOp	make_variant(VecRRRLongModOp::Umlal32, [])
		59: ValueRegs	constructor(value_reg, [120], 1)
		60: InstOutput	constructor(output, [59], 2)
		64: Type	const_prim(I8X16)
		65: WritableReg	constructor(temp_writable_reg, [64], 1)
		66: MInst	make_variant(MInst::VecMisc, [28, 65, 12, 13])
		67: Unit	constructor(emit, [66], 2)
		68: Reg	constructor(writable_reg_to_reg, [65], 0)
		73: Type	const_prim(I8X16)
		74: WritableReg	constructor(temp_writable_reg, [73], 1)
		75: MInst	make_variant(MInst::VecRRR, [33, 74, 68, 10, 13])
		76: Unit	constructor(emit, [75], 2)
		77: Reg	constructor(writable_reg_to_reg, [74], 0)
		81: Type	const_prim(I8X16)
		82: WritableReg	constructor(temp_writable_reg, [81], 1)
		83: MInst	make_variant(MInst::VecRRNarrowLow, [37, 82, 10, 16])
		84: Unit	constructor(emit, [83], 2)
		85: Reg	constructor(writable_reg_to_reg, [82], 0)
		90: Type	const_prim(I8X16)
		91: WritableReg	constructor(temp_writable_reg, [90], 1)
		92: MInst	make_variant(MInst::VecRRR, [42, 91, 77, 77, 13])
		93: Unit	constructor(emit, [92], 2)
		94: Reg	constructor(writable_reg_to_reg, [91], 0)
		98: Type	const_prim(I8X16)
		99: WritableReg	constructor(temp_writable_reg, [98], 1)
		100: MInst	make_variant(MInst::VecRRNarrowLow, [46, 99, 12, 16])
		101: Unit	constructor(emit, [100], 2)
		102: Reg	constructor(writable_reg_to_reg, [99], 0)
		106: Type	const_prim(I8X16)
		107: WritableReg	constructor(temp_writable_reg, [106], 1)
		108: MInst	make_variant(MInst::VecRRLong, [50, 107, 94, 20])
		109: Unit	constructor(emit, [108], 2)
		110: Reg	constructor(writable_reg_to_reg, [107], 0)
		116: Type	const_prim(I8X16)
		117: WritableReg	constructor(temp_writable_reg, [116], 1)
		118: MInst	make_variant(MInst::VecRRRLongMod, [56, 117, 110, 102, 85, 20])
		119: Unit	constructor(emit, [118], 2)
		120: Reg	constructor(writable_reg_to_reg, [117], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 793
		../../codegen/src/isa/aarch64/inst.isle line 2521
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: Type	match_some(6)
		10: Option(())	extractor(not_i64x2, 9)
		11: (Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [9], 3)
		19: Option(InstOutput)	some(28)
		20: Option(Option(InstOutput))	some(19)
		24: VecALUOp	make_variant(VecALUOp::Mul, [])
		27: ValueRegs	constructor(value_reg, [37], 1)
		28: InstOutput	constructor(output, [27], 2)
		33: Type	const_prim(I8X16)
		34: WritableReg	constructor(temp_writable_reg, [33], 1)
		35: MInst	make_variant(MInst::VecRRR, [24, 34, 13, 15, 16])
		36: Unit	constructor(emit, [35], 2)
		37: Reg	constructor(writable_reg_to_reg, [34], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 765
		../../codegen/src/isa/aarch64/inst.isle line 2513
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2043
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(imul, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Value	match_tuple(8, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 4)
		17: Reg	constructor(value_regs_get, [16, 11], 5)
		18: Reg	constructor(value_regs_get, [16, 13], 6)
		19: Type	const_prim(I64)
		23: Reg	constructor(zero_reg, [], 10)
		25: ValueRegs	constructor(value_regs, [94, 83], 12)
		26: InstOutput	constructor(output, [25], 13)
		27: Option(InstOutput)	some(26)
		28: Option(Option(InstOutput))	some(27)
		32: ALUOp	make_variant(ALUOp::UMulH, [])
		38: ALUOp3	make_variant(ALUOp3::MAdd, [])
		44: ALUOp3	make_variant(ALUOp3::MAdd, [])
		50: ALUOp3	make_variant(ALUOp3::MAdd, [])
		56: Type	const_prim(I64)
		57: WritableReg	constructor(temp_writable_reg, [56], 1)
		58: OperandSize	constructor(operand_size, [19], 2)
		59: MInst	make_variant(MInst::AluRRR, [32, 58, 57, 12, 17])
		60: Unit	constructor(emit, [59], 3)
		61: Reg	constructor(writable_reg_to_reg, [57], 0)
		67: Type	const_prim(I64)
		68: WritableReg	constructor(temp_writable_reg, [67], 1)
		69: OperandSize	constructor(operand_size, [19], 2)
		70: MInst	make_variant(MInst::AluRRRR, [38, 69, 68, 12, 18, 61])
		71: Unit	constructor(emit, [70], 3)
		72: Reg	constructor(writable_reg_to_reg, [68], 0)
		78: Type	const_prim(I64)
		79: WritableReg	constructor(temp_writable_reg, [78], 1)
		80: OperandSize	constructor(operand_size, [19], 2)
		81: MInst	make_variant(MInst::AluRRRR, [44, 80, 79, 14, 17, 72])
		82: Unit	constructor(emit, [81], 3)
		83: Reg	constructor(writable_reg_to_reg, [79], 0)
		89: Type	const_prim(I64)
		90: WritableReg	constructor(temp_writable_reg, [89], 1)
		91: OperandSize	constructor(operand_size, [19], 2)
		92: MInst	make_variant(MInst::AluRRRR, [50, 91, 90, 12, 17, 23])
		93: Unit	constructor(emit, [92], 3)
		94: Reg	constructor(writable_reg_to_reg, [90], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 761
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(imul, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(28)
		19: Option(Option(InstOutput))	some(18)
		24: ALUOp3	make_variant(ALUOp3::MAdd, [])
		27: ValueRegs	constructor(value_reg, [39], 1)
		28: InstOutput	constructor(output, [27], 2)
		34: Type	const_prim(I64)
		35: WritableReg	constructor(temp_writable_reg, [34], 1)
		36: OperandSize	constructor(operand_size, [15], 2)
		37: MInst	make_variant(MInst::AluRRRR, [24, 36, 35, 11, 13, 14])
		38: Unit	constructor(emit, [37], 3)
		39: Reg	constructor(writable_reg_to_reg, [35], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 755
		../../codegen/src/isa/aarch64/inst.isle line 2525
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: VectorSize	constructor(vector_size, [11], 2)
		15: Option(InstOutput)	some(23)
		16: Option(Option(InstOutput))	some(15)
		19: VecMisc2	make_variant(VecMisc2::Neg, [])
		22: ValueRegs	constructor(value_reg, [31], 1)
		23: InstOutput	constructor(output, [22], 2)
		27: Type	const_prim(I8X16)
		28: WritableReg	constructor(temp_writable_reg, [27], 1)
		29: MInst	make_variant(MInst::VecMisc, [19, 28, 10, 12])
		30: Unit	constructor(emit, [29], 2)
		31: Reg	constructor(writable_reg_to_reg, [28], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
		../../codegen/src/isa/aarch64/inst.isle line 1849
		../../codegen/src/isa/aarch64/inst.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 2089
		../../codegen/src/isa/aarch64/inst.isle line 2134
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ineg, 6)
		9: Value	match_some(7)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		12: InstOutput	constructor(output, [32], 4)
		13: Option(InstOutput)	some(12)
		14: Option(Option(InstOutput))	some(13)
		15: Type	const_prim(I64)
		16: ImmExtend	make_variant(ImmExtend::Zero, [])
		17: u64	const_int(0, u64)
		18: Reg	constructor(imm, [15, 16, 17], 1)
		19: Reg	constructor(imm, [15, 16, 17], 2)
		20: ValueRegs	constructor(value_regs, [18, 19], 3)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [20, 23], 1)
		25: usize	const_int(1, usize)
		26: Reg	constructor(value_regs_get, [20, 25], 2)
		27: Reg	constructor(value_regs_get, [10, 23], 3)
		28: Reg	constructor(value_regs_get, [10, 25], 4)
		29: Type	const_prim(I64)
		32: ValueRegs	constructor(with_flags, [42, 52], 7)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: OperandSize	constructor(operand_size, [29], 2)
		39: ALUOp	make_variant(ALUOp::SubS, [])
		40: MInst	make_variant(MInst::AluRRR, [39, 38, 37, 24, 27])
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		42: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [40, 41])
		46: Type	const_prim(I64)
		47: WritableReg	constructor(temp_writable_reg, [46], 1)
		48: OperandSize	constructor(operand_size, [29], 2)
		49: ALUOp	make_variant(ALUOp::Sbc, [])
		50: MInst	make_variant(MInst::AluRRR, [49, 48, 47, 26, 28])
		51: Reg	constructor(writable_reg_to_reg, [47], 0)
		52: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [50, 51])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 747
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ineg, 7)
		9: Reg	constructor(zero_reg, [], 1)
		10: Value	match_some(8)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_some(6)
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: ALUOp	make_variant(ALUOp::Sub, [])
		23: ValueRegs	constructor(value_reg, [34], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [12], 2)
		32: MInst	make_variant(MInst::AluRRR, [20, 31, 30, 9, 11])
		33: Unit	constructor(emit, [32], 3)
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 741
		../../codegen/src/isa/aarch64/inst.isle line 2509
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(ssub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Sqsub, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 736
		../../codegen/src/isa/aarch64/inst.isle line 2505
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(usub_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Uqsub, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 731
		../../codegen/src/isa/aarch64/inst.isle line 2501
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Sqadd, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 726
		../../codegen/src/isa/aarch64/inst.isle line 2497
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_vec128, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(uadd_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: VectorSize	constructor(vector_size, [14], 3)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: VecALUOp	make_variant(VecALUOp::Uqadd, [])
		26: ValueRegs	constructor(value_reg, [36], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRR, [23, 33, 11, 13, 15])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
		../../codegen/src/isa/aarch64/inst.isle line 2460
		../../codegen/src/isa/aarch64/inst.isle line 2089
		../../codegen/src/isa/aarch64/inst.isle line 2134
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(isub, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: Value	match_tuple(8, 1)
		12: ValueRegs	constructor(put_in_regs, [11], 2)
		14: InstOutput	constructor(output, [28], 4)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
		19: usize	const_int(0, usize)
		20: Reg	constructor(value_regs_get, [10, 19], 1)
		21: usize	const_int(1, usize)
		22: Reg	constructor(value_regs_get, [10, 21], 2)
		23: Reg	constructor(value_regs_get, [12, 19], 3)
		24: Reg	constructor(value_regs_get, [12, 21], 4)
		25: Type	const_prim(I64)
		28: ValueRegs	constructor(with_flags, [38, 48], 7)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [25], 2)
		35: ALUOp	make_variant(ALUOp::SubS, [])
		36: MInst	make_variant(MInst::AluRRR, [35, 34, 33, 20, 23])
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
		38: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [36, 37])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: OperandSize	constructor(operand_size, [25], 2)
		45: ALUOp	make_variant(ALUOp::Sbc, [])
		46: MInst	make_variant(MInst::AluRRR, [45, 44, 43, 22, 24])
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		48: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [46, 47])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 717
		../../codegen/src/isa/aarch64/inst.isle line 2457
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(isub, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: VecALUOp	make_variant(VecALUOp::Sub, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 14])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 711
		../../codegen/src/isa/aarch64/inst.isle line 2454
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(39)
		30: Option(Option(InstOutput))	some(29)
		35: ALUOp	make_variant(ALUOp::Sub, [])
		38: ValueRegs	constructor(value_reg, [50], 1)
		39: InstOutput	constructor(output, [38], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [19], 2)
		48: MInst	make_variant(MInst::AluRRRShift, [35, 47, 46, 23, 25, 26])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 30
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 706
		../../codegen/src/isa/aarch64/inst.isle line 2451
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2036
		../../codegen/src/isa/aarch64/inst.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::Sub, [])
		26: ValueRegs	constructor(value_reg, [45], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Reg	constructor(put_extended_in_reg, [15], 1)
		33: ExtendOp	constructor(get_extended_op, [15], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [23, 42, 41, 13, 32, 33])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 700
		../../codegen/src/isa/aarch64/inst.isle line 1803
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Option(Imm12)	match_some(35)
		18: Option(InstOutput)	some(43)
		19: Option(Option(InstOutput))	some(18)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Type, Inst))	extractor(has_type, 22)
		24: (Type, Inst)	match_some(23)
		25: Inst	match_tuple(24, 1)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Type	match_tuple(24, 0)
		28: Imm64	match_some(26)
		29: i64	constructor(i64_sextend_imm64, [27, 28], 0)
		30: i64	constructor(i64_neg, [29], 0)
		31: u64	constructor(i64_as_u64, [30], 0)
		32: Option(Imm12)	extractor(imm12_from_u64, 31)
		33: Imm12	match_some(32)
		34: Option(Imm12)	some(33)
		35: Option(Option(Imm12))	some(34)
		39: ALUOp	make_variant(ALUOp::Add, [])
		42: ValueRegs	constructor(value_reg, [53], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [14], 2)
		51: MInst	make_variant(MInst::AluRRImm12, [39, 50, 49, 13, 15])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		32:	some
		35:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 695
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::Sub, [])
		26: ValueRegs	constructor(value_reg, [37], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [14], 2)
		35: MInst	make_variant(MInst::AluRRImm12, [23, 34, 33, 13, 15])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 691
		../../codegen/src/isa/aarch64/inst.isle line 2445
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: ALUOp	make_variant(ALUOp::Sub, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [14], 2)
		34: MInst	make_variant(MInst::AluRRR, [22, 33, 32, 11, 13])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 683
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 677
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 674
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		13: bool	const_prim(true)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 671
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 668
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_sint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 663
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 660
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 657
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint_sat, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [11, 10, 12, 13], 2)
		16: Option(InstOutput)	some(20)
		17: Option(Option(InstOutput))	some(16)
		19: ValueRegs	constructor(value_reg, [14], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 654
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint_sat, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		13: bool	const_prim(false)
		14: Type	match_some(6)
		15: Reg	constructor(fpu_to_int_cvt_sat, [12, 11, 13, 14], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 651
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 648
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_to_uint_sat, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 643
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::I64ToF64, [])
		14: Option(InstOutput)	some(25)
		15: Option(Option(InstOutput))	some(14)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::IntToFpu, [11, 19, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 640
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::I64ToF32, [])
		14: Option(InstOutput)	some(25)
		15: Option(Option(InstOutput))	some(14)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::IntToFpu, [11, 19, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: Reg	constructor(put_in_reg_sext32, [8], 1)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		15: Option(InstOutput)	some(26)
		16: Option(Option(InstOutput))	some(15)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::IntToFpu, [12, 20, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: Reg	constructor(put_in_reg_sext32, [8], 1)
		12: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		15: Option(InstOutput)	some(26)
		16: Option(Option(InstOutput))	some(15)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::IntToFpu, [12, 20, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 631
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 628
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_sint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 623
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::U64ToF64, [])
		14: Option(InstOutput)	some(25)
		15: Option(Option(InstOutput))	some(14)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::IntToFpu, [11, 19, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		9:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 620
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: IntToFpuOp	make_variant(IntToFpuOp::U64ToF32, [])
		14: Option(InstOutput)	some(25)
		15: Option(Option(InstOutput))	some(14)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::IntToFpu, [11, 19, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		9:	const_prim(I64)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: Reg	constructor(put_in_reg_zext32, [8], 1)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		15: Option(InstOutput)	some(26)
		16: Option(Option(InstOutput))	some(15)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::IntToFpu, [12, 20, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
		10:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
		../../codegen/src/isa/aarch64/inst.isle line 3680
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_from_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: Reg	constructor(put_in_reg_zext32, [8], 1)
		12: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		15: Option(InstOutput)	some(26)
		16: Option(Option(InstOutput))	some(15)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::IntToFpu, [12, 20, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
		10:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 611
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		10:	some
		13:	some
		15:	const_int(64)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 608
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: Inst	match_tuple(4, 1)
		10: Option(Value)	extractor(fcvt_from_uint, 9)
		11: Value	match_some(10)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [11], 1)
		17: VectorSize	constructor(vector_size, [5], 2)
		18: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		21: Option(InstOutput)	some(33)
		22: Option(Option(InstOutput))	some(21)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 16, 17])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
		32: ValueRegs	constructor(value_reg, [30], 1)
		33: InstOutput	constructor(output, [32], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		10:	some
		13:	some
		15:	const_int(32)
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 603
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(35)
		18: Option(Option(InstOutput))	some(17)
		24: ScalarSize	constructor(scalar_size, [13], 1)
		26: u8	constructor(ty_bits, [13], 0)
		27: u8	constructor(ty_bits, [14], 0)
		28: Reg	constructor(min_fp_value, [12, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [12, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 10])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [11, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 10, 10])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 600
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		13: bool	const_prim(true)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(36)
		19: Option(Option(InstOutput))	some(18)
		25: ScalarSize	constructor(scalar_size, [14], 1)
		27: u8	constructor(ty_bits, [14], 0)
		28: u8	constructor(ty_bits, [15], 0)
		29: Reg	constructor(min_fp_value, [13, 27, 28], 3)
		30: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 47, 29], 4)
		31: Reg	constructor(max_fp_value, [13, 27, 28], 5)
		35: ValueRegs	constructor(value_reg, [66], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Cond	make_variant(Cond::Vs, [])
		41: CondBrKind	constructor(cond_br_cond, [40], 2)
		42: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		43: MInst	make_variant(MInst::TrapIf, [41, 42])
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 11])
		45: ValueRegs	constructor(with_flags, [71, 44], 3)
		46: usize	const_int(0, usize)
		47: Reg	constructor(value_regs_get, [45, 46], 4)
		52: Cond	make_variant(Cond::Ge, [])
		53: CondBrKind	constructor(cond_br_cond, [52], 2)
		54: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		55: MInst	make_variant(MInst::TrapIf, [53, 54])
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 30])
		57: ValueRegs	constructor(with_flags, [76, 56], 3)
		58: usize	const_int(0, usize)
		59: Reg	constructor(value_regs_get, [57, 58], 4)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: MInst	make_variant(MInst::FpuToInt, [12, 63, 59])
		65: Unit	constructor(emit, [64], 2)
		66: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: MInst	make_variant(MInst::FpuCmp, [25, 11, 11])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
		75: MInst	make_variant(MInst::FpuCmp, [25, 30, 31])
		76: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [75])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 597
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_sint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		12: bool	const_prim(true)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(35)
		18: Option(Option(InstOutput))	some(17)
		24: ScalarSize	constructor(scalar_size, [13], 1)
		26: u8	constructor(ty_bits, [13], 0)
		27: u8	constructor(ty_bits, [14], 0)
		28: Reg	constructor(min_fp_value, [12, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [12, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 10])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [11, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 10, 10])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 594
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_sint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		13: bool	const_prim(true)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(36)
		19: Option(Option(InstOutput))	some(18)
		25: ScalarSize	constructor(scalar_size, [14], 1)
		27: u8	constructor(ty_bits, [14], 0)
		28: u8	constructor(ty_bits, [15], 0)
		29: Reg	constructor(min_fp_value, [13, 27, 28], 3)
		30: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 47, 29], 4)
		31: Reg	constructor(max_fp_value, [13, 27, 28], 5)
		35: ValueRegs	constructor(value_reg, [66], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Cond	make_variant(Cond::Vs, [])
		41: CondBrKind	constructor(cond_br_cond, [40], 2)
		42: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		43: MInst	make_variant(MInst::TrapIf, [41, 42])
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 11])
		45: ValueRegs	constructor(with_flags, [71, 44], 3)
		46: usize	const_int(0, usize)
		47: Reg	constructor(value_regs_get, [45, 46], 4)
		52: Cond	make_variant(Cond::Ge, [])
		53: CondBrKind	constructor(cond_br_cond, [52], 2)
		54: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		55: MInst	make_variant(MInst::TrapIf, [53, 54])
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 30])
		57: ValueRegs	constructor(with_flags, [76, 56], 3)
		58: usize	const_int(0, usize)
		59: Reg	constructor(value_regs_get, [57, 58], 4)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: MInst	make_variant(MInst::FpuToInt, [12, 63, 59])
		65: Unit	constructor(emit, [64], 2)
		66: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: MInst	make_variant(MInst::FpuCmp, [25, 11, 11])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
		75: MInst	make_variant(MInst::FpuCmp, [25, 30, 31])
		76: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [75])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 589
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(35)
		18: Option(Option(InstOutput))	some(17)
		24: ScalarSize	constructor(scalar_size, [13], 1)
		26: u8	constructor(ty_bits, [13], 0)
		27: u8	constructor(ty_bits, [14], 0)
		28: Reg	constructor(min_fp_value, [12, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [12, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 10])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [11, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 10, 10])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F64)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 586
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		13: bool	const_prim(false)
		14: Type	const_prim(F64)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(36)
		19: Option(Option(InstOutput))	some(18)
		25: ScalarSize	constructor(scalar_size, [14], 1)
		27: u8	constructor(ty_bits, [14], 0)
		28: u8	constructor(ty_bits, [15], 0)
		29: Reg	constructor(min_fp_value, [13, 27, 28], 3)
		30: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 47, 29], 4)
		31: Reg	constructor(max_fp_value, [13, 27, 28], 5)
		35: ValueRegs	constructor(value_reg, [66], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Cond	make_variant(Cond::Vs, [])
		41: CondBrKind	constructor(cond_br_cond, [40], 2)
		42: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		43: MInst	make_variant(MInst::TrapIf, [41, 42])
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 11])
		45: ValueRegs	constructor(with_flags, [71, 44], 3)
		46: usize	const_int(0, usize)
		47: Reg	constructor(value_regs_get, [45, 46], 4)
		52: Cond	make_variant(Cond::Ge, [])
		53: CondBrKind	constructor(cond_br_cond, [52], 2)
		54: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		55: MInst	make_variant(MInst::TrapIf, [53, 54])
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 30])
		57: ValueRegs	constructor(with_flags, [76, 56], 3)
		58: usize	const_int(0, usize)
		59: Reg	constructor(value_regs_get, [57, 58], 4)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: MInst	make_variant(MInst::FpuToInt, [12, 63, 59])
		65: Unit	constructor(emit, [64], 2)
		66: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: MInst	make_variant(MInst::FpuCmp, [25, 11, 11])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
		75: MInst	make_variant(MInst::FpuCmp, [25, 30, 31])
		76: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [75])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F64)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 583
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fcvt_to_uint, 6)
		8: Value	match_some(7)
		9: Type	extractor(value_type, 8)
		10: Reg	constructor(put_in_reg, [8], 1)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		12: bool	const_prim(false)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		17: Option(InstOutput)	some(35)
		18: Option(Option(InstOutput))	some(17)
		24: ScalarSize	constructor(scalar_size, [13], 1)
		26: u8	constructor(ty_bits, [13], 0)
		27: u8	constructor(ty_bits, [14], 0)
		28: Reg	constructor(min_fp_value, [12, 26, 27], 3)
		29: Reg	constructor(fpu_to_int_underflow_check, [12, 13, 14, 46, 28], 4)
		30: Reg	constructor(max_fp_value, [12, 26, 27], 5)
		34: ValueRegs	constructor(value_reg, [65], 1)
		35: InstOutput	constructor(output, [34], 2)
		39: Cond	make_variant(Cond::Vs, [])
		40: CondBrKind	constructor(cond_br_cond, [39], 2)
		41: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		42: MInst	make_variant(MInst::TrapIf, [40, 41])
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [42, 10])
		44: ValueRegs	constructor(with_flags, [70, 43], 3)
		45: usize	const_int(0, usize)
		46: Reg	constructor(value_regs_get, [44, 45], 4)
		51: Cond	make_variant(Cond::Ge, [])
		52: CondBrKind	constructor(cond_br_cond, [51], 2)
		53: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		54: MInst	make_variant(MInst::TrapIf, [52, 53])
		55: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [54, 29])
		56: ValueRegs	constructor(with_flags, [75, 55], 3)
		57: usize	const_int(0, usize)
		58: Reg	constructor(value_regs_get, [56, 57], 4)
		61: Type	const_prim(I64)
		62: WritableReg	constructor(temp_writable_reg, [61], 1)
		63: MInst	make_variant(MInst::FpuToInt, [11, 62, 58])
		64: Unit	constructor(emit, [63], 2)
		65: Reg	constructor(writable_reg_to_reg, [62], 0)
		69: MInst	make_variant(MInst::FpuCmp, [24, 10, 10])
		70: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [69])
		74: MInst	make_variant(MInst::FpuCmp, [24, 29, 30])
		75: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [74])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
		9:	const_prim(F32)
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 580
		../../codegen/src/isa/aarch64/inst.isle line 3624
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 3561
		../../codegen/src/isa/aarch64/inst.isle line 3608
		../../codegen/src/isa/aarch64/inst.isle line 3672
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 1955
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_32, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fcvt_to_uint, 7)
		9: Value	match_some(8)
		10: Type	extractor(value_type, 9)
		11: Reg	constructor(put_in_reg, [9], 1)
		12: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		13: bool	const_prim(false)
		14: Type	const_prim(F32)
		15: Type	match_some(6)
		18: Option(InstOutput)	some(36)
		19: Option(Option(InstOutput))	some(18)
		25: ScalarSize	constructor(scalar_size, [14], 1)
		27: u8	constructor(ty_bits, [14], 0)
		28: u8	constructor(ty_bits, [15], 0)
		29: Reg	constructor(min_fp_value, [13, 27, 28], 3)
		30: Reg	constructor(fpu_to_int_underflow_check, [13, 14, 15, 47, 29], 4)
		31: Reg	constructor(max_fp_value, [13, 27, 28], 5)
		35: ValueRegs	constructor(value_reg, [66], 1)
		36: InstOutput	constructor(output, [35], 2)
		40: Cond	make_variant(Cond::Vs, [])
		41: CondBrKind	constructor(cond_br_cond, [40], 2)
		42: TrapCode	constructor(trap_code_bad_conversion_to_integer, [], 0)
		43: MInst	make_variant(MInst::TrapIf, [41, 42])
		44: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [43, 11])
		45: ValueRegs	constructor(with_flags, [71, 44], 3)
		46: usize	const_int(0, usize)
		47: Reg	constructor(value_regs_get, [45, 46], 4)
		52: Cond	make_variant(Cond::Ge, [])
		53: CondBrKind	constructor(cond_br_cond, [52], 2)
		54: TrapCode	constructor(trap_code_integer_overflow, [], 0)
		55: MInst	make_variant(MInst::TrapIf, [53, 54])
		56: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [55, 30])
		57: ValueRegs	constructor(with_flags, [76, 56], 3)
		58: usize	const_int(0, usize)
		59: Reg	constructor(value_regs_get, [57, 58], 4)
		62: Type	const_prim(I64)
		63: WritableReg	constructor(temp_writable_reg, [62], 1)
		64: MInst	make_variant(MInst::FpuToInt, [12, 63, 59])
		65: Unit	constructor(emit, [64], 2)
		66: Reg	constructor(writable_reg_to_reg, [63], 0)
		70: MInst	make_variant(MInst::FpuCmp, [25, 11, 11])
		71: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [70])
		75: MInst	make_variant(MInst::FpuCmp, [25, 30, 31])
		76: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [75])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		10:	const_prim(F32)
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fcopysign, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		13: Reg	constructor(fcopy_sign, [9, 11, 12], 3)
		15: Option(InstOutput)	some(19)
		16: Option(Option(InstOutput))	some(15)
		18: ValueRegs	constructor(value_reg, [13], 1)
		19: InstOutput	constructor(output, [18], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 520
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: VectorSize	constructor(vector_size, [5], 1)
		10: VecALUModOp	make_variant(VecALUModOp::Fmla, [])
		11: (Value, Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Value	match_tuple(11, 2)
		15: Reg	constructor(lower_fmla, [10, 12, 13, 14, 9], 2)
		17: Option(InstOutput)	some(21)
		18: Option(Option(InstOutput))	some(17)
		20: ValueRegs	constructor(value_reg, [15], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 516
		../../codegen/src/isa/aarch64/inst.isle line 1948
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value, Value))	extractor(fma, 7)
		9: Type	match_some(6)
		10: ScalarSize	constructor(scalar_size, [9], 1)
		11: (Value, Value, Value)	match_some(8)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Value	match_tuple(11, 2)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: FPUOp3	make_variant(FPUOp3::MAdd, [])
		21: Option(InstOutput)	some(35)
		22: Option(Option(InstOutput))	some(21)
		28: Type	const_prim(F64)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::FpuRRRR, [18, 10, 29, 13, 15, 17])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		34: ValueRegs	constructor(value_reg, [32], 1)
		35: InstOutput	constructor(output, [34], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 22
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 511
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Nearest64, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 508
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(nearest, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Nearest32, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 505
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(nearest, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintn, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 500
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Zero64, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 497
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(trunc, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Zero32, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 494
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(trunc, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintz, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 489
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Minus64, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 486
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(floor, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Minus32, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 483
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(floor, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintm, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 478
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Plus64, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 475
		../../codegen/src/isa/aarch64/inst.isle line 2246
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(ceil, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FpuRoundMode	make_variant(FpuRoundMode::Plus32, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F64)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuRound, [10, 18, 9])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 472
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(ceil, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Frintp, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 467
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fdemote, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FPUOp1	make_variant(FPUOp1::Cvt64To32, [])
		11: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: Option(InstOutput)	some(26)
		15: Option(Option(InstOutput))	some(14)
		19: Type	const_prim(F64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::FpuRR, [10, 11, 20, 9])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 462
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(fpromote, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: FPUOp1	make_variant(FPUOp1::Cvt32To64, [])
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		14: Option(InstOutput)	some(26)
		15: Option(Option(InstOutput))	some(14)
		19: Type	const_prim(F64)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::FpuRR, [10, 11, 20, 9])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		7:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 457
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(scalar_size, [11], 2)
		13: FPUOp1	make_variant(FPUOp1::Abs, [])
		16: Option(InstOutput)	some(28)
		17: Option(Option(InstOutput))	some(16)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuRR, [13, 12, 22, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 454
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Fabs, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 449
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(scalar_size, [11], 2)
		13: FPUOp1	make_variant(FPUOp1::Neg, [])
		16: Option(InstOutput)	some(28)
		17: Option(Option(InstOutput))	some(16)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuRR, [13, 12, 22, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 446
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(fneg, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Fneg, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 441
		../../codegen/src/isa/aarch64/inst.isle line 1906
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(6)
		12: ScalarSize	constructor(scalar_size, [11], 2)
		13: FPUOp1	make_variant(FPUOp1::Sqrt, [])
		16: Option(InstOutput)	some(28)
		17: Option(Option(InstOutput))	some(16)
		21: Type	const_prim(F64)
		22: WritableReg	constructor(temp_writable_reg, [21], 1)
		23: MInst	make_variant(MInst::FpuRR, [13, 12, 22, 10])
		24: Unit	constructor(emit, [23], 2)
		25: Reg	constructor(writable_reg_to_reg, [22], 0)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 438
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(sqrt, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		12: VecMisc2	make_variant(VecMisc2::Fsqrt, [])
		15: Option(InstOutput)	some(27)
		16: Option(Option(InstOutput))	some(15)
		20: Type	const_prim(I8X16)
		21: WritableReg	constructor(temp_writable_reg, [20], 1)
		22: MInst	make_variant(MInst::VecMisc, [12, 21, 10, 11])
		23: Unit	constructor(emit, [22], 2)
		24: Reg	constructor(writable_reg_to_reg, [21], 0)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 433
		../../codegen/src/isa/aarch64/inst.isle line 1941
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Max, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuRRR, [16, 15, 26, 11, 13])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 430
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmax, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmax, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 425
		../../codegen/src/isa/aarch64/inst.isle line 1941
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Min, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuRRR, [16, 15, 26, 11, 13])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 422
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmin, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmin, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 417
		../../codegen/src/isa/aarch64/inst.isle line 1941
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Div, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuRRR, [16, 15, 26, 11, 13])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 414
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fdiv, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 409
		../../codegen/src/isa/aarch64/inst.isle line 1941
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Mul, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuRRR, [16, 15, 26, 11, 13])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 406
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fmul, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fmul, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 401
		../../codegen/src/isa/aarch64/inst.isle line 1941
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(ty_scalar_float, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Sub, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuRRR, [16, 15, 26, 11, 13])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 398
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fsub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fsub, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 393
		../../codegen/src/isa/aarch64/inst.isle line 1941
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(fadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(8)
		15: ScalarSize	constructor(scalar_size, [14], 3)
		16: FPUOp2	make_variant(FPUOp2::Add, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(F64)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::FpuRRR, [16, 15, 26, 11, 13])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 390
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(fadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Fadd, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 385
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(sqmul_round_sat, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [5], 3)
		15: VecALUOp	make_variant(VecALUOp::Sqrdmulh, [])
		18: Option(InstOutput)	some(31)
		19: Option(Option(InstOutput))	some(18)
		24: Type	const_prim(I8X16)
		25: WritableReg	constructor(temp_writable_reg, [24], 1)
		26: MInst	make_variant(MInst::VecRRR, [15, 25, 11, 13, 14])
		27: Unit	constructor(emit, [26], 2)
		28: Reg	constructor(writable_reg_to_reg, [25], 0)
		30: ValueRegs	constructor(value_reg, [28], 1)
		31: InstOutput	constructor(output, [30], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 380
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(avg_round, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(lane_fits_in_32, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(8)
		15: VectorSize	constructor(vector_size, [14], 3)
		16: VecALUOp	make_variant(VecALUOp::Urhadd, [])
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecRRR, [16, 26, 11, 13, 15])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 371
		../../codegen/src/isa/aarch64/inst.isle line 2708
		../../codegen/src/isa/aarch64/inst.isle line 2719
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 2750
		../../codegen/src/isa/aarch64/inst.isle line 2440
		../../codegen/src/isa/aarch64/inst.isle line 2440
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1968
		../../codegen/src/isa/aarch64/inst.isle line 1899
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(avg_round, 6)
		8: u64	const_int(1, u64)
		9: VectorSize	make_variant(VectorSize::Size64x2, [])
		10: Reg	constructor(splat_const, [8, 9], 1)
		11: (Value, Value)	match_some(7)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		18: Reg	constructor(put_in_reg, [12], 6)
		19: u8	const_int(1, u8)
		21: Reg	constructor(put_in_reg, [14], 8)
		26: Option(InstOutput)	some(60)
		27: Option(Option(InstOutput))	some(26)
		31: VecALUOp	make_variant(VecALUOp::Orr, [])
		36: VecALUOp	make_variant(VecALUOp::And, [])
		41: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		46: VecShiftImmOp	make_variant(VecShiftImmOp::Ushr, [])
		51: VecALUOp	make_variant(VecALUOp::Add, [])
		56: VecALUOp	make_variant(VecALUOp::Add, [])
		59: ValueRegs	constructor(value_reg, [114], 1)
		60: InstOutput	constructor(output, [59], 2)
		65: Type	const_prim(I8X16)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: MInst	make_variant(MInst::VecRRR, [31, 66, 13, 15, 9])
		68: Unit	constructor(emit, [67], 2)
		69: Reg	constructor(writable_reg_to_reg, [66], 0)
		74: Type	const_prim(I8X16)
		75: WritableReg	constructor(temp_writable_reg, [74], 1)
		76: MInst	make_variant(MInst::VecRRR, [36, 75, 69, 10, 9])
		77: Unit	constructor(emit, [76], 2)
		78: Reg	constructor(writable_reg_to_reg, [75], 0)
		83: Type	const_prim(I8X16)
		84: WritableReg	constructor(temp_writable_reg, [83], 1)
		85: MInst	make_variant(MInst::VecShiftImm, [41, 84, 18, 9, 19])
		86: Unit	constructor(emit, [85], 2)
		87: Reg	constructor(writable_reg_to_reg, [84], 0)
		92: Type	const_prim(I8X16)
		93: WritableReg	constructor(temp_writable_reg, [92], 1)
		94: MInst	make_variant(MInst::VecShiftImm, [46, 93, 21, 9, 19])
		95: Unit	constructor(emit, [94], 2)
		96: Reg	constructor(writable_reg_to_reg, [93], 0)
		101: Type	const_prim(I8X16)
		102: WritableReg	constructor(temp_writable_reg, [101], 1)
		103: MInst	make_variant(MInst::VecRRR, [51, 102, 87, 96, 9])
		104: Unit	constructor(emit, [103], 2)
		105: Reg	constructor(writable_reg_to_reg, [102], 0)
		110: Type	const_prim(I8X16)
		111: WritableReg	constructor(temp_writable_reg, [110], 1)
		112: MInst	make_variant(MInst::VecRRR, [56, 111, 78, 105, 9])
		113: Unit	constructor(emit, [112], 2)
		114: Reg	constructor(writable_reg_to_reg, [111], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		7:	some
	]
	result = 27
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
		../../codegen/src/isa/aarch64/inst.isle line 2660
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2723
		../../codegen/src/isa/aarch64/inst.isle line 2089
		../../codegen/src/isa/aarch64/inst.isle line 2134
		../../codegen/src/isa/aarch64/inst.isle line 1885
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Value	match_some(7)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: usize	const_int(1, usize)
		13: Reg	constructor(value_regs_get, [9, 12], 3)
		14: u8	const_int(63, u8)
		15: ImmShift	constructor(imm_shift_from_u8, [14], 4)
		16: Type	const_prim(I64)
		22: ValueRegs	constructor(with_flags, [50, 60], 10)
		23: InstOutput	constructor(output, [22], 11)
		24: Option(InstOutput)	some(23)
		25: Option(Option(InstOutput))	some(24)
		29: ALUOp	make_variant(ALUOp::Asr, [])
		34: ALUOp	make_variant(ALUOp::Eor, [])
		39: ALUOp	make_variant(ALUOp::Eor, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: OperandSize	constructor(operand_size, [16], 2)
		47: ALUOp	make_variant(ALUOp::SubS, [])
		48: MInst	make_variant(MInst::AluRRR, [47, 46, 45, 90, 70])
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
		50: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [48, 49])
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: OperandSize	constructor(operand_size, [16], 2)
		57: ALUOp	make_variant(ALUOp::Sbc, [])
		58: MInst	make_variant(MInst::AluRRR, [57, 56, 55, 80, 70])
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		60: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [58, 59])
		65: Type	const_prim(I64)
		66: WritableReg	constructor(temp_writable_reg, [65], 1)
		67: OperandSize	constructor(operand_size, [16], 2)
		68: MInst	make_variant(MInst::AluRRImmShift, [29, 67, 66, 13, 15])
		69: Unit	constructor(emit, [68], 3)
		70: Reg	constructor(writable_reg_to_reg, [66], 0)
		75: Type	const_prim(I64)
		76: WritableReg	constructor(temp_writable_reg, [75], 1)
		77: OperandSize	constructor(operand_size, [16], 2)
		78: MInst	make_variant(MInst::AluRRR, [34, 77, 76, 13, 70])
		79: Unit	constructor(emit, [78], 3)
		80: Reg	constructor(writable_reg_to_reg, [76], 0)
		85: Type	const_prim(I64)
		86: WritableReg	constructor(temp_writable_reg, [85], 1)
		87: OperandSize	constructor(operand_size, [16], 2)
		88: MInst	make_variant(MInst::AluRRR, [39, 87, 86, 11, 70])
		89: Unit	constructor(emit, [88], 3)
		90: Reg	constructor(writable_reg_to_reg, [86], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
		../../codegen/src/isa/aarch64/inst.isle line 2601
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2400
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Value)	extractor(iabs, 5)
		7: Type	match_tuple(4, 0)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: Value	match_some(6)
		10: Reg	constructor(put_in_reg_sext32, [9], 1)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		14: Option(InstOutput)	some(28)
		15: Option(Option(InstOutput))	some(14)
		18: u8	const_int(0, u8)
		19: Imm12	constructor(u8_into_imm12, [18], 1)
		21: Cond	make_variant(Cond::Gt, [])
		23: ValueRegs	constructor(with_flags, [35, 43], 4)
		24: usize	const_int(0, usize)
		25: Reg	constructor(value_regs_get, [23, 24], 5)
		27: ValueRegs	constructor(value_reg, [25], 1)
		28: InstOutput	constructor(output, [27], 2)
		32: WritableReg	constructor(writable_zero_reg, [], 1)
		33: ALUOp	make_variant(ALUOp::SubS, [])
		34: MInst	make_variant(MInst::AluRRImm12, [33, 11, 32, 10, 19])
		35: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [34])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: MInst	make_variant(MInst::CSNeg, [40, 21, 10, 10])
		42: Reg	constructor(writable_reg_to_reg, [40], 0)
		43: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [41, 42])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 345
		../../codegen/src/isa/aarch64/inst.isle line 2601
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2400
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(iabs, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		13: Option(InstOutput)	some(27)
		14: Option(Option(InstOutput))	some(13)
		17: u8	const_int(0, u8)
		18: Imm12	constructor(u8_into_imm12, [17], 1)
		20: Cond	make_variant(Cond::Gt, [])
		22: ValueRegs	constructor(with_flags, [34, 42], 4)
		23: usize	const_int(0, usize)
		24: Reg	constructor(value_regs_get, [22, 23], 5)
		26: ValueRegs	constructor(value_reg, [24], 1)
		27: InstOutput	constructor(output, [26], 2)
		31: WritableReg	constructor(writable_zero_reg, [], 1)
		32: ALUOp	make_variant(ALUOp::SubS, [])
		33: MInst	make_variant(MInst::AluRRImm12, [32, 10, 31, 9, 18])
		34: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [33])
		38: Type	const_prim(I64)
		39: WritableReg	constructor(temp_writable_reg, [38], 1)
		40: MInst	make_variant(MInst::CSNeg, [39, 20, 9, 9])
		41: Reg	constructor(writable_reg_to_reg, [39], 0)
		42: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [40, 41])
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 342
		../../codegen/src/isa/aarch64/inst.isle line 2596
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: Inst	match_tuple(4, 1)
		8: Option(Value)	extractor(iabs, 7)
		9: Value	match_some(8)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [5], 2)
		14: Option(InstOutput)	some(22)
		15: Option(Option(InstOutput))	some(14)
		18: VecMisc2	make_variant(VecMisc2::Abs, [])
		21: ValueRegs	constructor(value_reg, [30], 1)
		22: InstOutput	constructor(output, [21], 2)
		26: Type	const_prim(I8X16)
		27: WritableReg	constructor(temp_writable_reg, [26], 1)
		28: MInst	make_variant(MInst::VecMisc, [18, 27, 10, 11])
		29: Unit	constructor(emit, [28], 2)
		30: Reg	constructor(writable_reg_to_reg, [27], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 337
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd_pairwise, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Type	match_tuple(4, 0)
		13: VectorSize	constructor(vector_size, [12], 3)
		16: Option(InstOutput)	some(25)
		17: Option(Option(InstOutput))	some(16)
		21: VecALUOp	make_variant(VecALUOp::Addp, [])
		24: ValueRegs	constructor(value_reg, [34], 1)
		25: InstOutput	constructor(output, [24], 2)
		30: Type	const_prim(I8X16)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		32: MInst	make_variant(MInst::VecRRR, [21, 31, 9, 11, 13])
		33: Unit	constructor(emit, [32], 2)
		34: Reg	constructor(writable_reg_to_reg, [31], 0)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 17
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 334
		../../codegen/src/isa/aarch64/inst.isle line 2625
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(29)
		23: Option(Option(InstOutput))	some(22)
		25: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp16, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRPairLong, [25, 33, 19])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 330
		../../codegen/src/isa/aarch64/inst.isle line 2622
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Value	match_tuple(8, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(10)
		14: Option(Value)	extractor(uwiden_low, 13)
		15: Inst	match_some(12)
		16: Option(Value)	extractor(uwiden_high, 15)
		17: Value	match_some(14)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(29)
		23: Option(Option(InstOutput))	some(22)
		25: VecRRPairLongOp	make_variant(VecRRPairLongOp::Uaddlp8, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRPairLong, [25, 33, 19])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 326
		../../codegen/src/isa/aarch64/inst.isle line 2619
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(29)
		23: Option(Option(InstOutput))	some(22)
		25: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp16, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRPairLong, [25, 33, 19])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 322
		../../codegen/src/isa/aarch64/inst.isle line 2616
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2187
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd_pairwise, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: Option(Value)	extractor(swiden_low, 11)
		13: Value	match_tuple(8, 1)
		14: Option(Inst)	extractor(def_inst, 13)
		15: Inst	match_some(14)
		16: Option(Value)	extractor(swiden_high, 15)
		17: Value	match_some(12)
		18: Value	match_some(16)
		19: Reg	constructor(put_in_reg, [17], 1)
		22: Option(InstOutput)	some(29)
		23: Option(Option(InstOutput))	some(22)
		25: VecRRPairLongOp	make_variant(VecRRPairLongOp::Saddlp8, [])
		28: ValueRegs	constructor(value_reg, [36], 1)
		29: InstOutput	constructor(output, [28], 2)
		32: Type	const_prim(I8X16)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::VecRRPairLong, [25, 33, 19])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		7:	some
		10:	some
		12:	some
		14:	some
		16:	some
	]
	equals = [
		18 == 17
	]
	result = 23
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vany_true, 0)
		4: Value	match_some(3)
		5: Reg	constructor(put_in_reg, [4], 1)
		6: Type	extractor(value_type, 4)
		7: ProducesFlags	constructor(vanytrue, [5, 6], 2)
		8: Cond	make_variant(Cond::Ne, [])
		10: ValueRegs	constructor(with_flags, [7, 19], 4)
		11: InstOutput	constructor(output, [10], 5)
		12: Option(InstOutput)	some(11)
		13: Option(Option(InstOutput))	some(12)
		15: Type	const_prim(I64)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: MInst	make_variant(MInst::CSet, [16, 8])
		18: Reg	constructor(writable_reg_to_reg, [16], 0)
		19: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [17, 18])
	]
	constraints = [
		3:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 306
		../../codegen/src/isa/aarch64/inst.isle line 1961
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2117
		../../codegen/src/isa/aarch64/inst.isle line 2098
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(lane_fits_in_32, 5)
		7: Type	match_some(6)
		8: Option(Type)	constructor(not_vec32x2, [7], 0)
		9: Reg	constructor(put_in_reg, [4], 1)
		10: VectorSize	constructor(vector_size, [7], 2)
		11: VecLanesOp	make_variant(VecLanesOp::Uminv, [])
		13: u8	const_int(0, u8)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: Imm12	constructor(u8_into_imm12, [13], 5)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		19: Cond	make_variant(Cond::Ne, [])
		21: ValueRegs	constructor(with_flags, [47, 53], 8)
		22: InstOutput	constructor(output, [21], 9)
		23: Option(InstOutput)	some(22)
		24: Option(Option(InstOutput))	some(23)
		28: Type	const_prim(I8X16)
		29: WritableReg	constructor(temp_writable_reg, [28], 1)
		30: MInst	make_variant(MInst::VecLanes, [11, 29, 9, 10])
		31: Unit	constructor(emit, [30], 2)
		32: Reg	constructor(writable_reg_to_reg, [29], 0)
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		38: MInst	make_variant(MInst::MovFromVec, [37, 32, 13, 14])
		39: Unit	constructor(emit, [38], 2)
		40: Reg	constructor(writable_reg_to_reg, [37], 0)
		44: WritableReg	constructor(writable_zero_reg, [], 1)
		45: ALUOp	make_variant(ALUOp::SubS, [])
		46: MInst	make_variant(MInst::AluRRImm12, [45, 17, 44, 40, 16])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		49: Type	const_prim(I64)
		50: WritableReg	constructor(temp_writable_reg, [49], 1)
		51: MInst	make_variant(MInst::CSet, [50, 19])
		52: Reg	constructor(writable_reg_to_reg, [50], 0)
		53: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [51, 52])
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 24
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 289
		../../codegen/src/isa/aarch64/inst.isle line 2292
		../../codegen/src/isa/aarch64/inst.isle line 2011
		../../codegen/src/isa/aarch64/inst.isle line 2415
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: Reg	constructor(put_in_reg, [4], 1)
		11: u8	const_int(0, u8)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		14: Reg	constructor(zero_reg, [], 3)
		15: OperandSize	make_variant(OperandSize::Size64, [])
		16: u64	const_int(32, u64)
		18: UImm5	constructor(u8_into_uimm5, [11], 5)
		19: bool	const_prim(false)
		20: bool	const_prim(true)
		21: NZCV	constructor(nzcv, [19, 20, 19, 19], 6)
		22: OperandSize	make_variant(OperandSize::Size32, [])
		23: Cond	make_variant(Cond::Ne, [])
		25: ValueRegs	constructor(with_flags, [47, 59], 8)
		26: InstOutput	constructor(output, [25], 9)
		27: Option(InstOutput)	some(26)
		28: Option(Option(InstOutput))	some(27)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: MInst	make_variant(MInst::MovFromVec, [33, 10, 11, 12])
		35: Unit	constructor(emit, [34], 2)
		36: Reg	constructor(writable_reg_to_reg, [33], 0)
		41: Type	const_prim(I64)
		42: Option(ShiftOpAndAmt)	constructor(lshr_from_u64, [41, 16], 0)
		43: WritableReg	constructor(writable_zero_reg, [], 1)
		44: ALUOp	make_variant(ALUOp::SubS, [])
		45: ShiftOpAndAmt	match_some(42)
		46: MInst	make_variant(MInst::AluRRRShift, [44, 15, 43, 14, 36, 45])
		47: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [46])
		53: Type	const_prim(I64)
		54: WritableReg	constructor(temp_writable_reg, [53], 1)
		55: Reg	constructor(writable_reg_to_reg, [54], 0)
		56: ValueRegs	constructor(value_reg, [55], 2)
		57: MInst	make_variant(MInst::CCmpImm, [22, 36, 18, 21, 23])
		58: MInst	make_variant(MInst::CSet, [54, 23])
		59: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs, [57, 58, 56])
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(32)
		9:	const_int(2)
		42:	some
	]
	result = 28
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 283
		../../codegen/src/isa/aarch64/inst.isle line 3408
		../../codegen/src/isa/aarch64/inst.isle line 2588
		../../codegen/src/isa/aarch64/inst.isle line 1955
		../../codegen/src/isa/aarch64/inst.isle line 2098
		../../codegen/src/isa/aarch64/inst.isle line 2142
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(vall_true, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option((u32, u32))	extractor(multi_lane, 5)
		7: (u32, u32)	match_some(6)
		8: u32	match_tuple(7, 0)
		9: u32	match_tuple(7, 1)
		10: Reg	constructor(put_in_reg, [4], 1)
		11: VectorSize	make_variant(VectorSize::Size64x2, [])
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: Cond	make_variant(Cond::Eq, [])
		18: ValueRegs	constructor(with_flags, [35, 41], 6)
		19: InstOutput	constructor(output, [18], 7)
		20: Option(InstOutput)	some(19)
		21: Option(Option(InstOutput))	some(20)
		24: VecMisc2	make_variant(VecMisc2::Cmeq0, [])
		29: VecALUOp	make_variant(VecALUOp::Addp, [])
		34: MInst	make_variant(MInst::FpuCmp, [14, 58, 58])
		35: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsSideEffect, [34])
		37: Type	const_prim(I64)
		38: WritableReg	constructor(temp_writable_reg, [37], 1)
		39: MInst	make_variant(MInst::CSet, [38, 16])
		40: Reg	constructor(writable_reg_to_reg, [38], 0)
		41: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsReg, [39, 40])
		45: Type	const_prim(I8X16)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: MInst	make_variant(MInst::VecMisc, [24, 46, 10, 11])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [46], 0)
		54: Type	const_prim(I8X16)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		56: MInst	make_variant(MInst::VecRRR, [29, 55, 49, 49, 11])
		57: Unit	constructor(emit, [56], 2)
		58: Reg	constructor(writable_reg_to_reg, [55], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	const_int(64)
		9:	const_int(2)
	]
	result = 21
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Option(Type)	extractor(int_fits_in_32, 5)
		7: Reg	constructor(put_in_reg_zext32, [4], 1)
		8: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Option(InstOutput)	some(22)
		12: Option(Option(InstOutput))	some(11)
		15: Type	const_prim(I8X16)
		16: WritableReg	constructor(temp_writable_reg, [15], 1)
		17: MInst	make_variant(MInst::MovToFpu, [16, 7, 8])
		18: Unit	constructor(emit, [17], 2)
		19: Reg	constructor(writable_reg_to_reg, [16], 0)
		21: ValueRegs	constructor(value_reg, [19], 1)
		22: InstOutput	constructor(output, [21], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 12
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 266
		../../codegen/src/isa/aarch64/inst.isle line 2264
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(scalar_to_vector, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: Reg	constructor(put_in_reg, [4], 1)
		7: ScalarSize	make_variant(ScalarSize::Size64, [])
		10: Option(InstOutput)	some(21)
		11: Option(Option(InstOutput))	some(10)
		14: Type	const_prim(I8X16)
		15: WritableReg	constructor(temp_writable_reg, [14], 1)
		16: MInst	make_variant(MInst::MovToFpu, [15, 6, 7])
		17: Unit	constructor(emit, [16], 2)
		18: Reg	constructor(writable_reg_to_reg, [15], 0)
		20: ValueRegs	constructor(value_reg, [18], 1)
		21: InstOutput	constructor(output, [20], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
	]
	result = 11
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 263
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F32X4)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuExtend, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F64X2)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 260
		../../codegen/src/isa/aarch64/inst.isle line 2319
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option(Value)	extractor(scalar_to_vector, 6)
		8: Value	match_some(7)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		13: Option(InstOutput)	some(24)
		14: Option(Option(InstOutput))	some(13)
		17: Type	const_prim(F32X4)
		18: WritableReg	constructor(temp_writable_reg, [17], 1)
		19: MInst	make_variant(MInst::FpuExtend, [18, 9, 10])
		20: Unit	constructor(emit, [19], 2)
		21: Reg	constructor(writable_reg_to_reg, [18], 0)
		23: ValueRegs	constructor(value_reg, [21], 1)
		24: InstOutput	constructor(output, [23], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(F32X4)
		7:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 255
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iconcat, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: ValueRegs	constructor(value_regs, [10, 12], 3)
		14: InstOutput	constructor(output, [13], 4)
		15: Option(InstOutput)	some(14)
		16: Option(Option(InstOutput))	some(15)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 246
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(isplit, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: ValueRegs	constructor(put_in_regs, [4], 1)
		7: usize	const_int(0, usize)
		8: Reg	constructor(value_regs_get, [6, 7], 2)
		9: ValueRegs	constructor(value_reg, [8], 3)
		10: usize	const_int(1, usize)
		11: Reg	constructor(value_regs_get, [6, 10], 4)
		12: ValueRegs	constructor(value_reg, [11], 5)
		13: InstOutput	constructor(output_pair, [9, 12], 6)
		14: Option(InstOutput)	some(13)
		15: Option(Option(InstOutput))	some(14)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 241
		../../codegen/src/isa/aarch64/inst.isle line 2149
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(swizzle, 5)
		7: (Value, Value)	match_some(6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		14: Option(InstOutput)	some(25)
		15: Option(Option(InstOutput))	some(14)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecTbl, [19, 9, 11])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 235
		../../codegen/src/isa/aarch64/inst.isle line 2162
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value, Immediate))	extractor(shuffle, 5)
		7: (Value, Value, Immediate)	match_some(6)
		8: Immediate	match_tuple(7, 2)
		9: Option(u128)	extractor(u128_from_immediate, 8)
		10: u128	match_some(9)
		11: Reg	constructor(constant_f128, [10], 1)
		12: Value	match_tuple(7, 0)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Value	match_tuple(7, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: Type	match_tuple(4, 0)
		19: Option(InstOutput)	some(32)
		20: Option(Option(InstOutput))	some(19)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecTbl2, [26, 13, 15, 11])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
		31: ValueRegs	constructor(value_reg, [29], 1)
		32: InstOutput	constructor(output, [31], 2)
	]
	constraints = [
		3:	some
		6:	some
		9:	some
	]
	result = 20
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 232
		../../codegen/src/isa/aarch64/inst.isle line 2537
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Rev64, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(14673614102390417578512422760905835780)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 230
		../../codegen/src/isa/aarch64/inst.isle line 2537
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Rev64, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(12004814239757670119517129289737963270)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 228
		../../codegen/src/isa/aarch64/inst.isle line 2537
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Rev64, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(10680758337341567148842519922299176455)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 226
		../../codegen/src/isa/aarch64/inst.isle line 2533
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Rev32, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(17342576855639742879858139805557719810)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 224
		../../codegen/src/isa/aarch64/inst.isle line 2533
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Rev32, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(16018520953223639909183530438118932995)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 222
		../../codegen/src/isa/aarch64/inst.isle line 2529
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2142
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Option(InstOutput)	some(21)
		14: Option(Option(InstOutput))	some(13)
		17: VecMisc2	make_variant(VecMisc2::Rev16, [])
		20: ValueRegs	constructor(value_reg, [29], 1)
		21: InstOutput	constructor(output, [20], 2)
		25: Type	const_prim(I8X16)
		26: WritableReg	constructor(temp_writable_reg, [25], 1)
		27: MInst	make_variant(MInst::VecMisc, [17, 26, 9, 10])
		28: Unit	constructor(emit, [27], 2)
		29: Reg	constructor(writable_reg_to_reg, [26], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(18687320815856387368178823909286805505)
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 212
		../../codegen/src/isa/aarch64/inst.isle line 4185
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Trn2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909301208165426529540)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 210
		../../codegen/src/isa/aarch64/inst.isle line 4181
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Trn1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664569647092737326704519438008576)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 208
		../../codegen/src/isa/aarch64/inst.isle line 4185
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Trn2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142128814346332279593629287318274)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 206
		../../codegen/src/isa/aarch64/inst.isle line 4181
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Trn1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693260819630515246292341806293057792)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 204
		../../codegen/src/isa/aarch64/inst.isle line 4185
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Trn2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284541550424544734358823780242100481)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 202
		../../codegen/src/isa/aarch64/inst.isle line 4181
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Trn1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(39950100895832629191365197868744970240)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 194
		../../codegen/src/isa/aarch64/inst.isle line 4177
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Zip2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427188014754909590568856778836232)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 192
		../../codegen/src/isa/aarch64/inst.isle line 4173
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Zip1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901951279430565641561564801794304)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 190
		../../codegen/src/isa/aarch64/inst.isle line 4177
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Zip2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362142129435743685477327603181816072)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 188
		../../codegen/src/isa/aarch64/inst.isle line 4173
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Zip1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686616892700419341528320311204774144)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 186
		../../codegen/src/isa/aarch64/inst.isle line 4177
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Zip2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41284561912683712994304547342093195272)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 184
		../../codegen/src/isa/aarch64/inst.isle line 4173
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Zip1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30609036675948388650355540050116153344)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 179
		../../codegen/src/isa/aarch64/inst.isle line 4169
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427191743139026172726477975062792)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 177
		../../codegen/src/isa/aarch64/inst.isle line 4165
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(30686901955007814682223719185998020864)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 175
		../../codegen/src/isa/aarch64/inst.isle line 4169
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362427190500344320355979912890680580)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 173
		../../codegen/src/isa/aarch64/inst.isle line 4165
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(36024664572132682148381476266902159616)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 171
		../../codegen/src/isa/aarch64/inst.isle line 4169
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41362386467224802506860000736977486594)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 169
		../../codegen/src/isa/aarch64/inst.isle line 4165
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(38693505158040971420872748913983226112)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 167
		../../codegen/src/isa/aarch64/inst.isle line 4169
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp2, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(41357194091136896220700492464948314881)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 165
		../../codegen/src/isa/aarch64/inst.isle line 4165
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: Value	match_tuple(4, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(4, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Option(InstOutput)	some(24)
		16: Option(Option(InstOutput))	some(15)
		20: VecALUOp	make_variant(VecALUOp::Uzp1, [])
		23: ValueRegs	constructor(value_reg, [33], 1)
		24: InstOutput	constructor(output, [23], 2)
		29: Type	const_prim(I8X16)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: MInst	make_variant(MInst::VecRRR, [20, 30, 9, 11, 12])
		32: Unit	constructor(emit, [31], 2)
		33: Reg	constructor(writable_reg_to_reg, [30], 0)
	]
	constraints = [
		3:	some
		6:	some
		7:	const_int(40022753436544980677706866553451184640)
	]
	result = 16
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 152
		../../codegen/src/isa/aarch64/inst.isle line 2333
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(vec_extract_imm4_from_immediate, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: Value	match_tuple(4, 1)
		10: Reg	constructor(put_in_reg, [9], 2)
		11: u8	match_some(6)
		14: Option(InstOutput)	some(26)
		15: Option(Option(InstOutput))	some(14)
		19: Type	const_prim(I8X16)
		20: WritableReg	constructor(temp_writable_reg, [19], 1)
		21: MInst	make_variant(MInst::VecExtract, [20, 8, 10, 11])
		22: Unit	constructor(emit, [21], 2)
		23: Reg	constructor(writable_reg_to_reg, [20], 0)
		25: ValueRegs	constructor(value_reg, [23], 1)
		26: InstOutput	constructor(output, [25], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 15
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 133
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup64_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size64x2, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(25)
		14: Option(Option(InstOutput))	some(13)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecDupFromFpu, [19, 8, 9, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 131
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup32_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(25)
		14: Option(Option(InstOutput))	some(13)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecDupFromFpu, [19, 8, 9, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 129
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup16_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(25)
		14: Option(Option(InstOutput))	some(13)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecDupFromFpu, [19, 8, 9, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 127
		../../codegen/src/isa/aarch64/inst.isle line 1982
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Value, Value, Immediate))	extractor(shuffle, 0)
		4: (Value, Value, Immediate)	match_some(3)
		5: Immediate	match_tuple(4, 2)
		6: Option(u8)	extractor(shuffle_dup8_from_imm, 5)
		7: Value	match_tuple(4, 0)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: u8	match_some(6)
		13: Option(InstOutput)	some(25)
		14: Option(Option(InstOutput))	some(13)
		18: Type	const_prim(I8X16)
		19: WritableReg	constructor(temp_writable_reg, [18], 1)
		20: MInst	make_variant(MInst::VecDupFromFpu, [19, 8, 9, 10])
		21: Unit	constructor(emit, [20], 2)
		22: Reg	constructor(writable_reg_to_reg, [19], 0)
		24: ValueRegs	constructor(value_reg, [22], 1)
		25: InstOutput	constructor(output, [24], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
		../../codegen/src/isa/aarch64/inst.isle line 2073
		../../codegen/src/isa/aarch64/inst.isle line 2081
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Inst	match_tuple(4, 1)
		7: Option((Value, Value))	extractor(iadd, 6)
		8: (Value, Value)	match_some(7)
		9: Value	match_tuple(8, 0)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: Value	match_tuple(8, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 4)
		17: Reg	constructor(value_regs_get, [16, 11], 5)
		18: Reg	constructor(value_regs_get, [16, 13], 6)
		19: Type	const_prim(I64)
		22: ValueRegs	constructor(with_flags, [35, 45], 9)
		23: InstOutput	constructor(output, [22], 10)
		24: Option(InstOutput)	some(23)
		25: Option(Option(InstOutput))	some(24)
		29: Type	const_prim(I64)
		30: WritableReg	constructor(temp_writable_reg, [29], 1)
		31: OperandSize	constructor(operand_size, [19], 2)
		32: ALUOp	make_variant(ALUOp::AddS, [])
		33: MInst	make_variant(MInst::AluRRR, [32, 31, 30, 12, 17])
		34: Reg	constructor(writable_reg_to_reg, [30], 0)
		35: ProducesFlags	make_variant(ProducesFlags::ProducesFlagsReturnsResultWithConsumer, [33, 34])
		39: Type	const_prim(I64)
		40: WritableReg	constructor(temp_writable_reg, [39], 1)
		41: OperandSize	constructor(operand_size, [19], 2)
		42: ALUOp	make_variant(ALUOp::Adc, [])
		43: MInst	make_variant(MInst::AluRRR, [42, 41, 40, 14, 18])
		44: Reg	constructor(writable_reg_to_reg, [40], 0)
		45: ConsumesFlags	make_variant(ConsumesFlags::ConsumesFlagsReturnsResultWithProducer, [43, 44])
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		7:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 100
		../../codegen/src/isa/aarch64/inst.isle line 2440
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1899
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option((Value, Value))	extractor(iadd, 5)
		7: Type	match_tuple(4, 0)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: (Value, Value)	match_some(6)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	constructor(vector_size, [7], 3)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: VecALUOp	make_variant(VecALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [35], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I8X16)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: MInst	make_variant(MInst::VecRRR, [22, 32, 11, 13, 14])
		34: Unit	constructor(emit, [33], 2)
		35: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 95
		../../codegen/src/isa/aarch64/inst.isle line 2485
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(isub, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Value	match_tuple(9, 0)
		20: Reg	constructor(put_in_reg, [19], 3)
		21: Type	match_some(6)
		24: Option(InstOutput)	some(34)
		25: Option(Option(InstOutput))	some(24)
		30: ALUOp3	make_variant(ALUOp3::MSub, [])
		33: ValueRegs	constructor(value_reg, [45], 1)
		34: InstOutput	constructor(output, [33], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [21], 2)
		43: MInst	make_variant(MInst::AluRRRR, [30, 42, 41, 16, 18, 20])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 91
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Value	match_tuple(9, 1)
		20: Reg	constructor(put_in_reg, [19], 3)
		21: Type	match_some(6)
		24: Option(InstOutput)	some(34)
		25: Option(Option(InstOutput))	some(24)
		30: ALUOp3	make_variant(ALUOp3::MAdd, [])
		33: ValueRegs	constructor(value_reg, [45], 1)
		34: InstOutput	constructor(output, [33], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [21], 2)
		43: MInst	make_variant(MInst::AluRRRR, [30, 42, 41, 16, 18, 20])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 88
		../../codegen/src/isa/aarch64/inst.isle line 2480
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2043
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(imul, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Value	match_tuple(14, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Value	match_tuple(9, 0)
		20: Reg	constructor(put_in_reg, [19], 3)
		21: Type	match_some(6)
		24: Option(InstOutput)	some(34)
		25: Option(Option(InstOutput))	some(24)
		30: ALUOp3	make_variant(ALUOp3::MAdd, [])
		33: ValueRegs	constructor(value_reg, [45], 1)
		34: InstOutput	constructor(output, [33], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [21], 2)
		43: MInst	make_variant(MInst::AluRRRR, [30, 42, 41, 16, 18, 20])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
	]
	result = 25
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 82
		../../codegen/src/isa/aarch64/inst.isle line 2437
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 1)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(39)
		30: Option(Option(InstOutput))	some(29)
		35: ALUOp	make_variant(ALUOp::Add, [])
		38: ValueRegs	constructor(value_reg, [50], 1)
		39: InstOutput	constructor(output, [38], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [19], 2)
		48: MInst	make_variant(MInst::AluRRRShift, [35, 47, 46, 23, 25, 26])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 30
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 77
		../../codegen/src/isa/aarch64/inst.isle line 2437
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2003
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: Option((Value, Value))	extractor(ishl, 12)
		14: (Value, Value)	match_some(13)
		15: Value	match_tuple(14, 1)
		16: Option(Inst)	extractor(def_inst, 15)
		17: Inst	match_some(16)
		18: Option(Imm64)	extractor(iconst, 17)
		19: Type	match_some(6)
		20: Imm64	match_some(18)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [19, 20], 0)
		22: Value	match_tuple(9, 0)
		23: Reg	constructor(put_in_reg, [22], 1)
		24: Value	match_tuple(14, 0)
		25: Reg	constructor(put_in_reg, [24], 2)
		26: ShiftOpAndAmt	match_some(21)
		29: Option(InstOutput)	some(39)
		30: Option(Option(InstOutput))	some(29)
		35: ALUOp	make_variant(ALUOp::Add, [])
		38: ValueRegs	constructor(value_reg, [50], 1)
		39: InstOutput	constructor(output, [38], 2)
		45: Type	const_prim(I64)
		46: WritableReg	constructor(temp_writable_reg, [45], 1)
		47: OperandSize	constructor(operand_size, [19], 2)
		48: MInst	make_variant(MInst::AluRRRShift, [35, 47, 46, 23, 25, 26])
		49: Unit	constructor(emit, [48], 3)
		50: Reg	constructor(writable_reg_to_reg, [46], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
		13:	some
		16:	some
		18:	some
		21:	some
	]
	result = 30
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 72
		../../codegen/src/isa/aarch64/inst.isle line 2431
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2036
		../../codegen/src/isa/aarch64/inst.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::Add, [])
		26: ValueRegs	constructor(value_reg, [45], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Reg	constructor(put_extended_in_reg, [15], 1)
		33: ExtendOp	constructor(get_extended_op, [15], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [23, 42, 41, 13, 32, 33])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 69
		../../codegen/src/isa/aarch64/inst.isle line 2431
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 2036
		../../codegen/src/isa/aarch64/inst.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(ExtendedValue)	extractor(extended_value_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: ExtendedValue	match_some(11)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::Add, [])
		26: ValueRegs	constructor(value_reg, [45], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Reg	constructor(put_extended_in_reg, [15], 1)
		33: ExtendOp	constructor(get_extended_op, [15], 2)
		40: Type	const_prim(I64)
		41: WritableReg	constructor(temp_writable_reg, [40], 1)
		42: OperandSize	constructor(operand_size, [14], 2)
		43: MInst	make_variant(MInst::AluRRRExtend, [23, 42, 41, 13, 32, 33])
		44: Unit	constructor(emit, [43], 3)
		45: Reg	constructor(writable_reg_to_reg, [41], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 63
		../../codegen/src/isa/aarch64/inst.isle line 1803
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Option(Imm12)	match_some(35)
		18: Option(InstOutput)	some(43)
		19: Option(Option(InstOutput))	some(18)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Type, Inst))	extractor(has_type, 22)
		24: (Type, Inst)	match_some(23)
		25: Inst	match_tuple(24, 1)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Type	match_tuple(24, 0)
		28: Imm64	match_some(26)
		29: i64	constructor(i64_sextend_imm64, [27, 28], 0)
		30: i64	constructor(i64_neg, [29], 0)
		31: u64	constructor(i64_as_u64, [30], 0)
		32: Option(Imm12)	extractor(imm12_from_u64, 31)
		33: Imm12	match_some(32)
		34: Option(Imm12)	some(33)
		35: Option(Option(Imm12))	some(34)
		39: ALUOp	make_variant(ALUOp::Sub, [])
		42: ValueRegs	constructor(value_reg, [53], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [14], 2)
		51: MInst	make_variant(MInst::AluRRImm12, [39, 50, 49, 13, 15])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		32:	some
		35:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 59
		../../codegen/src/isa/aarch64/inst.isle line 1803
		../../codegen/src/isa/aarch64/inst.isle line 2448
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Option(Imm12)	match_some(35)
		18: Option(InstOutput)	some(43)
		19: Option(Option(InstOutput))	some(18)
		21: Option(Inst)	extractor(def_inst, 10)
		22: Inst	match_some(21)
		23: Option((Type, Inst))	extractor(has_type, 22)
		24: (Type, Inst)	match_some(23)
		25: Inst	match_tuple(24, 1)
		26: Option(Imm64)	extractor(iconst, 25)
		27: Type	match_tuple(24, 0)
		28: Imm64	match_some(26)
		29: i64	constructor(i64_sextend_imm64, [27, 28], 0)
		30: i64	constructor(i64_neg, [29], 0)
		31: u64	constructor(i64_as_u64, [30], 0)
		32: Option(Imm12)	extractor(imm12_from_u64, 31)
		33: Imm12	match_some(32)
		34: Option(Imm12)	some(33)
		35: Option(Option(Imm12))	some(34)
		39: ALUOp	make_variant(ALUOp::Sub, [])
		42: ValueRegs	constructor(value_reg, [53], 1)
		43: InstOutput	constructor(output, [42], 2)
		48: Type	const_prim(I64)
		49: WritableReg	constructor(temp_writable_reg, [48], 1)
		50: OperandSize	constructor(operand_size, [14], 2)
		51: MInst	make_variant(MInst::AluRRImm12, [39, 50, 49, 13, 15])
		52: Unit	constructor(emit, [51], 3)
		53: Reg	constructor(writable_reg_to_reg, [49], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		21:	some
		23:	some
		26:	some
		32:	some
		35:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 54
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::Add, [])
		26: ValueRegs	constructor(value_reg, [37], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [14], 2)
		35: MInst	make_variant(MInst::AluRRImm12, [23, 34, 33, 13, 15])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 51
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1996
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 1)
		11: Option(Imm12)	extractor(imm12_from_value, 10)
		12: Value	match_tuple(9, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Type	match_some(6)
		15: Imm12	match_some(11)
		18: Option(InstOutput)	some(27)
		19: Option(Option(InstOutput))	some(18)
		23: ALUOp	make_variant(ALUOp::Add, [])
		26: ValueRegs	constructor(value_reg, [37], 1)
		27: InstOutput	constructor(output, [26], 2)
		32: Type	const_prim(I64)
		33: WritableReg	constructor(temp_writable_reg, [32], 1)
		34: OperandSize	constructor(operand_size, [14], 2)
		35: MInst	make_variant(MInst::AluRRImm12, [23, 34, 33, 13, 15])
		36: Unit	constructor(emit, [35], 3)
		37: Reg	constructor(writable_reg_to_reg, [33], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
		11:	some
	]
	result = 19
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 47
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/prelude_lower.isle line 73
		../../codegen/src/isa/aarch64/inst.isle line 1892
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Type	match_tuple(4, 0)
		6: Option(Type)	extractor(fits_in_64, 5)
		7: Inst	match_tuple(4, 1)
		8: Option((Value, Value))	extractor(iadd, 7)
		9: (Value, Value)	match_some(8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Type	match_some(6)
		17: Option(InstOutput)	some(26)
		18: Option(Option(InstOutput))	some(17)
		22: ALUOp	make_variant(ALUOp::Add, [])
		25: ValueRegs	constructor(value_reg, [36], 1)
		26: InstOutput	constructor(output, [25], 2)
		31: Type	const_prim(I64)
		32: WritableReg	constructor(temp_writable_reg, [31], 1)
		33: OperandSize	constructor(operand_size, [14], 2)
		34: MInst	make_variant(MInst::AluRRR, [22, 33, 32, 11, 13])
		35: Unit	constructor(emit, [34], 3)
		36: Reg	constructor(writable_reg_to_reg, [32], 0)
	]
	constraints = [
		3:	some
		6:	some
		8:	some
	]
	result = 18
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 39
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(())	extractor(nop, 0)
		4: Reg	constructor(invalid_reg, [], 1)
		6: Option(InstOutput)	some(10)
		7: Option(Option(InstOutput))	some(6)
		9: ValueRegs	constructor(value_reg, [4], 1)
		10: InstOutput	constructor(output, [9], 2)
	]
	constraints = [
		3:	some
	]
	result = 7
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 34
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee64)	extractor(f64const, 0)
		4: Ieee64	match_some(3)
		5: u64	extractor(u64_from_ieee64, 4)
		6: Reg	constructor(constant_f64, [5], 1)
		8: Option(InstOutput)	some(12)
		9: Option(Option(InstOutput))	some(8)
		11: ValueRegs	constructor(value_reg, [6], 1)
		12: InstOutput	constructor(output, [11], 2)
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Ieee32)	extractor(f32const, 0)
		4: Ieee32	match_some(3)
		5: u32	extractor(u32_from_ieee32, 4)
		6: Reg	constructor(constant_f32, [5], 1)
		8: Option(InstOutput)	some(12)
		9: Option(Option(InstOutput))	some(8)
		11: ValueRegs	constructor(value_reg, [6], 1)
		12: InstOutput	constructor(output, [11], 2)
	]
	constraints = [
		3:	some
	]
	result = 9
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 24
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(())	extractor(null, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: u64	const_int(0, u64)
		10: Reg	constructor(imm, [7, 8, 9], 1)
		12: Option(InstOutput)	some(16)
		13: Option(Option(InstOutput))	some(12)
		15: ValueRegs	constructor(value_reg, [10], 1)
		16: InstOutput	constructor(output, [15], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 13
	feasible = true
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 19
		../../codegen/src/prelude_lower.isle line 73
	]
	bindings = [
		0: Inst	argument(0)
		3: Option((Type, Inst))	extractor(has_type, 0)
		4: (Type, Inst)	match_some(3)
		5: Inst	match_tuple(4, 1)
		6: Option(Imm64)	extractor(iconst, 5)
		7: Type	match_tuple(4, 0)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: Imm64	match_some(6)
		10: u64	extractor(u64_from_imm64, 9)
		11: Reg	constructor(imm, [7, 8, 10], 1)
		13: Option(InstOutput)	some(17)
		14: Option(Option(InstOutput))	some(13)
		16: ValueRegs	constructor(value_reg, [11], 1)
		17: InstOutput	constructor(output, [16], 2)
	]
	constraints = [
		3:	some
		6:	some
	]
	result = 14
	feasible = true
}

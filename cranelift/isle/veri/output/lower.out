inline term: lower
expansions = 479
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 97
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		7: Value	match_variant(4, InstructionData::Unary, arg)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: bool	const_prim(true)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: Reg	constructor(vec_extend, [6, 8, 9, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::UwidenHigh)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 92
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		7: Value	match_variant(4, InstructionData::Unary, arg)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: bool	const_prim(true)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: Reg	constructor(vec_extend, [6, 8, 9, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::SwidenHigh)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 87
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::BinaryImm8, opcode)
		5: Uimm8	match_variant(3, InstructionData::BinaryImm8, imm)
		6: Value	match_variant(3, InstructionData::BinaryImm8, arg)
		7: Reg	constructor(put_in_reg, [6], 1)
		8: ValueRegs	constructor(value_reg, [7], 2)
		9: InstOutput	constructor(output, [8], 3)
	]
	constraints = [
		3:	variant(InstructionData::BinaryImm8)
		4:	variant(Opcode::ExtractVector)
		5:	const_int(0)
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 81
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::DynamicStackLoad, opcode)
		5: Type	const_prim(I64)
		6: WritableReg	constructor(temp_writable_reg, [5], 1)
		7: Reg	constructor(writable_reg_to_reg, [6], 0)
		8: ValueRegs	constructor(value_reg, [7], 4)
		9: InstOutput	constructor(output, [8], 5)
	]
	constraints = [
		3:	variant(InstructionData::DynamicStackLoad)
		4:	variant(Opcode::DynamicStackAddr)
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 75
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(uqxtn, [12, 14], 3)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: ScalarSize	constructor(lane_size, [13], 5)
		19: Reg	constructor(uqxtn2, [15, 17, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Uunarrow)
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 71
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: u8	const_int(1, u8)
		16: u8	const_int(0, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_vec_elem, [12, 14, 15, 16, 17], 3)
		19: Type	match_some(8)
		20: ScalarSize	constructor(lane_size, [19], 4)
		21: Reg	constructor(uqxtn, [18, 20], 5)
		22: InstOutput	constructor(output_reg, [21], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Uunarrow)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 67
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_dyn128_int, 11)
		13: Value	match_tuple(7, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	match_some(12)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Reg	constructor(uqxtn, [14, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Uunarrow)
		9:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 61
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(sqxtun, [12, 14], 3)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: ScalarSize	constructor(lane_size, [13], 5)
		19: Reg	constructor(sqxtun2, [15, 17, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Unarrow)
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 57
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: u8	const_int(1, u8)
		16: u8	const_int(0, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_vec_elem, [12, 14, 15, 16, 17], 3)
		19: Type	match_some(8)
		20: ScalarSize	constructor(lane_size, [19], 4)
		21: Reg	constructor(sqxtun, [18, 20], 5)
		22: InstOutput	constructor(output_reg, [21], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Unarrow)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 53
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_dyn128_int, 11)
		13: Value	match_tuple(7, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	match_some(12)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Reg	constructor(sqxtun, [14, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Unarrow)
		9:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 47
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(sqxtn, [12, 14], 3)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: ScalarSize	constructor(lane_size, [13], 5)
		19: Reg	constructor(sqxtn2, [15, 17, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Snarrow)
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 43
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn64_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: u8	const_int(1, u8)
		16: u8	const_int(0, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_vec_elem, [12, 14, 15, 16, 17], 3)
		19: Type	match_some(8)
		20: ScalarSize	constructor(lane_size, [19], 4)
		21: Reg	constructor(sqxtn, [18, 20], 5)
		22: InstOutput	constructor(output_reg, [21], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Snarrow)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 39
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Value)	constructor(zero_value, [8], 0)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: Option(Type)	extractor(ty_dyn128_int, 11)
		13: Value	match_tuple(7, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	match_some(12)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Reg	constructor(sqxtn, [14, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Snarrow)
		9:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 35
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmax, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: ValueRegs	constructor(value_reg, [17], 5)
		19: InstOutput	constructor(output, [18], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmax)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 31
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmin, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: ValueRegs	constructor(value_reg, [17], 5)
		19: InstOutput	constructor(output, [18], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmin)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 27
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: ValueRegs	constructor(value_reg, [17], 5)
		19: InstOutput	constructor(output, [18], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fdiv)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 23
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmul, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: ValueRegs	constructor(value_reg, [17], 5)
		19: InstOutput	constructor(output, [18], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmul)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 19
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fsub, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: ValueRegs	constructor(value_reg, [17], 5)
		19: InstOutput	constructor(output, [18], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fsub)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 15
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fadd, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: ValueRegs	constructor(value_reg, [17], 5)
		19: InstOutput	constructor(output, [18], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fadd)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 11
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(lane_fits_in_32, 7)
		9: Type	match_some(8)
		10: Option((u32, u32))	extractor(dynamic_lane, 9)
		11: VecALUOp	make_variant(VecALUOp::Mul, [])
		12: ValueArray2	match_variant(4, InstructionData::Binary, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Value	match_tuple(13, 1)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: VectorSize	constructor(vector_size, [9], 3)
		19: Reg	constructor(vec_rrr, [11, 15, 17, 18], 4)
		20: ValueRegs	constructor(value_reg, [19], 5)
		21: InstOutput	constructor(output, [20], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Imul)
		8:	some
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 7
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		16: Reg	constructor(sub_vec, [12, 14, 15], 4)
		17: ValueRegs	constructor(value_reg, [16], 5)
		18: InstOutput	constructor(output, [17], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Isub)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower_dynamic_neon.isle line 3
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(dynamic_lane, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		16: Reg	constructor(add_vec, [12, 14, 15], 4)
		17: ValueRegs	constructor(value_reg, [16], 5)
		18: InstOutput	constructor(output, [17], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Iadd)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2860
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: VecRRLongOp	make_variant(VecRRLongOp::Fcvtl32, [])
		6: Value	match_variant(3, InstructionData::Unary, arg)
		7: Reg	constructor(put_in_reg, [6], 1)
		8: bool	const_prim(false)
		9: Reg	constructor(vec_rr_long, [5, 7, 8], 2)
		10: InstOutput	constructor(output_reg, [9], 3)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::FvpromoteLow)
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2855
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::UnaryGlobalValue, opcode)
		6: GlobalValue	match_variant(4, InstructionData::UnaryGlobalValue, global_value)
		7: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: TlsModel	extractor(tls_model, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(7)
		12: ExternalName	match_tuple(11, 0)
		13: Reg	constructor(macho_tls_get_addr, [12], 1)
		14: InstOutput	constructor(output_reg, [13], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::UnaryGlobalValue)
		5:	variant(Opcode::TlsValue)
		7:	some
		10:	variant(TlsModel::Macho)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2852
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::UnaryGlobalValue, opcode)
		6: GlobalValue	match_variant(4, InstructionData::UnaryGlobalValue, global_value)
		7: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: TlsModel	extractor(tls_model, 9)
		11: (ExternalName, RelocDistance, i64)	match_some(7)
		12: ExternalName	match_tuple(11, 0)
		13: Reg	constructor(elf_tls_get_addr, [12], 1)
		14: InstOutput	constructor(output_reg, [13], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::UnaryGlobalValue)
		5:	variant(Opcode::TlsValue)
		7:	some
		10:	variant(TlsModel::ElfGd)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2839
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(zero_reg, [], 3)
		16: Reg	constructor(madd, [8, 12, 14, 15], 4)
		17: ValueRegs	constructor(value_reg, [16], 11)
		18: OperandSize	make_variant(OperandSize::Size64, [])
		19: Reg	constructor(put_in_reg, [11], 5)
		20: Reg	constructor(put_in_reg, [13], 6)
		21: Reg	constructor(smulh, [8, 19, 20], 7)
		22: u64	const_int(63, u64)
		23: ProducesFlags	constructor(cmp_rr_shift_asr, [18, 21, 16, 22], 8)
		24: Cond	make_variant(Cond::Ne, [])
		25: ConsumesFlags	constructor(cset, [24], 9)
		26: Reg	constructor(with_flags_reg, [23, 25], 10)
		27: ValueRegs	constructor(value_reg, [26], 12)
		28: InstOutput	constructor(output_pair, [17, 27], 13)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::SmulOverflow)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2825
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Reg	constructor(smaddl, [11, 13, 14], 4)
		16: ValueRegs	constructor(value_reg, [15], 8)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		18: ExtendOp	make_variant(ExtendOp::SXTW, [])
		19: ProducesFlags	constructor(cmp_extend, [17, 15, 15, 18], 5)
		20: Cond	make_variant(Cond::Ne, [])
		21: ConsumesFlags	constructor(cset, [20], 6)
		22: Reg	constructor(with_flags_reg, [19, 21], 7)
		23: ValueRegs	constructor(value_reg, [22], 9)
		24: InstOutput	constructor(output_pair, [16, 23], 10)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::SmulOverflow)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2809
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_sext32, [12], 2)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg_sext32, [14], 3)
		16: Reg	constructor(zero_reg, [], 4)
		17: Reg	constructor(madd, [9, 13, 15, 16], 5)
		18: ValueRegs	constructor(value_reg, [17], 9)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		20: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		21: ExtendOp	constructor(lower_extend_op, [9, 20], 1)
		22: ProducesFlags	constructor(cmp_extend, [19, 17, 17, 21], 6)
		23: Cond	make_variant(Cond::Ne, [])
		24: ConsumesFlags	constructor(cset, [23], 7)
		25: Reg	constructor(with_flags_reg, [22, 24], 8)
		26: ValueRegs	constructor(value_reg, [25], 10)
		27: InstOutput	constructor(output_pair, [18, 26], 11)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SmulOverflow)
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2791
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(zero_reg, [], 3)
		16: Reg	constructor(madd, [8, 12, 14, 15], 4)
		17: ValueRegs	constructor(value_reg, [16], 12)
		18: Reg	constructor(put_in_reg, [11], 5)
		19: Reg	constructor(put_in_reg, [13], 6)
		20: Reg	constructor(umulh, [8, 18, 19], 7)
		21: u8	const_int(0, u8)
		22: Imm12	constructor(u8_into_imm12, [21], 8)
		23: ProducesFlags	constructor(cmp64_imm, [20, 22], 9)
		24: Cond	make_variant(Cond::Ne, [])
		25: ConsumesFlags	constructor(cset, [24], 10)
		26: Reg	constructor(with_flags_reg, [23, 25], 11)
		27: ValueRegs	constructor(value_reg, [26], 13)
		28: InstOutput	constructor(output_pair, [17, 27], 14)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::UmulOverflow)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2777
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: Reg	constructor(zero_reg, [], 3)
		15: Reg	constructor(umaddl, [11, 13, 14], 4)
		16: ValueRegs	constructor(value_reg, [15], 8)
		17: OperandSize	make_variant(OperandSize::Size64, [])
		18: ExtendOp	make_variant(ExtendOp::UXTW, [])
		19: ProducesFlags	constructor(cmp_extend, [17, 15, 15, 18], 5)
		20: Cond	make_variant(Cond::Ne, [])
		21: ConsumesFlags	constructor(cset, [20], 6)
		22: Reg	constructor(with_flags_reg, [19, 21], 7)
		23: ValueRegs	constructor(value_reg, [22], 9)
		24: InstOutput	constructor(output_pair, [16, 23], 10)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::UmulOverflow)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2761
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext32, [12], 2)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg_zext32, [14], 3)
		16: Reg	constructor(zero_reg, [], 4)
		17: Reg	constructor(madd, [9, 13, 15, 16], 5)
		18: ValueRegs	constructor(value_reg, [17], 9)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		20: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		21: ExtendOp	constructor(lower_extend_op, [9, 20], 1)
		22: ProducesFlags	constructor(cmp_extend, [19, 17, 17, 21], 6)
		23: Cond	make_variant(Cond::Ne, [])
		24: ConsumesFlags	constructor(cset, [23], 7)
		25: Reg	constructor(with_flags_reg, [22, 24], 8)
		26: ValueRegs	constructor(value_reg, [25], 10)
		27: InstOutput	constructor(output_pair, [18, 26], 11)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UmulOverflow)
		8:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2751
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Value	match_tuple(9, 1)
		12: ALUOp	make_variant(ALUOp::SubS, [])
		13: ALUOp	make_variant(ALUOp::SbcS, [])
		14: Cond	make_variant(Cond::Vs, [])
		15: InstOutput	constructor(overflow_op_128, [10, 11, 12, 13, 14], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::SsubOverflow)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2745
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ALUOp	make_variant(ALUOp::SubS, [])
		15: Cond	make_variant(Cond::Vs, [])
		16: InstOutput	constructor(overflow_op_normal, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SsubOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2740
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		15: ALUOp	make_variant(ALUOp::Sub, [])
		16: InstOutput	constructor(overflow_op_small, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SsubOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2731
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Value	match_tuple(9, 1)
		12: ALUOp	make_variant(ALUOp::SubS, [])
		13: ALUOp	make_variant(ALUOp::SbcS, [])
		14: Cond	make_variant(Cond::Lo, [])
		15: InstOutput	constructor(overflow_op_128, [10, 11, 12, 13, 14], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::UsubOverflow)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2725
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ALUOp	make_variant(ALUOp::SubS, [])
		15: Cond	make_variant(Cond::Lo, [])
		16: InstOutput	constructor(overflow_op_normal, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UsubOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2720
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		15: ALUOp	make_variant(ALUOp::Sub, [])
		16: InstOutput	constructor(overflow_op_small, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UsubOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2711
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Value	match_tuple(9, 1)
		12: ALUOp	make_variant(ALUOp::AddS, [])
		13: ALUOp	make_variant(ALUOp::AdcS, [])
		14: Cond	make_variant(Cond::Vs, [])
		15: InstOutput	constructor(overflow_op_128, [10, 11, 12, 13, 14], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::SaddOverflow)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2705
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ALUOp	make_variant(ALUOp::AddS, [])
		15: Cond	make_variant(Cond::Vs, [])
		16: InstOutput	constructor(overflow_op_normal, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SaddOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2700
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ArgumentExtension	make_variant(ArgumentExtension::Sext, [])
		15: ALUOp	make_variant(ALUOp::Add, [])
		16: InstOutput	constructor(overflow_op_small, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SaddOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2691
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Value	match_tuple(9, 1)
		12: ALUOp	make_variant(ALUOp::AddS, [])
		13: ALUOp	make_variant(ALUOp::AdcS, [])
		14: Cond	make_variant(Cond::Hs, [])
		15: InstOutput	constructor(overflow_op_128, [10, 11, 12, 13, 14], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::UaddOverflow)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2687
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_32_or_64, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ALUOp	make_variant(ALUOp::AddS, [])
		15: Cond	make_variant(Cond::Hs, [])
		16: InstOutput	constructor(overflow_op_normal, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UaddOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2683
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ArgumentExtension	make_variant(ArgumentExtension::Uext, [])
		15: ALUOp	make_variant(ALUOp::Add, [])
		16: InstOutput	constructor(overflow_op_small, [9, 12, 13, 14, 15], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UaddOverflow)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2603
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::IntAddTrap, opcode)
		9: Type	match_some(7)
		10: ValueArray2	match_variant(4, InstructionData::IntAddTrap, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: ProducesFlags	constructor(add_with_flags_paired, [9, 13, 15], 3)
		17: TrapCode	match_variant(4, InstructionData::IntAddTrap, code)
		18: Reg	constructor(trap_if_overflow, [16, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::IntAddTrap)
		7:	some
		8:	variant(Opcode::UaddOverflowTrap)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2589
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Type	const_prim(I64)
		8: Reg	constructor(put_in_reg, [5], 3)
		9: u8	const_int(0, u8)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: Reg	constructor(mov_from_vec, [8, 9, 10], 4)
		12: u8	const_int(63, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 7)
		14: Reg	constructor(lsr_imm, [7, 11, 13], 8)
		15: Reg	constructor(put_in_reg, [5], 1)
		16: u8	const_int(1, u8)
		17: Reg	constructor(mov_from_vec, [15, 16, 10], 2)
		18: ImmShift	constructor(imm_shift_from_u8, [12], 5)
		19: Reg	constructor(lsr_imm, [7, 17, 18], 6)
		20: u64	const_int(1, u64)
		21: Option(ShiftOpAndAmt)	constructor(lshl_from_u64, [7, 20], 0)
		22: ShiftOpAndAmt	match_some(21)
		23: Reg	constructor(add_shift, [7, 14, 19, 22], 9)
		24: InstOutput	constructor(output_reg, [23], 10)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VhighBits)
		6:	const_prim(I64X2)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2576
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Reg	constructor(put_in_reg, [5], 1)
		8: u8	const_int(31, u8)
		9: VectorSize	make_variant(VectorSize::Size32x4, [])
		10: Reg	constructor(sshr_vec_imm, [7, 8, 9], 2)
		11: u128	const_int(633825300187901677051779743745, u128)
		12: Reg	constructor(constant_f128, [11], 3)
		13: Reg	constructor(and_vec, [10, 12, 9], 4)
		14: Reg	constructor(addv, [13, 9], 5)
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size32, [])
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 6)
		18: InstOutput	constructor(output_reg, [17], 7)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VhighBits)
		6:	const_prim(I32X4)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2563
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Reg	constructor(put_in_reg, [5], 1)
		8: u8	const_int(15, u8)
		9: VectorSize	make_variant(VectorSize::Size16x8, [])
		10: Reg	constructor(sshr_vec_imm, [7, 8, 9], 2)
		11: u128	const_int(664619068533544770747334646890102785, u128)
		12: Reg	constructor(constant_f128, [11], 3)
		13: Reg	constructor(and_vec, [10, 12, 9], 4)
		14: Reg	constructor(addv, [13, 9], 5)
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size16, [])
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 6)
		18: InstOutput	constructor(output_reg, [17], 7)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VhighBits)
		6:	const_prim(I16X8)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2539
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Reg	constructor(put_in_reg, [5], 1)
		8: u8	const_int(7, u8)
		9: VectorSize	make_variant(VectorSize::Size8x16, [])
		10: Reg	constructor(sshr_vec_imm, [7, 8, 9], 2)
		11: u128	const_int(-169808226154284360427508033573982305791, u128)
		12: Reg	constructor(constant_f128, [11], 3)
		13: Reg	constructor(and_vec, [10, 12, 9], 4)
		14: u8	const_int(8, u8)
		15: Reg	constructor(vec_extract, [13, 13, 14], 5)
		16: Reg	constructor(zip1, [13, 15, 9], 6)
		17: VectorSize	make_variant(VectorSize::Size16x8, [])
		18: Reg	constructor(addv, [16, 17], 7)
		19: u8	const_int(0, u8)
		20: ScalarSize	make_variant(ScalarSize::Size16, [])
		21: Reg	constructor(mov_from_vec, [18, 19, 20], 8)
		22: InstOutput	constructor(output_reg, [21], 9)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VhighBits)
		6:	const_prim(I8X16)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2525
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::StackLoad, opcode)
		5: StackSlot	match_variant(3, InstructionData::StackLoad, stack_slot)
		6: Offset32	match_variant(3, InstructionData::StackLoad, offset)
		7: Reg	constructor(compute_stack_addr, [5, 6], 1)
		8: InstOutput	constructor(output_reg, [7], 2)
	]
	constraints = [
		3:	variant(InstructionData::StackLoad)
		4:	variant(Opcode::StackAddr)
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2518
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::TernaryImm8, opcode)
		5: ValueArray2	match_variant(3, InstructionData::TernaryImm8, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 1)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_scalar_float, 8)
		10: Value	match_tuple(6, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Reg	constructor(put_in_reg, [7], 2)
		13: Uimm8	match_variant(3, InstructionData::TernaryImm8, imm)
		14: u8	extractor(u8_from_uimm8, 13)
		15: u8	const_int(0, u8)
		16: Type	extractor(value_type, 10)
		17: VectorSize	constructor(vector_size, [16], 3)
		18: Reg	constructor(mov_vec_elem, [11, 12, 14, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	variant(InstructionData::TernaryImm8)
		4:	variant(Opcode::Insertlane)
		9:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2513
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::TernaryImm8, opcode)
		5: ValueArray2	match_variant(3, InstructionData::TernaryImm8, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 1)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_int, 8)
		10: Value	match_tuple(6, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Reg	constructor(put_in_reg, [7], 2)
		13: Uimm8	match_variant(3, InstructionData::TernaryImm8, imm)
		14: u8	extractor(u8_from_uimm8, 13)
		15: Type	extractor(value_type, 10)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(mov_to_vec, [11, 12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	variant(InstructionData::TernaryImm8)
		4:	variant(Opcode::Insertlane)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2506
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Opcode	match_variant(4, InstructionData::BinaryImm8, opcode)
		9: Value	match_variant(4, InstructionData::BinaryImm8, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Uimm8	match_variant(4, InstructionData::BinaryImm8, imm)
		12: u8	extractor(u8_from_uimm8, 11)
		13: Type	extractor(value_type, 9)
		14: VectorSize	constructor(vector_size, [13], 2)
		15: Reg	constructor(fpu_move_from_vec, [10, 12, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::BinaryImm8)
		7:	some
		8:	variant(Opcode::Extractlane)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2501
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_int, 6)
		8: Opcode	match_variant(4, InstructionData::BinaryImm8, opcode)
		9: Value	match_variant(4, InstructionData::BinaryImm8, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Uimm8	match_variant(4, InstructionData::BinaryImm8, imm)
		12: u8	extractor(u8_from_uimm8, 11)
		13: Type	match_some(7)
		14: ScalarSize	constructor(scalar_size, [13], 2)
		15: Reg	constructor(mov_from_vec, [10, 12, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::BinaryImm8)
		7:	some
		8:	variant(Opcode::Extractlane)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2498
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Opcode	match_variant(4, InstructionData::BinaryImm8, opcode)
		9: Uimm8	match_variant(4, InstructionData::BinaryImm8, imm)
		10: u8	extractor(u8_from_uimm8, 9)
		11: Value	match_variant(4, InstructionData::BinaryImm8, arg)
		12: InstOutput	constructor(output_value, [11], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::BinaryImm8)
		7:	some
		8:	variant(Opcode::Extractlane)
		10:	const_int(0)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2492
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::LoadNoOffset, opcode)
		8: Value	match_variant(6, InstructionData::LoadNoOffset, arg)
		9: Type	extractor(value_type, 8)
		10: InstOutput	constructor(output_value, [8], 1)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::LoadNoOffset)
		7:	variant(Opcode::Bitcast)
		9:	const_prim(I128)
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2488
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	constructor(ty_int_ref_scalar_64, [6], 0)
		8: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		9: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		10: Type	extractor(value_type, 9)
		11: Option(Type)	constructor(ty_int_ref_scalar_64, [10], 0)
		12: InstOutput	constructor(output_value, [9], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		7:	some
		8:	variant(Opcode::Bitcast)
		11:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2480
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	constructor(ty_int_ref_scalar_64, [6], 0)
		8: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		9: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		10: Type	extractor(value_type, 9)
		11: Option(Type)	constructor(ty_int_ref_scalar_64, [10], 0)
		12: bool	constructor(is_ref_type, [10], 0)
		13: bool	constructor(is_ref_type, [6], 0)
		14: Reg	constructor(put_in_reg, [9], 1)
		15: Reg	constructor(copy_reg, [10, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		7:	some
		8:	variant(Opcode::Bitcast)
		11:	some
		12:	const_prim(false)
		13:	const_prim(true)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2474
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	constructor(ty_int_ref_scalar_64, [6], 0)
		8: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		9: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		10: Type	extractor(value_type, 9)
		11: Option(Type)	constructor(ty_int_ref_scalar_64, [10], 0)
		12: bool	constructor(is_ref_type, [10], 0)
		13: bool	constructor(is_ref_type, [6], 0)
		14: Reg	constructor(put_in_reg, [9], 1)
		15: Reg	constructor(copy_reg, [6, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		7:	some
		8:	variant(Opcode::Bitcast)
		11:	some
		12:	const_prim(true)
		13:	const_prim(false)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2467
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	constructor(ty_int_ref_scalar_64, [6], 0)
		8: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		9: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		10: Type	extractor(value_type, 9)
		11: Option(Type)	extractor(fits_in_64, 10)
		12: Type	match_some(11)
		13: Option(Type)	extractor(ty_float_or_vec, 12)
		14: Reg	constructor(put_in_reg, [9], 1)
		15: u8	const_int(0, u8)
		16: ScalarSize	constructor(scalar_size, [6], 2)
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		7:	some
		8:	variant(Opcode::Bitcast)
		11:	some
		13:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2462
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_float_or_vec, 7)
		9: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		10: Type	extractor(value_type, 9)
		11: Option(Type)	constructor(ty_int_ref_scalar_64, [10], 0)
		12: Reg	constructor(put_in_reg, [9], 1)
		13: ScalarSize	constructor(scalar_size, [10], 2)
		14: Reg	constructor(mov_to_fpu, [12, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		5:	variant(Opcode::Bitcast)
		8:	some
		11:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2458
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_float_or_vec, 7)
		9: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		10: Type	extractor(value_type, 9)
		11: Option(Type)	extractor(ty_float_or_vec, 10)
		12: InstOutput	constructor(output_value, [9], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		5:	variant(Opcode::Bitcast)
		8:	some
		11:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2452
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Reg	constructor(put_in_reg, [5], 1)
		7: SideEffectNoResult	constructor(write_pinned_reg, [6], 2)
		8: InstOutput	constructor(side_effect, [7], 3)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::SetPinnedReg)
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2449
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: PReg	constructor(preg_pinned, [], 1)
		6: Reg	constructor(mov_from_preg, [5], 2)
		7: InstOutput	constructor(output_reg, [6], 3)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::GetPinnedReg)
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2442
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_dyn_vec128, 8)
		10: Type	const_prim(I8X16)
		11: Value	match_tuple(6, 1)
		12: Offset32	match_variant(3, InstructionData::Store, offset)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [10, 11, 13], 1)
		15: MemFlags	match_variant(3, InstructionData::Store, flags)
		16: Reg	constructor(put_in_reg, [7], 2)
		17: SideEffectNoResult	constructor(aarch64_fpustore128, [14, 15, 16], 3)
		18: InstOutput	constructor(side_effect, [17], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2438
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_dyn_vec64, 8)
		10: Type	const_prim(F64)
		11: Value	match_tuple(6, 1)
		12: Offset32	match_variant(3, InstructionData::Store, offset)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [10, 11, 13], 1)
		15: MemFlags	match_variant(3, InstructionData::Store, flags)
		16: Reg	constructor(put_in_reg, [7], 2)
		17: SideEffectNoResult	constructor(aarch64_fpustore64, [14, 15, 16], 3)
		18: InstOutput	constructor(side_effect, [17], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2434
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_vec128, 8)
		10: Type	const_prim(I8X16)
		11: Value	match_tuple(6, 1)
		12: Offset32	match_variant(3, InstructionData::Store, offset)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [10, 11, 13], 1)
		15: MemFlags	match_variant(3, InstructionData::Store, flags)
		16: Reg	constructor(put_in_reg, [7], 2)
		17: SideEffectNoResult	constructor(aarch64_fpustore128, [14, 15, 16], 3)
		18: InstOutput	constructor(side_effect, [17], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2430
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(ty_vec64, 8)
		10: Type	const_prim(F64)
		11: Value	match_tuple(6, 1)
		12: Offset32	match_variant(3, InstructionData::Store, offset)
		13: i32	constructor(offset32_to_i32, [12], 0)
		14: AMode	constructor(amode, [10, 11, 13], 1)
		15: MemFlags	match_variant(3, InstructionData::Store, flags)
		16: Reg	constructor(put_in_reg, [7], 2)
		17: SideEffectNoResult	constructor(aarch64_fpustore64, [14, 15, 16], 3)
		18: InstOutput	constructor(side_effect, [17], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2423
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Value	match_tuple(6, 1)
		10: Offset32	match_variant(3, InstructionData::Store, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: PairAMode	constructor(pair_amode, [9, 11], 1)
		13: MemFlags	match_variant(3, InstructionData::Store, flags)
		14: ValueRegs	constructor(put_in_regs, [7], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		17: ValueRegs	constructor(put_in_regs, [7], 4)
		18: usize	const_int(1, usize)
		19: Reg	constructor(value_regs_get, [17, 18], 5)
		20: SideEffectNoResult	constructor(aarch64_storep64, [12, 13, 16, 19], 6)
		21: InstOutput	constructor(side_effect, [20], 7)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(I128)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2418
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(F64)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_fpustore64, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(F64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2414
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(F32)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_fpustore32, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(F32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2409
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: Type	const_prim(I32)
		6: ValueArray2	match_variant(3, InstructionData::Store, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Offset32	match_variant(3, InstructionData::Store, offset)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [5, 8, 10], 1)
		12: MemFlags	match_variant(3, InstructionData::Store, flags)
		13: Value	match_tuple(7, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: SideEffectNoResult	constructor(aarch64_store32, [11, 12, 14], 3)
		16: InstOutput	constructor(side_effect, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Istore32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2405
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: Type	const_prim(I16)
		6: ValueArray2	match_variant(3, InstructionData::Store, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Offset32	match_variant(3, InstructionData::Store, offset)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [5, 8, 10], 1)
		12: MemFlags	match_variant(3, InstructionData::Store, flags)
		13: Value	match_tuple(7, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: SideEffectNoResult	constructor(aarch64_store16, [11, 12, 14], 3)
		16: InstOutput	constructor(side_effect, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Istore16)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2401
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: Type	const_prim(I8)
		6: ValueArray2	match_variant(3, InstructionData::Store, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Offset32	match_variant(3, InstructionData::Store, offset)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: AMode	constructor(amode, [5, 8, 10], 1)
		12: MemFlags	match_variant(3, InstructionData::Store, flags)
		13: Value	match_tuple(7, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: SideEffectNoResult	constructor(aarch64_store8, [11, 12, 14], 3)
		16: InstOutput	constructor(side_effect, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Istore8)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2396
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(I64)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_store64, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(R64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2392
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(I64)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_store64, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(I64)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2388
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(I32)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_store32, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(I32)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2384
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(I16)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_store16, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(I16)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2380
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Store, opcode)
		5: ValueArray2	match_variant(3, InstructionData::Store, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Type	const_prim(I8)
		10: Value	match_tuple(6, 1)
		11: Offset32	match_variant(3, InstructionData::Store, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(3, InstructionData::Store, flags)
		15: Reg	constructor(put_in_reg, [7], 2)
		16: SideEffectNoResult	constructor(aarch64_store8, [13, 14, 15], 3)
		17: InstOutput	constructor(side_effect, [16], 4)
	]
	constraints = [
		3:	variant(InstructionData::Store)
		4:	variant(Opcode::Store)
		8:	const_prim(I8)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2371
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		6: Type	const_prim(F64)
		7: Value	match_variant(3, InstructionData::Load, arg)
		8: Offset32	match_variant(3, InstructionData::Load, offset)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: AMode	constructor(amode, [6, 7, 9], 1)
		11: MemFlags	match_variant(3, InstructionData::Load, flags)
		12: Reg	constructor(aarch64_fpuload64, [10, 11], 2)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		15: Reg	constructor(vec_extend, [5, 12, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Uload32x2)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2365
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		6: Type	const_prim(F64)
		7: Value	match_variant(3, InstructionData::Load, arg)
		8: Offset32	match_variant(3, InstructionData::Load, offset)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: AMode	constructor(amode, [6, 7, 9], 1)
		11: MemFlags	match_variant(3, InstructionData::Load, flags)
		12: Reg	constructor(aarch64_fpuload64, [10, 11], 2)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size64, [])
		15: Reg	constructor(vec_extend, [5, 12, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Sload32x2)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2359
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		6: Type	const_prim(F64)
		7: Value	match_variant(3, InstructionData::Load, arg)
		8: Offset32	match_variant(3, InstructionData::Load, offset)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: AMode	constructor(amode, [6, 7, 9], 1)
		11: MemFlags	match_variant(3, InstructionData::Load, flags)
		12: Reg	constructor(aarch64_fpuload64, [10, 11], 2)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		15: Reg	constructor(vec_extend, [5, 12, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Uload16x4)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2353
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		6: Type	const_prim(F64)
		7: Value	match_variant(3, InstructionData::Load, arg)
		8: Offset32	match_variant(3, InstructionData::Load, offset)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: AMode	constructor(amode, [6, 7, 9], 1)
		11: MemFlags	match_variant(3, InstructionData::Load, flags)
		12: Reg	constructor(aarch64_fpuload64, [10, 11], 2)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size32, [])
		15: Reg	constructor(vec_extend, [5, 12, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Sload16x4)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2347
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		6: Type	const_prim(F64)
		7: Value	match_variant(3, InstructionData::Load, arg)
		8: Offset32	match_variant(3, InstructionData::Load, offset)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: AMode	constructor(amode, [6, 7, 9], 1)
		11: MemFlags	match_variant(3, InstructionData::Load, flags)
		12: Reg	constructor(aarch64_fpuload64, [10, 11], 2)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		15: Reg	constructor(vec_extend, [5, 12, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Uload8x8)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2341
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		6: Type	const_prim(F64)
		7: Value	match_variant(3, InstructionData::Load, arg)
		8: Offset32	match_variant(3, InstructionData::Load, offset)
		9: i32	constructor(offset32_to_i32, [8], 0)
		10: AMode	constructor(amode, [6, 7, 9], 1)
		11: MemFlags	match_variant(3, InstructionData::Load, flags)
		12: Reg	constructor(aarch64_fpuload64, [10, 11], 2)
		13: bool	const_prim(false)
		14: ScalarSize	make_variant(ScalarSize::Size16, [])
		15: Reg	constructor(vec_extend, [5, 12, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Sload8x8)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2337
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: Type	const_prim(I32)
		6: Value	match_variant(3, InstructionData::Load, arg)
		7: Offset32	match_variant(3, InstructionData::Load, offset)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [5, 6, 8], 1)
		10: MemFlags	match_variant(3, InstructionData::Load, flags)
		11: Reg	constructor(aarch64_sload32, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Sload32)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2334
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: Type	const_prim(I32)
		6: Value	match_variant(3, InstructionData::Load, arg)
		7: Offset32	match_variant(3, InstructionData::Load, offset)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [5, 6, 8], 1)
		10: MemFlags	match_variant(3, InstructionData::Load, flags)
		11: Reg	constructor(aarch64_uload32, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Uload32)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2331
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: Type	const_prim(I16)
		6: Value	match_variant(3, InstructionData::Load, arg)
		7: Offset32	match_variant(3, InstructionData::Load, offset)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [5, 6, 8], 1)
		10: MemFlags	match_variant(3, InstructionData::Load, flags)
		11: Reg	constructor(aarch64_sload16, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Sload16)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2328
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: Type	const_prim(I16)
		6: Value	match_variant(3, InstructionData::Load, arg)
		7: Offset32	match_variant(3, InstructionData::Load, offset)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [5, 6, 8], 1)
		10: MemFlags	match_variant(3, InstructionData::Load, flags)
		11: Reg	constructor(aarch64_uload16, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Uload16)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2325
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: Type	const_prim(I8)
		6: Value	match_variant(3, InstructionData::Load, arg)
		7: Offset32	match_variant(3, InstructionData::Load, offset)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [5, 6, 8], 1)
		10: MemFlags	match_variant(3, InstructionData::Load, flags)
		11: Reg	constructor(aarch64_sload8, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Sload8)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2322
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Load, opcode)
		5: Type	const_prim(I8)
		6: Value	match_variant(3, InstructionData::Load, arg)
		7: Offset32	match_variant(3, InstructionData::Load, offset)
		8: i32	constructor(offset32_to_i32, [7], 0)
		9: AMode	constructor(amode, [5, 6, 8], 1)
		10: MemFlags	match_variant(3, InstructionData::Load, flags)
		11: Reg	constructor(aarch64_uload8, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::Load)
		4:	variant(Opcode::Uload8)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2317
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Load, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn_vec128, 7)
		9: Type	const_prim(I8X16)
		10: Value	match_variant(4, InstructionData::Load, arg)
		11: Offset32	match_variant(4, InstructionData::Load, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(4, InstructionData::Load, flags)
		15: Reg	constructor(aarch64_fpuload128, [13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Load)
		5:	variant(Opcode::Load)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2313
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Load, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_dyn_vec64, 7)
		9: Type	const_prim(F64)
		10: Value	match_variant(4, InstructionData::Load, arg)
		11: Offset32	match_variant(4, InstructionData::Load, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(4, InstructionData::Load, flags)
		15: Reg	constructor(aarch64_fpuload64, [13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Load)
		5:	variant(Opcode::Load)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2309
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Opcode	match_variant(4, InstructionData::Load, opcode)
		9: Type	const_prim(I8X16)
		10: Value	match_variant(4, InstructionData::Load, arg)
		11: Offset32	match_variant(4, InstructionData::Load, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(4, InstructionData::Load, flags)
		15: Reg	constructor(aarch64_fpuload128, [13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Load)
		7:	some
		8:	variant(Opcode::Load)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2305
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Load, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec64, 7)
		9: Type	const_prim(F64)
		10: Value	match_variant(4, InstructionData::Load, arg)
		11: Offset32	match_variant(4, InstructionData::Load, offset)
		12: i32	constructor(offset32_to_i32, [11], 0)
		13: AMode	constructor(amode, [9, 10, 12], 1)
		14: MemFlags	match_variant(4, InstructionData::Load, flags)
		15: Reg	constructor(aarch64_fpuload64, [13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Load)
		5:	variant(Opcode::Load)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2302
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Value	match_variant(6, InstructionData::Load, arg)
		9: Offset32	match_variant(6, InstructionData::Load, offset)
		10: i32	constructor(offset32_to_i32, [9], 0)
		11: PairAMode	constructor(pair_amode, [8, 10], 1)
		12: MemFlags	match_variant(6, InstructionData::Load, flags)
		13: ValueRegs	constructor(aarch64_loadp64, [11, 12], 2)
		14: InstOutput	constructor(output, [13], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2299
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(F64)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_fpuload64, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2296
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(F32)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_fpuload32, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2293
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_uload64, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(R64)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2290
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_uload64, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2287
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_uload32, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2284
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(I16)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_uload16, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2281
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Load, opcode)
		8: Type	const_prim(I8)
		9: Value	match_variant(6, InstructionData::Load, arg)
		10: Offset32	match_variant(6, InstructionData::Load, offset)
		11: i32	constructor(offset32_to_i32, [10], 0)
		12: AMode	constructor(amode, [8, 9, 11], 1)
		13: MemFlags	match_variant(6, InstructionData::Load, flags)
		14: Reg	constructor(aarch64_uload8, [12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		6:	variant(InstructionData::Load)
		7:	variant(Opcode::Load)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2276
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::CallIndirect, opcode)
		5: ValueList	match_variant(3, InstructionData::CallIndirect, args)
		6: ValueSlice	extractor(value_list_slice, 5)
		7: Option((Value, ValueSlice))	extractor(value_slice_unwrap, 6)
		8: SigRef	match_variant(3, InstructionData::CallIndirect, sig_ref)
		9: (Value, ValueSlice)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueSlice	match_tuple(9, 1)
		12: InstOutput	constructor(gen_return_call_indirect, [8, 10, 11], 1)
	]
	constraints = [
		3:	variant(InstructionData::CallIndirect)
		4:	variant(Opcode::ReturnCallIndirect)
		7:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2273
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Call, opcode)
		5: FuncRef	match_variant(3, InstructionData::Call, func_ref)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueList	match_variant(3, InstructionData::Call, args)
		11: ValueSlice	extractor(value_list_slice, 10)
		12: InstOutput	constructor(gen_return_call, [7, 8, 9, 11], 1)
	]
	constraints = [
		3:	variant(InstructionData::Call)
		4:	variant(Opcode::ReturnCall)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2268
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::MultiAry, opcode)
		5: ValueList	match_variant(3, InstructionData::MultiAry, args)
		6: ValueSlice	extractor(value_list_slice, 5)
		7: InstOutput	constructor(lower_return, [6], 1)
	]
	constraints = [
		3:	variant(InstructionData::MultiAry)
		4:	variant(Opcode::Return)
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2262
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::CallIndirect, opcode)
		5: ValueList	match_variant(3, InstructionData::CallIndirect, args)
		6: ValueSlice	extractor(value_list_slice, 5)
		7: Option((Value, ValueSlice))	extractor(value_slice_unwrap, 6)
		8: SigRef	match_variant(3, InstructionData::CallIndirect, sig_ref)
		9: (Value, ValueSlice)	match_some(7)
		10: Value	match_tuple(9, 0)
		11: ValueSlice	match_tuple(9, 1)
		12: InstOutput	constructor(gen_call_indirect, [8, 10, 11], 1)
	]
	constraints = [
		3:	variant(InstructionData::CallIndirect)
		4:	variant(Opcode::CallIndirect)
		7:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2259
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Call, opcode)
		5: FuncRef	match_variant(3, InstructionData::Call, func_ref)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: SigRef	match_tuple(6, 0)
		8: ExternalName	match_tuple(6, 1)
		9: RelocDistance	match_tuple(6, 2)
		10: ValueList	match_variant(3, InstructionData::Call, args)
		11: ValueSlice	extractor(value_list_slice, 10)
		12: InstOutput	constructor(gen_call, [7, 8, 9, 11], 1)
	]
	constraints = [
		3:	variant(InstructionData::Call)
		4:	variant(Opcode::Call)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2254
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: Reg	constructor(aarch64_link, [], 1)
		6: InstOutput	constructor(output_reg, [5], 2)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::GetReturnAddress)
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2251
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: Reg	constructor(aarch64_sp, [], 1)
		6: InstOutput	constructor(output_reg, [5], 2)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::GetStackPointer)
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2248
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: Reg	constructor(aarch64_fp, [], 1)
		6: InstOutput	constructor(output_reg, [5], 2)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::GetFramePointer)
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2243
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::UnaryGlobalValue, opcode)
		5: GlobalValue	match_variant(3, InstructionData::UnaryGlobalValue, global_value)
		6: Option((ExternalName, RelocDistance, i64))	extractor(symbol_value_data, 5)
		7: (ExternalName, RelocDistance, i64)	match_some(6)
		8: ExternalName	match_tuple(7, 0)
		9: BoxExternalName	constructor(box_external_name, [8], 1)
		10: i64	match_tuple(7, 2)
		11: Reg	constructor(load_ext_name, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	variant(InstructionData::UnaryGlobalValue)
		4:	variant(Opcode::SymbolValue)
		6:	some
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2238
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::FuncAddr, opcode)
		5: FuncRef	match_variant(3, InstructionData::FuncAddr, func_ref)
		6: (SigRef, ExternalName, RelocDistance)	extractor(func_ref_data, 5)
		7: ExternalName	match_tuple(6, 1)
		8: BoxExternalName	constructor(box_external_name, [7], 1)
		9: i64	const_int(0, i64)
		10: Reg	constructor(load_ext_name, [8, 9], 2)
		11: InstOutput	constructor(output_reg, [10], 3)
	]
	constraints = [
		3:	variant(InstructionData::FuncAddr)
		4:	variant(Opcode::FuncAddr)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2233
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: SideEffectNoResult	constructor(brk, [], 1)
		6: InstOutput	constructor(side_effect, [5], 2)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::Debugtrap)
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2227
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: OperandSize	constructor(operand_size, [6], 1)
		8: Reg	constructor(put_in_reg, [5], 2)
		9: u8	const_int(1, u8)
		10: Imm12	constructor(u8_into_imm12, [9], 3)
		11: ProducesFlags	constructor(cmn_imm, [7, 8, 10], 4)
		12: Cond	make_variant(Cond::Eq, [])
		13: ConsumesFlags	constructor(materialize_bool_result, [12], 5)
		14: ValueRegs	constructor(with_flags, [11, 13], 6)
		15: InstOutput	constructor(output, [14], 7)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::IsInvalid)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2221
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: OperandSize	constructor(operand_size, [6], 1)
		8: Reg	constructor(put_in_reg, [5], 2)
		9: u8	const_int(0, u8)
		10: Imm12	constructor(u8_into_imm12, [9], 3)
		11: ProducesFlags	constructor(cmp_imm, [7, 8, 10], 4)
		12: Cond	make_variant(Cond::Eq, [])
		13: ConsumesFlags	constructor(materialize_bool_result, [12], 5)
		14: ValueRegs	constructor(with_flags, [11, 13], 6)
		15: InstOutput	constructor(output, [14], 7)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::IsNull)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2216
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: SideEffectNoResult	constructor(aarch64_fence, [], 1)
		6: InstOutput	constructor(side_effect, [5], 2)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::Fence)
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2209
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	constructor(ty_vec64, [7], 0)
		9: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: u8	const_int(1, u8)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		14: Reg	constructor(fpu_move_from_vec, [11, 12, 13], 2)
		15: bool	const_prim(false)
		16: ScalarSize	constructor(lane_size, [7], 3)
		17: Reg	constructor(vec_extend, [9, 14, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::UwidenHigh)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2206
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: bool	const_prim(true)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(vec_extend, [9, 11, 12, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::UwidenHigh)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2201
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: VecExtendOp	make_variant(VecExtendOp::Uxtl, [])
		7: Value	match_variant(4, InstructionData::Unary, arg)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: bool	const_prim(false)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: Reg	constructor(vec_extend, [6, 8, 9, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::UwidenLow)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2194
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	constructor(ty_vec64, [7], 0)
		9: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: u8	const_int(1, u8)
		13: VectorSize	make_variant(VectorSize::Size32x2, [])
		14: Reg	constructor(fpu_move_from_vec, [11, 12, 13], 2)
		15: bool	const_prim(false)
		16: ScalarSize	constructor(lane_size, [7], 3)
		17: Reg	constructor(vec_extend, [9, 14, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::SwidenHigh)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2191
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: bool	const_prim(true)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(vec_extend, [9, 11, 12, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::SwidenHigh)
		8:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2186
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: VecExtendOp	make_variant(VecExtendOp::Sxtl, [])
		7: Value	match_variant(4, InstructionData::Unary, arg)
		8: Reg	constructor(put_in_reg, [7], 1)
		9: bool	const_prim(false)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: ScalarSize	constructor(lane_size, [11], 2)
		13: Reg	constructor(vec_extend, [6, 8, 9, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::SwidenLow)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2179
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(uqxtn, [12, 14], 3)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: ScalarSize	constructor(lane_size, [13], 5)
		19: Reg	constructor(uqxtn2, [15, 17, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Uunarrow)
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2175
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: u8	const_int(1, u8)
		16: u8	const_int(0, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_vec_elem, [12, 14, 15, 16, 17], 3)
		19: Type	match_some(8)
		20: ScalarSize	constructor(lane_size, [19], 4)
		21: Reg	constructor(uqxtn, [18, 20], 5)
		22: InstOutput	constructor(output_reg, [21], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Uunarrow)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2171
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Value)	constructor(zero_value, [11], 0)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	match_some(8)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Reg	constructor(uqxtn, [14, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Uunarrow)
		8:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2163
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(sqxtun, [12, 14], 3)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: ScalarSize	constructor(lane_size, [13], 5)
		19: Reg	constructor(sqxtun2, [15, 17, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Unarrow)
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2159
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: u8	const_int(1, u8)
		16: u8	const_int(0, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_vec_elem, [12, 14, 15, 16, 17], 3)
		19: Type	match_some(8)
		20: ScalarSize	constructor(lane_size, [19], 4)
		21: Reg	constructor(sqxtun, [18, 20], 5)
		22: InstOutput	constructor(output_reg, [21], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Unarrow)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2155
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Value)	constructor(zero_value, [11], 0)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	match_some(8)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Reg	constructor(sqxtun, [14, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Unarrow)
		8:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2148
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Type	match_some(8)
		14: ScalarSize	constructor(lane_size, [13], 2)
		15: Reg	constructor(sqxtn, [12, 14], 3)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: ScalarSize	constructor(lane_size, [13], 5)
		19: Reg	constructor(sqxtn2, [15, 17, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Snarrow)
		8:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2144
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec64_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: u8	const_int(1, u8)
		16: u8	const_int(0, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_vec_elem, [12, 14, 15, 16, 17], 3)
		19: Type	match_some(8)
		20: ScalarSize	constructor(lane_size, [19], 4)
		21: Reg	constructor(sqxtn, [18, 20], 5)
		22: InstOutput	constructor(output_reg, [21], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Snarrow)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2140
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128_int, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Value)	constructor(zero_value, [11], 0)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Type	match_some(8)
		16: ScalarSize	constructor(lane_size, [15], 2)
		17: Reg	constructor(sqxtn, [14, 16], 3)
		18: InstOutput	constructor(output_reg, [17], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Snarrow)
		8:	some
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2135
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Reg	constructor(put_in_reg, [5], 1)
		7: ScalarSize	make_variant(ScalarSize::Size32, [])
		8: Reg	constructor(fcvtn, [6, 7], 2)
		9: InstOutput	constructor(output_reg, [8], 3)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::Fvdemote)
	]
	result = 9
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2130
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicCas, opcode)
		9: ValueArray3	match_variant(4, InstructionData::AtomicCas, args)
		10: (Value, Value, Value)	extractor(value_array_3, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Value	match_tuple(10, 2)
		16: Reg	constructor(put_in_reg, [15], 3)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicCas, flags)
		19: Reg	constructor(atomic_cas_loop, [12, 14, 16, 17, 18], 4)
		20: InstOutput	constructor(output_reg, [19], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicCas)
		7:	some
		8:	variant(Opcode::AtomicCas)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2125
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicCas, opcode)
		10: ValueArray3	match_variant(4, InstructionData::AtomicCas, args)
		11: (Value, Value, Value)	extractor(value_array_3, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Value	match_tuple(11, 2)
		17: Reg	constructor(put_in_reg, [16], 3)
		18: Type	match_some(7)
		19: MemFlags	match_variant(4, InstructionData::AtomicCas, flags)
		20: Reg	constructor(lse_atomic_cas, [13, 15, 17, 18, 19], 4)
		21: InstOutput	constructor(output_reg, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicCas)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicCas)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2120
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Xchg, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Xchg)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2117
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umax, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Umax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2114
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Umin, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Umin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2111
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smax, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Smax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2108
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Smin, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Smin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2105
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Eor, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Xor)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2102
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Orr, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Or)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2099
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Nand, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Nand)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2096
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::And, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::And)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2093
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Sub, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Sub)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2090
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		9: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		10: AtomicRMWLoopOp	make_variant(AtomicRMWLoopOp::Add, [])
		11: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(atomic_rmw_loop, [10, 14, 16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	variant(Opcode::AtomicRmw)
		9:	variant(AtomicRmwOp::Add)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2084
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Clr, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Type	match_some(7)
		16: Value	match_tuple(13, 1)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Reg	constructor(zero_reg, [], 2)
		19: Reg	constructor(eon, [15, 17, 18], 3)
		20: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		21: Reg	constructor(lse_atomic_rmw, [11, 14, 19, 15, 20], 4)
		22: InstOutput	constructor(output_reg, [21], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::And)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2080
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Type	match_some(7)
		16: Reg	constructor(zero_reg, [], 1)
		17: Value	match_tuple(13, 1)
		18: Reg	constructor(put_in_reg, [17], 2)
		19: Reg	constructor(sub, [15, 16, 18], 3)
		20: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		21: Reg	constructor(lse_atomic_rmw, [11, 14, 19, 15, 20], 4)
		22: InstOutput	constructor(output_reg, [21], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Sub)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2076
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Umin, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Umin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2072
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Umax, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Umax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2068
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Smin, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Smin)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2064
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Smax, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Smax)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2060
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Set, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Or)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2056
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Eor, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Xor)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2052
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Option(())	extractor(use_lse, 0)
		9: Opcode	match_variant(4, InstructionData::AtomicRmw, opcode)
		10: AtomicRmwOp	match_variant(4, InstructionData::AtomicRmw, op)
		11: AtomicRMWOp	make_variant(AtomicRMWOp::Add, [])
		12: ValueArray2	match_variant(4, InstructionData::AtomicRmw, args)
		13: (Value, Value)	extractor(value_array_2, 12)
		14: Value	match_tuple(13, 0)
		15: Value	match_tuple(13, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: Type	match_some(7)
		18: MemFlags	match_variant(4, InstructionData::AtomicRmw, flags)
		19: Reg	constructor(lse_atomic_rmw, [11, 14, 16, 17, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::AtomicRmw)
		7:	some
		8:	some
		9:	variant(Opcode::AtomicRmw)
		10:	variant(AtomicRmwOp::Add)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2045
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::StoreNoOffset, opcode)
		5: ValueArray2	match_variant(3, InstructionData::StoreNoOffset, args)
		6: (Value, Value)	extractor(value_array_2, 5)
		7: Value	match_tuple(6, 0)
		8: Type	extractor(value_type, 7)
		9: Option(Type)	extractor(valid_atomic_transaction, 8)
		10: Type	match_some(9)
		11: MemFlags	match_variant(3, InstructionData::StoreNoOffset, flags)
		12: Reg	constructor(put_in_reg, [7], 1)
		13: Value	match_tuple(6, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: SideEffectNoResult	constructor(store_release, [10, 11, 12, 14], 3)
		16: InstOutput	constructor(side_effect, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::StoreNoOffset)
		4:	variant(Opcode::AtomicStore)
		9:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2040
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(valid_atomic_transaction, 6)
		8: Opcode	match_variant(4, InstructionData::LoadNoOffset, opcode)
		9: Type	match_some(7)
		10: MemFlags	match_variant(4, InstructionData::LoadNoOffset, flags)
		11: Value	match_variant(4, InstructionData::LoadNoOffset, arg)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Reg	constructor(load_acquire, [9, 10, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::LoadNoOffset)
		7:	some
		8:	variant(Opcode::AtomicLoad)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2034
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Option(Inst)	extractor(def_inst, 6)
		8: Inst	match_some(7)
		9: InstructionData	extractor(inst_data, 8)
		10: Option(Inst)	constructor(is_sinkable_inst, [6], 0)
		11: Opcode	match_variant(9, InstructionData::Load, opcode)
		12: Value	match_some(3)
		13: Type	extractor(value_type, 12)
		14: Type	constructor(lane_type, [13], 0)
		15: Inst	match_some(10)
		16: Reg	constructor(sink_load_into_addr, [14, 15], 1)
		17: VectorSize	constructor(vector_size, [13], 2)
		18: MemFlags	match_variant(9, InstructionData::Load, flags)
		19: Reg	constructor(ld1r, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		7:	some
		9:	variant(InstructionData::Load)
		10:	some
		11:	variant(Opcode::Load)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2031
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Option(Inst)	extractor(def_inst, 6)
		8: Inst	match_some(7)
		9: InstructionData	extractor(inst_data, 8)
		10: Opcode	match_variant(9, InstructionData::Unary, opcode)
		11: Value	match_variant(9, InstructionData::Unary, arg)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::UnaryImm, opcode)
		16: Imm64	match_variant(14, InstructionData::UnaryImm, imm)
		17: u64	extractor(u64_from_imm64, 16)
		18: Value	match_some(3)
		19: Type	extractor(value_type, 18)
		20: VectorSize	constructor(vector_size, [19], 1)
		21: Reg	constructor(splat_const, [17, 20], 2)
		22: InstOutput	constructor(output_reg, [21], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		7:	some
		9:	variant(InstructionData::Unary)
		10:	variant(Opcode::Ireduce)
		12:	some
		14:	variant(InstructionData::UnaryImm)
		15:	variant(Opcode::Iconst)
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2028
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Option(Inst)	extractor(def_inst, 6)
		8: Inst	match_some(7)
		9: InstructionData	extractor(inst_data, 8)
		10: Opcode	match_variant(9, InstructionData::UnaryImm, opcode)
		11: Imm64	match_variant(9, InstructionData::UnaryImm, imm)
		12: u64	extractor(u64_from_imm64, 11)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: VectorSize	constructor(vector_size, [14], 1)
		16: Reg	constructor(splat_const, [12, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		7:	some
		9:	variant(InstructionData::UnaryImm)
		10:	variant(Opcode::Iconst)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2025
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Option(Inst)	extractor(def_inst, 6)
		8: Inst	match_some(7)
		9: InstructionData	extractor(inst_data, 8)
		10: Opcode	match_variant(9, InstructionData::UnaryIeee64, opcode)
		11: Ieee64	match_variant(9, InstructionData::UnaryIeee64, imm)
		12: u64	extractor(u64_from_ieee64, 11)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: VectorSize	constructor(vector_size, [14], 1)
		16: Reg	constructor(splat_const, [12, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		7:	some
		9:	variant(InstructionData::UnaryIeee64)
		10:	variant(Opcode::F64const)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2022
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Option(Inst)	extractor(def_inst, 6)
		8: Inst	match_some(7)
		9: InstructionData	extractor(inst_data, 8)
		10: Opcode	match_variant(9, InstructionData::UnaryIeee32, opcode)
		11: Ieee32	match_variant(9, InstructionData::UnaryIeee32, imm)
		12: u32	extractor(u32_from_ieee32, 11)
		13: u64	constructor(u32_as_u64, [12], 0)
		14: Value	match_some(3)
		15: Type	extractor(value_type, 14)
		16: VectorSize	constructor(vector_size, [15], 1)
		17: Reg	constructor(splat_const, [13, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		7:	some
		9:	variant(InstructionData::UnaryIeee32)
		10:	variant(Opcode::F32const)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2019
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: Reg	constructor(put_in_reg, [6], 1)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: u8	const_int(0, u8)
		14: Reg	constructor(vec_dup_from_fpu, [9, 12, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2015
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: Reg	constructor(put_in_reg, [6], 1)
		10: Value	match_some(3)
		11: Type	extractor(value_type, 10)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: Reg	constructor(vec_dup, [9, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Splat)
		8:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2009
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::UnaryConst, opcode)
		6: Constant	match_variant(4, InstructionData::UnaryConst, constant_handle)
		7: Option(u64)	extractor(u64_from_constant, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	constructor(ty_vec64, [9], 0)
		11: u64	match_some(7)
		12: Reg	constructor(constant_f64, [11], 1)
		13: InstOutput	constructor(output_reg, [12], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::UnaryConst)
		5:	variant(Opcode::Vconst)
		7:	some
		10:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 2006
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_vec128, 6)
		8: Opcode	match_variant(4, InstructionData::UnaryConst, opcode)
		9: Constant	match_variant(4, InstructionData::UnaryConst, constant_handle)
		10: Option(u128)	extractor(u128_from_constant, 9)
		11: u128	match_some(10)
		12: Reg	constructor(constant_f128, [11], 1)
		13: InstOutput	constructor(output_reg, [12], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::UnaryConst)
		7:	some
		8:	variant(Opcode::Vconst)
		10:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1995
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Type	const_prim(I64)
		12: ValueRegs	constructor(put_in_regs, [8], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [12, 15], 3)
		17: Reg	constructor(orr, [11, 14, 16], 4)
		18: Reg	constructor(zero_reg, [], 5)
		19: ProducesFlags	constructor(cmp, [10, 17, 18], 6)
		20: Cond	make_variant(Cond::Ne, [])
		21: Value	match_some(3)
		22: Type	extractor(value_type, 21)
		23: Value	match_tuple(7, 1)
		24: Value	match_tuple(7, 2)
		25: ValueRegs	constructor(lower_select, [19, 20, 22, 23, 24], 7)
		26: InstOutput	constructor(output, [25], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::SelectSpectreGuard)
		9:	const_prim(I128)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1989
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		12: Reg	constructor(put_in_reg_zext64, [8], 1)
		13: Reg	constructor(zero_reg, [], 2)
		14: ProducesFlags	constructor(cmp, [11, 12, 13], 3)
		15: Cond	make_variant(Cond::Ne, [])
		16: Value	match_some(3)
		17: Type	extractor(value_type, 16)
		18: Value	match_tuple(7, 1)
		19: Value	match_tuple(7, 2)
		20: ValueRegs	constructor(lower_select, [14, 15, 17, 18, 19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::SelectSpectreGuard)
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1975
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::IntCompare, opcode)
		15: IntCC	match_variant(13, InstructionData::IntCompare, cond)
		16: ValueArray2	match_variant(13, InstructionData::IntCompare, args)
		17: (Value, Value)	extractor(value_array_2, 16)
		18: Value	match_tuple(17, 0)
		19: Value	match_tuple(17, 1)
		20: Type	extractor(value_type, 18)
		21: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 18, 19, 20], 1)
		22: ProducesFlags	constructor(flags_and_cc_flags, [21], 2)
		23: IntCC	constructor(flags_and_cc_cc, [21], 3)
		24: Cond	constructor(cond_code, [23], 4)
		25: Value	match_some(3)
		26: Type	extractor(value_type, 25)
		27: Value	match_tuple(7, 1)
		28: Value	match_tuple(7, 2)
		29: ValueRegs	constructor(lower_select, [22, 24, 26, 27, 28], 5)
		30: InstOutput	constructor(output, [29], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::SelectSpectreGuard)
		9:	some
		11:	some
		13:	variant(InstructionData::IntCompare)
		14:	variant(Opcode::Icmp)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1964
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: Type	const_prim(I64)
		12: ValueRegs	constructor(put_in_regs, [8], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: usize	const_int(1, usize)
		16: Reg	constructor(value_regs_get, [12, 15], 3)
		17: Reg	constructor(orr, [11, 14, 16], 4)
		18: Reg	constructor(zero_reg, [], 5)
		19: ProducesFlags	constructor(cmp, [10, 17, 18], 6)
		20: Cond	make_variant(Cond::Ne, [])
		21: Value	match_some(3)
		22: Type	extractor(value_type, 21)
		23: Value	match_tuple(7, 1)
		24: Value	match_tuple(7, 2)
		25: ValueRegs	constructor(lower_select, [19, 20, 22, 23, 24], 7)
		26: InstOutput	constructor(output, [25], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Select)
		9:	const_prim(I128)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1958
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_64, 9)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		12: Reg	constructor(put_in_reg_zext64, [8], 1)
		13: Reg	constructor(zero_reg, [], 2)
		14: ProducesFlags	constructor(cmp, [11, 12, 13], 3)
		15: Cond	make_variant(Cond::Ne, [])
		16: Value	match_some(3)
		17: Type	extractor(value_type, 16)
		18: Value	match_tuple(7, 1)
		19: Value	match_tuple(7, 2)
		20: ValueRegs	constructor(lower_select, [14, 15, 17, 18, 19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Select)
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1952
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: OperandSize	make_variant(OperandSize::Size32, [])
		12: Reg	constructor(put_in_reg_zext32, [8], 1)
		13: Reg	constructor(zero_reg, [], 2)
		14: ProducesFlags	constructor(cmp, [11, 12, 13], 3)
		15: Cond	make_variant(Cond::Ne, [])
		16: Value	match_some(3)
		17: Type	extractor(value_type, 16)
		18: Value	match_tuple(7, 1)
		19: Value	match_tuple(7, 2)
		20: ValueRegs	constructor(lower_select, [14, 15, 17, 18, 19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Select)
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1946
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Type	const_prim(I32)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: u64	const_int(255, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [10, 12], 2)
		14: ProducesFlags	constructor(tst_imm, [10, 11, 13], 3)
		15: Cond	make_variant(Cond::Ne, [])
		16: Value	match_some(3)
		17: Type	extractor(value_type, 16)
		18: Value	match_tuple(7, 1)
		19: Value	match_tuple(7, 2)
		20: ValueRegs	constructor(lower_select, [14, 15, 17, 18, 19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Select)
		9:	const_prim(I8)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1937
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::FloatCompare, opcode)
		15: ValueArray2	match_variant(13, InstructionData::FloatCompare, args)
		16: (Value, Value)	extractor(value_array_2, 15)
		17: Value	match_tuple(16, 0)
		18: Type	extractor(value_type, 17)
		19: ScalarSize	constructor(scalar_size, [18], 2)
		20: Reg	constructor(put_in_reg, [17], 3)
		21: Value	match_tuple(16, 1)
		22: Reg	constructor(put_in_reg, [21], 4)
		23: ProducesFlags	constructor(fpu_cmp, [19, 20, 22], 5)
		24: FloatCC	match_variant(13, InstructionData::FloatCompare, cond)
		25: Cond	constructor(fp_cond_code, [24], 1)
		26: Value	match_some(3)
		27: Type	extractor(value_type, 26)
		28: Value	match_tuple(7, 1)
		29: Value	match_tuple(7, 2)
		30: ValueRegs	constructor(lower_select, [23, 25, 27, 28, 29], 6)
		31: InstOutput	constructor(output, [30], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Select)
		9:	some
		11:	some
		13:	variant(InstructionData::FloatCompare)
		14:	variant(Opcode::Fcmp)
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1924
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		7: (Value, Value, Value)	extractor(value_array_3, 6)
		8: Value	match_tuple(7, 0)
		9: Option(Value)	extractor(maybe_uextend, 8)
		10: Value	match_some(9)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::IntCompare, opcode)
		15: IntCC	match_variant(13, InstructionData::IntCompare, cond)
		16: ValueArray2	match_variant(13, InstructionData::IntCompare, args)
		17: (Value, Value)	extractor(value_array_2, 16)
		18: Value	match_tuple(17, 0)
		19: Value	match_tuple(17, 1)
		20: Type	extractor(value_type, 18)
		21: FlagsAndCC	constructor(lower_icmp_into_flags, [15, 18, 19, 20], 1)
		22: ProducesFlags	constructor(flags_and_cc_flags, [21], 2)
		23: IntCC	constructor(flags_and_cc_cc, [21], 3)
		24: Cond	constructor(cond_code, [23], 4)
		25: Value	match_some(3)
		26: Type	extractor(value_type, 25)
		27: Value	match_tuple(7, 1)
		28: Value	match_tuple(7, 2)
		29: ValueRegs	constructor(lower_select, [22, 24, 26, 27, 28], 5)
		30: InstOutput	constructor(output, [29], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Select)
		9:	some
		11:	some
		13:	variant(InstructionData::IntCompare)
		14:	variant(Opcode::Icmp)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1919
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Trap, opcode)
		5: TrapCode	match_variant(3, InstructionData::Trap, code)
		6: SideEffectNoResult	constructor(udf, [5], 1)
		7: InstOutput	constructor(side_effect, [6], 2)
	]
	constraints = [
		3:	variant(InstructionData::Trap)
		4:	variant(Opcode::ResumableTrap)
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1914
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Trap, opcode)
		5: TrapCode	match_variant(3, InstructionData::Trap, code)
		6: SideEffectNoResult	constructor(udf, [5], 1)
		7: InstOutput	constructor(side_effect, [6], 2)
	]
	constraints = [
		3:	variant(InstructionData::Trap)
		4:	variant(Opcode::Trap)
	]
	result = 7
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1909
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::IntCompare, opcode)
		5: IntCC	match_variant(3, InstructionData::IntCompare, cond)
		6: ValueArray2	match_variant(3, InstructionData::IntCompare, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Value	match_tuple(7, 1)
		10: Type	extractor(value_type, 8)
		11: Type	const_prim(I8)
		12: ValueRegs	constructor(lower_icmp_into_reg, [5, 8, 9, 10, 11], 1)
		13: InstOutput	constructor(output, [12], 2)
	]
	constraints = [
		3:	variant(InstructionData::IntCompare)
		4:	variant(Opcode::Icmp)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1903
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::IntCompare, opcode)
		9: IntCC	match_variant(4, InstructionData::IntCompare, cond)
		10: Option(IntCC)	extractor(icmp_zero_cond, 9)
		11: ValueArray2	match_variant(4, InstructionData::IntCompare, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Option(Value)	constructor(zero_value, [13], 0)
		15: IntCC	match_some(10)
		16: Value	match_tuple(12, 1)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(int_cmp_zero_swap, [15, 17, 18], 3)
		20: ValueRegs	constructor(value_reg, [19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::IntCompare)
		7:	some
		8:	variant(Opcode::Icmp)
		10:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1897
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::IntCompare, opcode)
		9: IntCC	match_variant(4, InstructionData::IntCompare, cond)
		10: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 9)
		11: ValueArray2	match_variant(4, InstructionData::IntCompare, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Option(Value)	constructor(zero_value, [13], 0)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [6], 2)
		18: Reg	constructor(cmeq0, [16, 17], 3)
		19: Reg	constructor(not, [18, 17], 4)
		20: ValueRegs	constructor(value_reg, [19], 5)
		21: InstOutput	constructor(output, [20], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::IntCompare)
		7:	some
		8:	variant(Opcode::Icmp)
		10:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1891
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::IntCompare, opcode)
		9: ValueArray2	match_variant(4, InstructionData::IntCompare, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Value)	constructor(zero_value, [11], 0)
		13: IntCC	match_variant(4, InstructionData::IntCompare, cond)
		14: Option(IntCC)	extractor(icmp_zero_cond, 13)
		15: IntCC	match_some(14)
		16: Value	match_tuple(10, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(int_cmp_zero, [15, 17, 18], 3)
		20: ValueRegs	constructor(value_reg, [19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::IntCompare)
		7:	some
		8:	variant(Opcode::Icmp)
		12:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1885
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::IntCompare, opcode)
		9: IntCC	match_variant(4, InstructionData::IntCompare, cond)
		10: Option(IntCC)	extractor(icmp_zero_cond_not_eq, 9)
		11: ValueArray2	match_variant(4, InstructionData::IntCompare, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 1)
		14: Option(Value)	constructor(zero_value, [13], 0)
		15: Value	match_tuple(12, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [6], 2)
		18: Reg	constructor(cmeq0, [16, 17], 3)
		19: Reg	constructor(not, [18, 17], 4)
		20: ValueRegs	constructor(value_reg, [19], 5)
		21: InstOutput	constructor(output, [20], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::IntCompare)
		7:	some
		8:	variant(Opcode::Icmp)
		10:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1879
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::FloatCompare, opcode)
		6: ValueArray2	match_variant(4, InstructionData::FloatCompare, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	constructor(ty_vector_float, [9], 0)
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Value	match_tuple(7, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: FloatCC	match_variant(4, InstructionData::FloatCompare, cond)
		15: Cond	constructor(fp_cond_code, [14], 3)
		16: Reg	constructor(vec_cmp, [11, 13, 9, 15], 4)
		17: InstOutput	constructor(output_reg, [16], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::FloatCompare)
		5:	variant(Opcode::Fcmp)
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1874
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::FloatCompare, opcode)
		6: ValueArray2	match_variant(4, InstructionData::FloatCompare, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(ty_scalar_float, 9)
		11: Type	match_some(10)
		12: ScalarSize	constructor(scalar_size, [11], 1)
		13: Reg	constructor(put_in_reg, [8], 2)
		14: Value	match_tuple(7, 1)
		15: Reg	constructor(put_in_reg, [14], 3)
		16: ProducesFlags	constructor(fpu_cmp, [12, 13, 15], 4)
		17: FloatCC	match_variant(4, InstructionData::FloatCompare, cond)
		18: Cond	constructor(fp_cond_code, [17], 5)
		19: ConsumesFlags	constructor(materialize_bool_result, [18], 6)
		20: ValueRegs	constructor(with_flags, [16, 19], 7)
		21: InstOutput	constructor(output, [20], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::FloatCompare)
		5:	variant(Opcode::Fcmp)
		10:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1868
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::FloatCompare, opcode)
		9: FloatCC	match_variant(4, InstructionData::FloatCompare, cond)
		10: Option(FloatCC)	extractor(fcmp_zero_cond, 9)
		11: ValueArray2	match_variant(4, InstructionData::FloatCompare, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Option(Value)	constructor(zero_value, [13], 0)
		15: FloatCC	match_some(10)
		16: Value	match_tuple(12, 1)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(float_cmp_zero_swap, [15, 17, 18], 3)
		20: ValueRegs	constructor(value_reg, [19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::FloatCompare)
		7:	some
		8:	variant(Opcode::Fcmp)
		10:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1862
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::FloatCompare, opcode)
		9: FloatCC	match_variant(4, InstructionData::FloatCompare, cond)
		10: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 9)
		11: ValueArray2	match_variant(4, InstructionData::FloatCompare, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Option(Value)	constructor(zero_value, [13], 0)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [6], 2)
		18: Reg	constructor(fcmeq0, [16, 17], 3)
		19: Reg	constructor(not, [18, 17], 4)
		20: ValueRegs	constructor(value_reg, [19], 5)
		21: InstOutput	constructor(output, [20], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::FloatCompare)
		7:	some
		8:	variant(Opcode::Fcmp)
		10:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1856
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::FloatCompare, opcode)
		9: ValueArray2	match_variant(4, InstructionData::FloatCompare, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Value)	constructor(zero_value, [11], 0)
		13: FloatCC	match_variant(4, InstructionData::FloatCompare, cond)
		14: Option(FloatCC)	extractor(fcmp_zero_cond, 13)
		15: FloatCC	match_some(14)
		16: Value	match_tuple(10, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(float_cmp_zero, [15, 17, 18], 3)
		20: ValueRegs	constructor(value_reg, [19], 4)
		21: InstOutput	constructor(output, [20], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::FloatCompare)
		7:	some
		8:	variant(Opcode::Fcmp)
		12:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1850
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::FloatCompare, opcode)
		9: FloatCC	match_variant(4, InstructionData::FloatCompare, cond)
		10: Option(FloatCC)	extractor(fcmp_zero_cond_not_eq, 9)
		11: ValueArray2	match_variant(4, InstructionData::FloatCompare, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 1)
		14: Option(Value)	constructor(zero_value, [13], 0)
		15: Value	match_tuple(12, 0)
		16: Reg	constructor(put_in_reg, [15], 1)
		17: VectorSize	constructor(vector_size, [6], 2)
		18: Reg	constructor(fcmeq0, [16, 17], 3)
		19: Reg	constructor(not, [18, 17], 4)
		20: ValueRegs	constructor(value_reg, [19], 5)
		21: InstOutput	constructor(output, [20], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::FloatCompare)
		7:	some
		8:	variant(Opcode::Fcmp)
		10:	some
		14:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1844
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Ireduce)
		8:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1836
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: Type	match_some(8)
		10: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		11: (Value, Value, Value)	extractor(value_array_3, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Value	match_tuple(11, 2)
		17: Reg	constructor(put_in_reg, [16], 3)
		18: Reg	constructor(bsl, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Bitselect)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1830
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	constructor(ty_int_ref_scalar_64, [7], 0)
		9: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		10: (Value, Value, Value)	extractor(value_array_3, 9)
		11: Value	match_tuple(10, 1)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 0)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(and_reg, [7, 12, 14], 3)
		16: Value	match_tuple(10, 2)
		17: Reg	constructor(put_in_reg, [16], 4)
		18: Reg	constructor(put_in_reg, [13], 5)
		19: Reg	constructor(bic, [7, 17, 18], 6)
		20: Reg	constructor(orr, [7, 15, 19], 7)
		21: InstOutput	constructor(output_reg, [20], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		5:	variant(Opcode::Bitselect)
		8:	some
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1825
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: VectorSize	make_variant(VectorSize::Size8x16, [])
		11: Reg	constructor(vec_cnt, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I8X16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Popcnt)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1817
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: usize	const_int(0, usize)
		11: Reg	constructor(value_regs_get, [9, 10], 2)
		12: ScalarSize	make_variant(ScalarSize::Size64, [])
		13: Reg	constructor(mov_to_fpu, [11, 12], 3)
		14: usize	const_int(1, usize)
		15: Reg	constructor(value_regs_get, [9, 14], 4)
		16: u8	const_int(1, u8)
		17: VectorSize	make_variant(VectorSize::Size64x2, [])
		18: Reg	constructor(mov_to_vec, [13, 15, 16, 17], 5)
		19: VectorSize	make_variant(VectorSize::Size8x16, [])
		20: Reg	constructor(vec_cnt, [18, 19], 6)
		21: Reg	constructor(addv, [20, 19], 7)
		22: u8	const_int(0, u8)
		23: ScalarSize	make_variant(ScalarSize::Size8, [])
		24: Reg	constructor(mov_from_vec, [21, 22, 23], 8)
		25: Type	const_prim(I64)
		26: ImmExtend	make_variant(ImmExtend::Zero, [])
		27: u64	const_int(0, u64)
		28: Reg	constructor(imm, [25, 26, 27], 9)
		29: ValueRegs	constructor(value_regs, [24, 28], 10)
		30: InstOutput	constructor(output, [29], 11)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Popcnt)
	]
	result = 30
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1811
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: Reg	constructor(mov_to_fpu, [9, 10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		13: Reg	constructor(vec_cnt, [11, 12], 3)
		14: Reg	constructor(addv, [13, 12], 4)
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 5)
		18: InstOutput	constructor(output_reg, [17], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Popcnt)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1805
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Reg	constructor(mov_to_fpu, [9, 10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		13: Reg	constructor(vec_cnt, [11, 12], 3)
		14: Reg	constructor(addv, [13, 12], 4)
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 5)
		18: InstOutput	constructor(output_reg, [17], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Popcnt)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1799
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Reg	constructor(mov_to_fpu, [9, 10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		13: Reg	constructor(vec_cnt, [11, 12], 3)
		14: Reg	constructor(addp, [13, 13, 12], 4)
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size8, [])
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 5)
		18: InstOutput	constructor(output_reg, [17], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Popcnt)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1793
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Reg	constructor(mov_to_fpu, [9, 10], 2)
		12: VectorSize	make_variant(VectorSize::Size8x8, [])
		13: Reg	constructor(vec_cnt, [11, 12], 3)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size8, [])
		16: Reg	constructor(mov_from_vec, [13, 14, 15], 4)
		17: InstOutput	constructor(output_reg, [16], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Popcnt)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1771
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Value	match_variant(4, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: ValueRegs	constructor(put_in_regs, [8], 1)
		11: ValueRegs	constructor(lower_bmask, [7, 9, 10], 2)
		12: InstOutput	constructor(output, [11], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Bmask)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1763
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: Reg	constructor(a64_rev64, [8, 12], 3)
		14: ValueRegs	constructor(put_in_regs, [9], 4)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 5)
		17: Reg	constructor(a64_rev64, [8, 16], 6)
		18: ValueRegs	constructor(value_regs, [13, 17], 7)
		19: InstOutput	constructor(output, [18], 8)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bswap)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1760
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(a64_rev64, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bswap)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1757
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(a64_rev32, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bswap)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1754
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I16)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(a64_rev16, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bswap)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1749
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Value	match_variant(4, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(a64_cls, [7, 9], 2)
		11: InstOutput	constructor(output_reg, [10], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Cls)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1735
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 3)
		13: Reg	constructor(a64_cls, [8, 12], 5)
		14: u8	const_int(63, u8)
		15: Imm12	constructor(u8_into_imm12, [14], 10)
		16: ProducesFlags	constructor(cmp64_imm, [13, 15], 11)
		17: Cond	make_variant(Cond::Eq, [])
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [10, 18], 2)
		20: Reg	constructor(a64_cls, [8, 19], 4)
		21: Reg	constructor(eon, [8, 12, 19], 6)
		22: ImmShift	constructor(imm_shift_from_u8, [14], 7)
		23: Reg	constructor(lsr_imm, [8, 21, 22], 8)
		24: Reg	constructor(madd, [8, 20, 23, 23], 9)
		25: Reg	constructor(zero_reg, [], 12)
		26: ConsumesFlags	constructor(csel, [17, 24, 25], 13)
		27: Reg	constructor(with_flags_reg, [16, 26], 14)
		28: Reg	constructor(add, [8, 27, 13], 15)
		29: ImmExtend	make_variant(ImmExtend::Zero, [])
		30: u64	const_int(0, u64)
		31: Reg	constructor(imm, [8, 29, 30], 16)
		32: ValueRegs	constructor(value_regs, [28, 31], 17)
		33: InstOutput	constructor(output, [32], 18)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Cls)
	]
	result = 33
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1723
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg_sext32, [9], 1)
		11: Reg	constructor(a64_cls, [8, 10], 2)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		14: Reg	constructor(sub_imm, [8, 11, 13], 4)
		15: InstOutput	constructor(output_reg, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Cls)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1720
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg_sext32, [9], 1)
		11: Reg	constructor(a64_cls, [8, 10], 2)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		14: Reg	constructor(sub_imm, [8, 11, 13], 4)
		15: InstOutput	constructor(output_reg, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Cls)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1715
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Value	match_variant(4, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(rbit, [7, 9], 2)
		11: Reg	constructor(a64_clz, [7, 10], 3)
		12: InstOutput	constructor(output_reg, [11], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Ctz)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1709
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 4)
		13: Reg	constructor(rbit, [8, 12], 5)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [10, 14], 2)
		16: Reg	constructor(rbit, [8, 15], 3)
		17: ValueRegs	constructor(value_regs, [13, 16], 6)
		18: ValueRegs	constructor(lower_clz128, [17], 7)
		19: InstOutput	constructor(output, [18], 8)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Ctz)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1706
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(rbit, [8, 10], 2)
		12: u64	const_int(32768, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [8, 12], 3)
		14: Reg	constructor(orr_imm, [8, 11, 13], 4)
		15: Reg	constructor(a64_clz, [8, 14], 5)
		16: InstOutput	constructor(output_reg, [15], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Ctz)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1703
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(rbit, [8, 10], 2)
		12: u64	const_int(8388608, u64)
		13: ImmLogic	constructor(u64_into_imm_logic, [8, 12], 3)
		14: Reg	constructor(orr_imm, [8, 11, 13], 4)
		15: Reg	constructor(a64_clz, [8, 14], 5)
		16: InstOutput	constructor(output_reg, [15], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Ctz)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1682
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Value	match_variant(4, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(a64_clz, [7, 9], 2)
		11: InstOutput	constructor(output_reg, [10], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Clz)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1679
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: ValueRegs	constructor(put_in_regs, [8], 1)
		10: ValueRegs	constructor(lower_clz128, [9], 2)
		11: InstOutput	constructor(output, [10], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Clz)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1676
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg_zext32, [9], 1)
		11: Reg	constructor(a64_clz, [8, 10], 2)
		12: u8	const_int(16, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		14: Reg	constructor(sub_imm, [8, 11, 13], 4)
		15: InstOutput	constructor(output_reg, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Clz)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1673
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg_zext32, [9], 1)
		11: Reg	constructor(a64_clz, [8, 10], 2)
		12: u8	const_int(24, u8)
		13: Imm12	constructor(u8_into_imm12, [12], 3)
		14: Reg	constructor(sub_imm, [8, 11, 13], 4)
		15: InstOutput	constructor(output_reg, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Clz)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1667
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Value	match_variant(4, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Reg	constructor(rbit, [7, 9], 2)
		11: InstOutput	constructor(output_reg, [10], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Bitrev)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1661
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 4)
		13: Reg	constructor(rbit, [8, 12], 5)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [10, 14], 2)
		16: Reg	constructor(rbit, [8, 15], 3)
		17: ValueRegs	constructor(value_regs, [13, 16], 6)
		18: InstOutput	constructor(output, [17], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bitrev)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1658
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(rbit, [8, 10], 2)
		12: u8	const_int(16, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		14: Reg	constructor(lsr_imm, [8, 11, 13], 4)
		15: InstOutput	constructor(output_reg, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I16)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bitrev)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1652
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I32)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(rbit, [8, 10], 2)
		12: u8	const_int(24, u8)
		13: ImmShift	constructor(imm_shift_from_u8, [12], 3)
		14: Reg	constructor(lsr_imm, [8, 11, 13], 4)
		15: InstOutput	constructor(output_reg, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I8)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bitrev)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1637
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: ValueRegs	constructor(put_in_regs, [11], 1)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		17: ValueRegs	constructor(lower_ushr128, [12, 16], 6)
		18: Reg	constructor(value_regs_get, [17, 15], 11)
		19: ImmExtend	make_variant(ImmExtend::Zero, [])
		20: u64	const_int(128, u64)
		21: Reg	constructor(imm, [8, 19, 20], 4)
		22: Reg	constructor(sub, [8, 21, 16], 5)
		23: ValueRegs	constructor(lower_shl128, [12, 22], 7)
		24: Reg	constructor(value_regs_get, [23, 15], 12)
		25: Reg	constructor(orr, [8, 18, 24], 13)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [17, 26], 8)
		28: Reg	constructor(value_regs_get, [23, 26], 9)
		29: Reg	constructor(orr, [8, 27, 28], 10)
		30: ValueRegs	constructor(value_regs, [25, 29], 14)
		31: InstOutput	constructor(output, [30], 15)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotr)
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1588
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::UnaryImm, opcode)
		15: Type	const_prim(I64)
		16: Imm64	match_variant(13, InstructionData::UnaryImm, imm)
		17: Option(ImmShift)	constructor(imm_shift_from_imm64, [15, 16], 0)
		18: Value	match_tuple(9, 0)
		19: Reg	constructor(put_in_reg, [18], 1)
		20: ImmShift	match_some(17)
		21: Reg	constructor(a64_rotr_imm, [15, 19, 20], 2)
		22: InstOutput	constructor(output_reg, [21], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotr)
		11:	some
		13:	variant(InstructionData::UnaryImm)
		14:	variant(Opcode::Iconst)
		17:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1583
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::UnaryImm, opcode)
		15: Type	const_prim(I32)
		16: Imm64	match_variant(13, InstructionData::UnaryImm, imm)
		17: Option(ImmShift)	constructor(imm_shift_from_imm64, [15, 16], 0)
		18: Value	match_tuple(9, 0)
		19: Reg	constructor(put_in_reg, [18], 1)
		20: ImmShift	match_some(17)
		21: Reg	constructor(a64_rotr_imm, [15, 19, 20], 2)
		22: InstOutput	constructor(output_reg, [21], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotr)
		11:	some
		13:	variant(InstructionData::UnaryImm)
		14:	variant(Opcode::Iconst)
		17:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1578
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(fits_in_16, 14)
		16: Type	match_some(15)
		17: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		18: Option(ImmShift)	constructor(imm_shift_from_imm64, [16, 17], 0)
		19: Value	match_tuple(7, 0)
		20: Reg	constructor(put_in_reg_zext32, [19], 1)
		21: ImmShift	match_some(18)
		22: Reg	constructor(small_rotr_imm, [16, 20, 21], 2)
		23: InstOutput	constructor(output_reg, [22], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Rotr)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
		18:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1574
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		17: Reg	constructor(a64_rotr, [8, 12, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotr)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1570
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I32)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		17: Reg	constructor(a64_rotr, [8, 12, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotr)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1566
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext32, [12], 1)
		14: Value	match_tuple(11, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 2)
		16: usize	const_int(0, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 3)
		18: Reg	constructor(small_rotr, [9, 13, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Rotr)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1553
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: ValueRegs	constructor(put_in_regs, [11], 1)
		13: Value	match_tuple(10, 1)
		14: ValueRegs	constructor(put_in_regs, [13], 2)
		15: usize	const_int(0, usize)
		16: Reg	constructor(value_regs_get, [14, 15], 3)
		17: ValueRegs	constructor(lower_shl128, [12, 16], 6)
		18: Reg	constructor(value_regs_get, [17, 15], 8)
		19: ImmExtend	make_variant(ImmExtend::Zero, [])
		20: u64	const_int(128, u64)
		21: Reg	constructor(imm, [8, 19, 20], 4)
		22: Reg	constructor(sub, [8, 21, 16], 5)
		23: ValueRegs	constructor(lower_ushr128, [12, 22], 7)
		24: Reg	constructor(value_regs_get, [23, 15], 9)
		25: Reg	constructor(orr, [8, 18, 24], 10)
		26: usize	const_int(1, usize)
		27: Reg	constructor(value_regs_get, [17, 26], 11)
		28: Reg	constructor(value_regs_get, [23, 26], 12)
		29: Reg	constructor(orr, [8, 27, 28], 13)
		30: ValueRegs	constructor(value_regs, [25, 29], 14)
		31: InstOutput	constructor(output, [30], 15)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotl)
	]
	result = 31
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1543
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::UnaryImm, opcode)
		15: Type	const_prim(I64)
		16: Imm64	match_variant(13, InstructionData::UnaryImm, imm)
		17: Option(ImmShift)	constructor(imm_shift_from_imm64, [15, 16], 0)
		18: Value	match_tuple(9, 0)
		19: Reg	constructor(put_in_reg, [18], 1)
		20: ImmShift	match_some(17)
		21: ImmShift	constructor(negate_imm_shift, [15, 20], 2)
		22: Reg	constructor(a64_rotr_imm, [15, 19, 21], 3)
		23: InstOutput	constructor(output_reg, [22], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotl)
		11:	some
		13:	variant(InstructionData::UnaryImm)
		14:	variant(Opcode::Iconst)
		17:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1538
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::UnaryImm, opcode)
		15: Type	const_prim(I32)
		16: Imm64	match_variant(13, InstructionData::UnaryImm, imm)
		17: Option(ImmShift)	constructor(imm_shift_from_imm64, [15, 16], 0)
		18: Value	match_tuple(9, 0)
		19: Reg	constructor(put_in_reg, [18], 1)
		20: ImmShift	match_some(17)
		21: ImmShift	constructor(negate_imm_shift, [15, 20], 2)
		22: Reg	constructor(a64_rotr_imm, [15, 19, 21], 3)
		23: InstOutput	constructor(output_reg, [22], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotl)
		11:	some
		13:	variant(InstructionData::UnaryImm)
		14:	variant(Opcode::Iconst)
		17:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1532
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 5)
		13: Reg	constructor(zero_reg, [], 3)
		14: Value	match_tuple(10, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 1)
		16: usize	const_int(0, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 2)
		18: Reg	constructor(sub, [8, 13, 17], 4)
		19: Reg	constructor(a64_rotr, [8, 12, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotl)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1526
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I32)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 5)
		13: Reg	constructor(zero_reg, [], 3)
		14: Value	match_tuple(10, 1)
		15: ValueRegs	constructor(put_in_regs, [14], 1)
		16: usize	const_int(0, usize)
		17: Reg	constructor(value_regs_get, [15, 16], 2)
		18: Reg	constructor(sub, [8, 13, 17], 4)
		19: Reg	constructor(a64_rotr, [8, 12, 18], 6)
		20: InstOutput	constructor(output_reg, [19], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I32)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Rotl)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1513
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(fits_in_16, 14)
		16: Type	match_some(15)
		17: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		18: Option(ImmShift)	constructor(imm_shift_from_imm64, [16, 17], 0)
		19: Value	match_tuple(7, 0)
		20: Reg	constructor(put_in_reg_zext32, [19], 1)
		21: ImmShift	match_some(18)
		22: ImmShift	constructor(negate_imm_shift, [16, 21], 2)
		23: Reg	constructor(small_rotr_imm, [16, 20, 22], 3)
		24: InstOutput	constructor(output_reg, [23], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Rotl)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
		18:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1507
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_16, 7)
		9: Type	match_some(8)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext32, [12], 5)
		14: Type	const_prim(I32)
		15: Reg	constructor(zero_reg, [], 3)
		16: Value	match_tuple(11, 1)
		17: ValueRegs	constructor(put_in_regs, [16], 1)
		18: usize	const_int(0, usize)
		19: Reg	constructor(value_regs_get, [17, 18], 2)
		20: Reg	constructor(sub, [14, 15, 19], 4)
		21: Reg	constructor(small_rotr, [9, 13, 20], 6)
		22: InstOutput	constructor(output_reg, [21], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Rotl)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1471
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Type	match_some(15)
		17: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: Value	match_tuple(7, 0)
		21: InstOutput	constructor(output_value, [20], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Sshr)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
		19:	const_int(0)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1469
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Value	match_tuple(7, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Type	match_some(15)
		19: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		20: u64	extractor(u64_from_imm64, 19)
		21: u8	constructor(shift_masked_imm, [18, 20], 0)
		22: VectorSize	constructor(vector_size, [18], 2)
		23: Reg	constructor(sshr_vec_imm, [17, 21, 22], 3)
		24: InstOutput	constructor(output_reg, [23], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Sshr)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1464
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 8)
		13: Type	const_prim(I64)
		14: Reg	constructor(zero_reg, [], 5)
		15: Type	const_prim(I32)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(8)
		19: ImmLogic	constructor(shift_mask, [18], 3)
		20: Reg	constructor(and_imm, [15, 17, 19], 4)
		21: Reg	constructor(sub, [13, 14, 20], 6)
		22: VectorSize	constructor(vector_size, [18], 1)
		23: Reg	constructor(vec_dup, [21, 22], 7)
		24: Reg	constructor(sshl, [12, 23, 22], 9)
		25: InstOutput	constructor(output_reg, [24], 10)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Sshr)
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1455
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: ValueRegs	constructor(lower_sshr128, [11, 15], 4)
		17: InstOutput	constructor(output, [16], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Sshr)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1451
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ALUOp	make_variant(ALUOp::Asr, [])
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_sext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [8, 9, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Sshr)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1447
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: ALUOp	make_variant(ALUOp::Asr, [])
		10: Type	match_some(8)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg_sext32, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(do_shift, [9, 10, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Sshr)
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1413
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Type	match_some(15)
		17: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		18: u64	extractor(u64_from_imm64, 17)
		19: u8	constructor(shift_masked_imm, [16, 18], 0)
		20: Value	match_tuple(7, 0)
		21: InstOutput	constructor(output_value, [20], 1)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ushr)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
		19:	const_int(0)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1411
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Value	match_tuple(7, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Type	match_some(15)
		19: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		20: u64	extractor(u64_from_imm64, 19)
		21: u8	constructor(shift_masked_imm, [18, 20], 0)
		22: VectorSize	constructor(vector_size, [18], 2)
		23: Reg	constructor(ushr_vec_imm, [17, 21, 22], 3)
		24: InstOutput	constructor(output_reg, [23], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ushr)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1406
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 8)
		13: Type	const_prim(I64)
		14: Reg	constructor(zero_reg, [], 5)
		15: Type	const_prim(I32)
		16: Value	match_tuple(10, 1)
		17: Reg	constructor(put_in_reg, [16], 2)
		18: Type	match_some(8)
		19: ImmLogic	constructor(shift_mask, [18], 3)
		20: Reg	constructor(and_imm, [15, 17, 19], 4)
		21: Reg	constructor(sub, [13, 14, 20], 6)
		22: VectorSize	constructor(vector_size, [18], 1)
		23: Reg	constructor(vec_dup, [21, 22], 7)
		24: Reg	constructor(ushl, [12, 23, 22], 9)
		25: InstOutput	constructor(output_reg, [24], 10)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ushr)
		8:	some
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1398
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: ValueRegs	constructor(lower_ushr128, [11, 15], 4)
		17: InstOutput	constructor(output, [16], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Ushr)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1394
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ALUOp	make_variant(ALUOp::Lsr, [])
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [8, 9, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Ushr)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1390
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: ALUOp	make_variant(ALUOp::Lsr, [])
		10: Type	match_some(8)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg_zext32, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(do_shift, [9, 10, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ushr)
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1342
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::UnaryImm, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Value	match_tuple(7, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Type	match_some(15)
		19: Imm64	match_variant(11, InstructionData::UnaryImm, imm)
		20: u64	extractor(u64_from_imm64, 19)
		21: u8	constructor(shift_masked_imm, [18, 20], 0)
		22: VectorSize	constructor(vector_size, [18], 2)
		23: Reg	constructor(ushl_vec_imm, [17, 21, 22], 3)
		24: InstOutput	constructor(output_reg, [23], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ishl)
		9:	some
		11:	variant(InstructionData::UnaryImm)
		12:	variant(Opcode::Iconst)
		15:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1337
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 6)
		13: Type	const_prim(I32)
		14: Value	match_tuple(10, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ImmLogic	constructor(shift_mask, [16], 3)
		18: Reg	constructor(and_imm, [13, 15, 17], 4)
		19: VectorSize	constructor(vector_size, [16], 1)
		20: Reg	constructor(vec_dup, [18, 19], 5)
		21: Reg	constructor(sshl, [12, 20, 19], 7)
		22: InstOutput	constructor(output_reg, [21], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ishl)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1307
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: usize	const_int(0, usize)
		15: Reg	constructor(value_regs_get, [13, 14], 3)
		16: ValueRegs	constructor(lower_shl128, [11, 15], 4)
		17: InstOutput	constructor(output, [16], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Ishl)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1303
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ALUOp	make_variant(ALUOp::Lsl, [])
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(do_shift, [8, 9, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Ishl)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1299
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: ALUOp	make_variant(ALUOp::Lsl, [])
		10: Type	match_some(8)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(do_shift, [9, 10, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Ishl)
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1294
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::Unary, opcode)
		15: ALUOp	make_variant(ALUOp::EorNot, [])
		16: Type	const_prim(I64)
		17: Value	match_tuple(9, 1)
		18: Value	match_variant(13, InstructionData::Unary, arg)
		19: ValueRegs	constructor(i128_alu_bitop, [15, 16, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Bxor)
		11:	some
		13:	variant(InstructionData::Unary)
		14:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1293
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::Unary, opcode)
		15: ALUOp	make_variant(ALUOp::EorNot, [])
		16: Type	const_prim(I64)
		17: Value	match_tuple(9, 0)
		18: Value	match_variant(13, InstructionData::Unary, arg)
		19: ValueRegs	constructor(i128_alu_bitop, [15, 16, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Bxor)
		11:	some
		13:	variant(InstructionData::Unary)
		14:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1290
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Unary, opcode)
		16: ALUOp	make_variant(ALUOp::EorNot, [])
		17: Type	match_some(7)
		18: Value	match_tuple(10, 1)
		19: Value	match_variant(14, InstructionData::Unary, arg)
		20: Reg	constructor(alu_rs_imm_logic, [16, 17, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Bxor)
		12:	some
		14:	variant(InstructionData::Unary)
		15:	variant(Opcode::Bnot)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1288
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Unary, opcode)
		16: ALUOp	make_variant(ALUOp::EorNot, [])
		17: Type	match_some(7)
		18: Value	match_tuple(10, 0)
		19: Value	match_variant(14, InstructionData::Unary, arg)
		20: Reg	constructor(alu_rs_imm_logic, [16, 17, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Bxor)
		12:	some
		14:	variant(InstructionData::Unary)
		15:	variant(Opcode::Bnot)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1281
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(eor_vec, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Bxor)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1279
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ALUOp	make_variant(ALUOp::Eor, [])
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ValueRegs	constructor(i128_alu_bitop, [8, 9, 12, 13], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Bxor)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1276
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ALUOp	make_variant(ALUOp::Eor, [])
		10: Type	match_some(7)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Value	match_tuple(12, 1)
		15: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 13, 14], 1)
		16: InstOutput	constructor(output_reg, [15], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Bxor)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1272
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::Unary, opcode)
		15: ALUOp	make_variant(ALUOp::OrrNot, [])
		16: Type	const_prim(I64)
		17: Value	match_tuple(9, 1)
		18: Value	match_variant(13, InstructionData::Unary, arg)
		19: ValueRegs	constructor(i128_alu_bitop, [15, 16, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Bor)
		11:	some
		13:	variant(InstructionData::Unary)
		14:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1271
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::Unary, opcode)
		15: ALUOp	make_variant(ALUOp::OrrNot, [])
		16: Type	const_prim(I64)
		17: Value	match_tuple(9, 0)
		18: Value	match_variant(13, InstructionData::Unary, arg)
		19: ValueRegs	constructor(i128_alu_bitop, [15, 16, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Bor)
		11:	some
		13:	variant(InstructionData::Unary)
		14:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1268
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Unary, opcode)
		16: ALUOp	make_variant(ALUOp::OrrNot, [])
		17: Type	match_some(7)
		18: Value	match_tuple(10, 1)
		19: Value	match_variant(14, InstructionData::Unary, arg)
		20: Reg	constructor(alu_rs_imm_logic, [16, 17, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Bor)
		12:	some
		14:	variant(InstructionData::Unary)
		15:	variant(Opcode::Bnot)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1266
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Unary, opcode)
		16: ALUOp	make_variant(ALUOp::OrrNot, [])
		17: Type	match_some(7)
		18: Value	match_tuple(10, 0)
		19: Value	match_variant(14, InstructionData::Unary, arg)
		20: Reg	constructor(alu_rs_imm_logic, [16, 17, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Bor)
		12:	some
		14:	variant(InstructionData::Unary)
		15:	variant(Opcode::Bnot)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1259
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(orr_vec, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Bor)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1257
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ALUOp	make_variant(ALUOp::Orr, [])
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ValueRegs	constructor(i128_alu_bitop, [8, 9, 12, 13], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Bor)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1254
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ALUOp	make_variant(ALUOp::Orr, [])
		10: Type	match_some(7)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Value	match_tuple(12, 1)
		15: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 13, 14], 1)
		16: InstOutput	constructor(output_reg, [15], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Bor)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1249
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::Unary, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Value	match_tuple(7, 1)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_variant(11, InstructionData::Unary, arg)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Type	match_some(15)
		21: VectorSize	constructor(vector_size, [20], 3)
		22: Reg	constructor(bic_vec, [17, 19, 21], 4)
		23: InstOutput	constructor(output_reg, [22], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Band)
		9:	some
		11:	variant(InstructionData::Unary)
		12:	variant(Opcode::Bnot)
		15:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1247
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 1)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::Unary, opcode)
		13: Value	match_some(3)
		14: Type	extractor(value_type, 13)
		15: Option(Type)	extractor(ty_vec128, 14)
		16: Value	match_tuple(7, 0)
		17: Reg	constructor(put_in_reg, [16], 1)
		18: Value	match_variant(11, InstructionData::Unary, arg)
		19: Reg	constructor(put_in_reg, [18], 2)
		20: Type	match_some(15)
		21: VectorSize	constructor(vector_size, [20], 3)
		22: Reg	constructor(bic_vec, [17, 19, 21], 4)
		23: InstOutput	constructor(output_reg, [22], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Band)
		9:	some
		11:	variant(InstructionData::Unary)
		12:	variant(Opcode::Bnot)
		15:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1245
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::Unary, opcode)
		15: ALUOp	make_variant(ALUOp::AndNot, [])
		16: Type	const_prim(I64)
		17: Value	match_tuple(9, 1)
		18: Value	match_variant(13, InstructionData::Unary, arg)
		19: ValueRegs	constructor(i128_alu_bitop, [15, 16, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Band)
		11:	some
		13:	variant(InstructionData::Unary)
		14:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1244
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Opcode	match_variant(13, InstructionData::Unary, opcode)
		15: ALUOp	make_variant(ALUOp::AndNot, [])
		16: Type	const_prim(I64)
		17: Value	match_tuple(9, 0)
		18: Value	match_variant(13, InstructionData::Unary, arg)
		19: ValueRegs	constructor(i128_alu_bitop, [15, 16, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Band)
		11:	some
		13:	variant(InstructionData::Unary)
		14:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1241
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Unary, opcode)
		16: ALUOp	make_variant(ALUOp::AndNot, [])
		17: Type	match_some(7)
		18: Value	match_tuple(10, 1)
		19: Value	match_variant(14, InstructionData::Unary, arg)
		20: Reg	constructor(alu_rs_imm_logic, [16, 17, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Band)
		12:	some
		14:	variant(InstructionData::Unary)
		15:	variant(Opcode::Bnot)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1239
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Unary, opcode)
		16: ALUOp	make_variant(ALUOp::AndNot, [])
		17: Type	match_some(7)
		18: Value	match_tuple(10, 0)
		19: Value	match_variant(14, InstructionData::Unary, arg)
		20: Reg	constructor(alu_rs_imm_logic, [16, 17, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Band)
		12:	some
		14:	variant(InstructionData::Unary)
		15:	variant(Opcode::Bnot)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1232
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(and_vec, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Band)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1230
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ALUOp	make_variant(ALUOp::And, [])
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: ValueRegs	constructor(i128_alu_bitop, [8, 9, 12, 13], 1)
		15: InstOutput	constructor(output, [14], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Band)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1227
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ALUOp	make_variant(ALUOp::And, [])
		10: Type	match_some(7)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Value	match_tuple(12, 1)
		15: Reg	constructor(alu_rs_imm_logic_commutative, [9, 10, 13, 14], 1)
		16: InstOutput	constructor(output_reg, [15], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Band)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1223
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::Binary, opcode)
		13: ALUOp	make_variant(ALUOp::EorNot, [])
		14: Type	const_prim(I64)
		15: ValueArray2	match_variant(11, InstructionData::Binary, args)
		16: (Value, Value)	extractor(value_array_2, 15)
		17: Value	match_tuple(16, 0)
		18: Value	match_tuple(16, 1)
		19: ValueRegs	constructor(i128_alu_bitop, [13, 14, 17, 18], 1)
		20: InstOutput	constructor(output, [19], 2)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bnot)
		9:	some
		11:	variant(InstructionData::Binary)
		12:	variant(Opcode::Bxor)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1221
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: InstructionData	extractor(inst_data, 11)
		13: Opcode	match_variant(12, InstructionData::Binary, opcode)
		14: ALUOp	make_variant(ALUOp::EorNot, [])
		15: Type	match_some(7)
		16: ValueArray2	match_variant(12, InstructionData::Binary, args)
		17: (Value, Value)	extractor(value_array_2, 16)
		18: Value	match_tuple(17, 0)
		19: Value	match_tuple(17, 1)
		20: Reg	constructor(alu_rs_imm_logic, [14, 15, 18, 19], 1)
		21: InstOutput	constructor(output_reg, [20], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Bnot)
		10:	some
		12:	variant(InstructionData::Binary)
		13:	variant(Opcode::Bxor)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1217
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(8)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: Reg	constructor(not, [10, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Bnot)
		8:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1208
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Reg	constructor(zero_reg, [], 4)
		10: Value	match_variant(6, InstructionData::Unary, arg)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: usize	const_int(0, usize)
		13: Reg	constructor(value_regs_get, [11, 12], 2)
		14: Reg	constructor(orr_not, [8, 9, 13], 5)
		15: Reg	constructor(zero_reg, [], 6)
		16: usize	const_int(1, usize)
		17: Reg	constructor(value_regs_get, [11, 16], 3)
		18: Reg	constructor(orr_not, [8, 15, 17], 7)
		19: ValueRegs	constructor(value_regs, [14, 18], 8)
		20: InstOutput	constructor(output, [19], 9)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Bnot)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1202
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: InstructionData	extractor(inst_data, 11)
		13: Opcode	match_variant(12, InstructionData::Binary, opcode)
		14: ValueArray2	match_variant(12, InstructionData::Binary, args)
		15: (Value, Value)	extractor(value_array_2, 14)
		16: Value	match_tuple(15, 1)
		17: Option(Inst)	extractor(def_inst, 16)
		18: Inst	match_some(17)
		19: InstructionData	extractor(inst_data, 18)
		20: Opcode	match_variant(19, InstructionData::UnaryImm, opcode)
		21: Type	match_some(7)
		22: Imm64	match_variant(19, InstructionData::UnaryImm, imm)
		23: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [21, 22], 0)
		24: Reg	constructor(zero_reg, [], 1)
		25: Value	match_tuple(15, 0)
		26: Reg	constructor(put_in_reg, [25], 2)
		27: ShiftOpAndAmt	match_some(23)
		28: Reg	constructor(orr_not_shift, [21, 24, 26, 27], 3)
		29: InstOutput	constructor(output_reg, [28], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Bnot)
		10:	some
		12:	variant(InstructionData::Binary)
		13:	variant(Opcode::Ishl)
		17:	some
		19:	variant(InstructionData::UnaryImm)
		20:	variant(Opcode::Iconst)
		23:	some
	]
	result = 29
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1197
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Type	match_some(7)
		10: Reg	constructor(zero_reg, [], 1)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(orr_not, [9, 10, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Bnot)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1181
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::BinaryImm8, opcode)
		13: Value	match_variant(11, InstructionData::BinaryImm8, arg)
		14: Type	extractor(value_type, 13)
		15: Reg	constructor(put_in_reg, [13], 1)
		16: Uimm8	match_variant(11, InstructionData::BinaryImm8, imm)
		17: u8	extractor(u8_from_uimm8, 16)
		18: ScalarSize	make_variant(ScalarSize::Size64, [])
		19: Reg	constructor(mov_from_vec, [15, 17, 18], 2)
		20: Type	const_prim(I64)
		21: u8	const_int(63, u8)
		22: ImmShift	constructor(imm_shift_from_u8, [21], 3)
		23: Reg	constructor(asr_imm, [20, 19, 22], 4)
		24: ValueRegs	constructor(value_regs, [19, 23], 5)
		25: InstOutput	constructor(output, [24], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Sextend)
		9:	some
		11:	variant(InstructionData::BinaryImm8)
		12:	variant(Opcode::Extractlane)
		14:	const_prim(I64X2)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1170
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::BinaryImm8, opcode)
		13: Value	match_variant(11, InstructionData::BinaryImm8, arg)
		14: Type	extractor(value_type, 13)
		15: Option(())	extractor(not_i64x2, 14)
		16: Reg	constructor(put_in_reg, [13], 1)
		17: Uimm8	match_variant(11, InstructionData::BinaryImm8, imm)
		18: u8	extractor(u8_from_uimm8, 17)
		19: VectorSize	constructor(vector_size, [14], 2)
		20: Type	const_prim(I64)
		21: OperandSize	constructor(size_from_ty, [20], 3)
		22: Reg	constructor(mov_from_vec_signed, [16, 18, 19, 21], 4)
		23: u8	const_int(63, u8)
		24: ImmShift	constructor(imm_shift_from_u8, [23], 5)
		25: Reg	constructor(asr_imm, [20, 22, 24], 6)
		26: ValueRegs	constructor(value_regs, [22, 25], 7)
		27: InstOutput	constructor(output, [26], 8)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Sextend)
		9:	some
		11:	variant(InstructionData::BinaryImm8)
		12:	variant(Opcode::Extractlane)
		15:	some
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1160
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg_sext64, [8], 1)
		10: Type	const_prim(I64)
		11: u8	const_int(63, u8)
		12: ImmShift	constructor(imm_shift_from_u8, [11], 2)
		13: Reg	constructor(asr_imm, [10, 9, 12], 3)
		14: ValueRegs	constructor(value_regs, [9, 13], 4)
		15: InstOutput	constructor(output, [14], 5)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Sextend)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1151
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: InstructionData	extractor(inst_data, 11)
		13: Opcode	match_variant(12, InstructionData::BinaryImm8, opcode)
		14: Value	match_variant(12, InstructionData::BinaryImm8, arg)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_variant(12, InstructionData::BinaryImm8, imm)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: VectorSize	constructor(vector_size, [18], 2)
		20: Type	match_some(7)
		21: OperandSize	constructor(size_from_ty, [20], 3)
		22: Reg	constructor(mov_from_vec_signed, [15, 17, 19, 21], 4)
		23: InstOutput	constructor(output_reg, [22], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Sextend)
		10:	some
		12:	variant(InstructionData::BinaryImm8)
		13:	variant(Opcode::Extractlane)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1146
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(true)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(7)
		15: u8	constructor(ty_bits, [14], 0)
		16: Reg	constructor(extend, [10, 11, 13, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Sextend)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1137
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Option(Inst)	extractor(def_inst, 8)
		10: Inst	match_some(9)
		11: InstructionData	extractor(inst_data, 10)
		12: Opcode	match_variant(11, InstructionData::BinaryImm8, opcode)
		13: Value	match_variant(11, InstructionData::BinaryImm8, arg)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Uimm8	match_variant(11, InstructionData::BinaryImm8, imm)
		16: u8	extractor(u8_from_uimm8, 15)
		17: Type	extractor(value_type, 13)
		18: ScalarSize	constructor(lane_size, [17], 2)
		19: Reg	constructor(mov_from_vec, [14, 16, 18], 3)
		20: Type	const_prim(I64)
		21: ImmExtend	make_variant(ImmExtend::Zero, [])
		22: u64	const_int(0, u64)
		23: Reg	constructor(imm, [20, 21, 22], 4)
		24: ValueRegs	constructor(value_regs, [19, 23], 5)
		25: InstOutput	constructor(output, [24], 6)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Uextend)
		9:	some
		11:	variant(InstructionData::BinaryImm8)
		12:	variant(Opcode::Extractlane)
	]
	result = 25
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1132
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg_zext64, [8], 1)
		10: Type	const_prim(I64)
		11: ImmExtend	make_variant(ImmExtend::Zero, [])
		12: u64	const_int(0, u64)
		13: Reg	constructor(imm, [10, 11, 12], 2)
		14: ValueRegs	constructor(value_regs, [9, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Uextend)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1125
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: InstructionData	extractor(inst_data, 11)
		13: Opcode	match_variant(12, InstructionData::LoadNoOffset, opcode)
		14: Option(Inst)	constructor(is_sinkable_inst, [9], 0)
		15: Type	extractor(value_type, 9)
		16: MemFlags	match_variant(12, InstructionData::LoadNoOffset, flags)
		17: Inst	match_some(14)
		18: Reg	constructor(sink_atomic_load, [17], 1)
		19: Reg	constructor(load_acquire, [15, 16, 18], 2)
		20: InstOutput	constructor(output_reg, [19], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Uextend)
		10:	some
		12:	variant(InstructionData::LoadNoOffset)
		13:	variant(Opcode::AtomicLoad)
		14:	some
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1118
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Option(Inst)	extractor(def_inst, 9)
		11: Inst	match_some(10)
		12: InstructionData	extractor(inst_data, 11)
		13: Opcode	match_variant(12, InstructionData::BinaryImm8, opcode)
		14: Value	match_variant(12, InstructionData::BinaryImm8, arg)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Uimm8	match_variant(12, InstructionData::BinaryImm8, imm)
		17: u8	extractor(u8_from_uimm8, 16)
		18: Type	extractor(value_type, 14)
		19: ScalarSize	constructor(lane_size, [18], 2)
		20: Reg	constructor(mov_from_vec, [15, 17, 19], 3)
		21: InstOutput	constructor(output_reg, [20], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Uextend)
		10:	some
		12:	variant(InstructionData::BinaryImm8)
		13:	variant(Opcode::Extractlane)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1113
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: bool	const_prim(false)
		12: Type	extractor(value_type, 9)
		13: u8	constructor(ty_bits, [12], 0)
		14: Type	match_some(7)
		15: u8	constructor(ty_bits, [14], 0)
		16: Reg	constructor(extend, [10, 11, 13, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Uextend)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1106
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 3)
		18: Reg	constructor(put_in_reg, [12], 4)
		19: Reg	constructor(put_in_reg, [14], 5)
		20: Reg	constructor(bsl, [8, 17, 18, 19], 6)
		21: InstOutput	constructor(output_reg, [20], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Umax)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1103
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Umax, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Umax)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1100
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 3)
		18: Reg	constructor(put_in_reg, [12], 4)
		19: Reg	constructor(put_in_reg, [14], 5)
		20: Reg	constructor(bsl, [8, 17, 18, 19], 6)
		21: InstOutput	constructor(output_reg, [20], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Smax)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1097
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Smax, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Smax)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1094
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmhi, [])
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 0)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 3)
		18: Reg	constructor(put_in_reg, [14], 4)
		19: Reg	constructor(put_in_reg, [12], 5)
		20: Reg	constructor(bsl, [8, 17, 18, 19], 6)
		21: InstOutput	constructor(output_reg, [20], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Umin)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1091
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Umin, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Umin)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1088
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64X2)
		9: VecALUOp	make_variant(VecALUOp::Cmgt, [])
		10: ValueArray2	match_variant(6, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 1)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 0)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	make_variant(VectorSize::Size64x2, [])
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 3)
		18: Reg	constructor(put_in_reg, [14], 4)
		19: Reg	constructor(put_in_reg, [12], 5)
		20: Reg	constructor(bsl, [8, 17, 18, 19], 6)
		21: InstOutput	constructor(output_reg, [20], 7)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Smin)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1085
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(())	extractor(not_i64x2, 7)
		9: VecALUOp	make_variant(VecALUOp::Smin, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Smin)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1080
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Option(Type)	extractor(ty_int, 6)
		10: Type	match_some(7)
		11: Cond	make_variant(Cond::Gt, [])
		12: bool	const_prim(true)
		13: ValueArray2	match_variant(4, InstructionData::Binary, args)
		14: (Value, Value)	extractor(value_array_2, 13)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 15, 16], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Smax)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1078
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Option(Type)	extractor(ty_int, 6)
		10: Type	match_some(7)
		11: Cond	make_variant(Cond::Hi, [])
		12: bool	const_prim(false)
		13: ValueArray2	match_variant(4, InstructionData::Binary, args)
		14: (Value, Value)	extractor(value_array_2, 13)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 15, 16], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Umax)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1076
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Option(Type)	extractor(ty_int, 6)
		10: Type	match_some(7)
		11: Cond	make_variant(Cond::Lt, [])
		12: bool	const_prim(true)
		13: ValueArray2	match_variant(4, InstructionData::Binary, args)
		14: (Value, Value)	extractor(value_array_2, 13)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 15, 16], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Smin)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1074
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Option(Type)	extractor(ty_int, 6)
		10: Type	match_some(7)
		11: Cond	make_variant(Cond::Lo, [])
		12: bool	const_prim(false)
		13: ValueArray2	match_variant(4, InstructionData::Binary, args)
		14: (Value, Value)	extractor(value_array_2, 13)
		15: Value	match_tuple(14, 0)
		16: Value	match_tuple(14, 1)
		17: ValueRegs	constructor(cmp_and_choose, [10, 11, 12, 15, 16], 1)
		18: InstOutput	constructor(output, [17], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Umin)
		9:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1046
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_sext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_nonzero_in_reg_sext64, [14], 2)
		16: Reg	constructor(a64_sdiv, [9, 13, 15], 3)
		17: Reg	constructor(msub, [9, 16, 15, 13], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Srem)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1039
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_nonzero_in_reg_zext64, [14], 2)
		16: Reg	constructor(a64_udiv, [9, 13, 15], 3)
		17: Reg	constructor(msub, [9, 16, 15, 13], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Urem)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1010
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::UnaryImm, opcode)
		16: Type	match_some(7)
		17: Imm64	match_variant(14, InstructionData::UnaryImm, imm)
		18: Option(u64)	constructor(safe_divisor_from_imm64, [16, 17], 0)
		19: Type	const_prim(I64)
		20: Value	match_tuple(10, 0)
		21: Reg	constructor(put_in_reg_sext64, [20], 1)
		22: ImmExtend	make_variant(ImmExtend::Sign, [])
		23: u64	match_some(18)
		24: Reg	constructor(imm, [16, 22, 23], 2)
		25: Reg	constructor(a64_sdiv, [19, 21, 24], 3)
		26: InstOutput	constructor(output_reg, [25], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Sdiv)
		12:	some
		14:	variant(InstructionData::UnaryImm)
		15:	variant(Opcode::Iconst)
		18:	some
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 1001
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	const_prim(I64)
		10: Type	match_some(7)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg_sext64, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_nonzero_in_reg_sext64, [15], 2)
		17: Reg	constructor(trap_if_div_overflow, [10, 14, 16], 3)
		18: Reg	constructor(a64_sdiv, [9, 17, 16], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Sdiv)
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 968
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_nonzero_in_reg_zext64, [14], 2)
		16: Reg	constructor(a64_udiv, [9, 13, 15], 3)
		17: InstOutput	constructor(output_reg, [16], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Udiv)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 952
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_zext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg_zext64, [14], 2)
		16: Reg	constructor(zero_reg, [], 3)
		17: Reg	constructor(madd, [9, 13, 15, 16], 4)
		18: Type	match_some(8)
		19: u8	constructor(ty_bits, [18], 0)
		20: ImmShift	constructor(imm_shift_from_u8, [19], 5)
		21: Reg	constructor(lsr_imm, [9, 17, 20], 6)
		22: ValueRegs	constructor(value_reg, [21], 7)
		23: InstOutput	constructor(output, [22], 8)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Umulhi)
		8:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 949
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(umulh, [8, 12, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Umulhi)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 940
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: Type	const_prim(I64)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg_sext64, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg_sext64, [14], 2)
		16: Reg	constructor(zero_reg, [], 3)
		17: Reg	constructor(madd, [9, 13, 15, 16], 4)
		18: Type	match_some(8)
		19: u8	constructor(ty_bits, [18], 0)
		20: ImmShift	constructor(imm_shift_from_u8, [19], 5)
		21: Reg	constructor(asr_imm, [9, 17, 20], 6)
		22: InstOutput	constructor(output_reg, [21], 7)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Smulhi)
		8:	some
	]
	result = 22
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 937
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Reg	constructor(smulh, [8, 12, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Smulhi)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 930
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(true)
		27: Reg	constructor(umull32, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenHigh)
		19:	variant(Opcode::UwidenHigh)
		21:	const_prim(I32X4)
		23:	const_prim(I32X4)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 924
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(false)
		27: Reg	constructor(umull32, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenLow)
		19:	variant(Opcode::UwidenLow)
		21:	const_prim(I32X4)
		23:	const_prim(I32X4)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 918
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(true)
		27: Reg	constructor(smull32, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenHigh)
		19:	variant(Opcode::SwidenHigh)
		21:	const_prim(I32X4)
		23:	const_prim(I32X4)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 912
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(false)
		27: Reg	constructor(smull32, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenLow)
		19:	variant(Opcode::SwidenLow)
		21:	const_prim(I32X4)
		23:	const_prim(I32X4)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 906
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(true)
		27: Reg	constructor(umull16, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenHigh)
		19:	variant(Opcode::UwidenHigh)
		21:	const_prim(I16X8)
		23:	const_prim(I16X8)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 900
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(false)
		27: Reg	constructor(umull16, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenLow)
		19:	variant(Opcode::UwidenLow)
		21:	const_prim(I16X8)
		23:	const_prim(I16X8)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 894
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(true)
		27: Reg	constructor(smull16, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenHigh)
		19:	variant(Opcode::SwidenHigh)
		21:	const_prim(I16X8)
		23:	const_prim(I16X8)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 888
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(false)
		27: Reg	constructor(smull16, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenLow)
		19:	variant(Opcode::SwidenLow)
		21:	const_prim(I16X8)
		23:	const_prim(I16X8)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 882
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(true)
		27: Reg	constructor(umull8, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenHigh)
		19:	variant(Opcode::UwidenHigh)
		21:	const_prim(I8X16)
		23:	const_prim(I8X16)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 876
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(false)
		27: Reg	constructor(umull8, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenLow)
		19:	variant(Opcode::UwidenLow)
		21:	const_prim(I8X16)
		23:	const_prim(I8X16)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 870
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(true)
		27: Reg	constructor(smull8, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenHigh)
		19:	variant(Opcode::SwidenHigh)
		21:	const_prim(I8X16)
		23:	const_prim(I8X16)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 864
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Type	extractor(value_type, 20)
		22: Value	match_variant(13, InstructionData::Unary, arg)
		23: Type	extractor(value_type, 22)
		24: Reg	constructor(put_in_reg, [20], 1)
		25: Reg	constructor(put_in_reg, [22], 2)
		26: bool	const_prim(false)
		27: Reg	constructor(smull8, [24, 25, 26], 3)
		28: InstOutput	constructor(output_reg, [27], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenLow)
		19:	variant(Opcode::SwidenLow)
		21:	const_prim(I8X16)
		23:	const_prim(I8X16)
	]
	result = 28
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 825
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Reg	constructor(rev64, [11, 12], 3)
		14: Value	match_tuple(9, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Reg	constructor(mul, [13, 15, 12], 4)
		17: Reg	constructor(addp, [16, 16, 12], 6)
		18: bool	const_prim(false)
		19: Reg	constructor(shll32, [17, 18], 8)
		20: ScalarSize	make_variant(ScalarSize::Size32, [])
		21: Reg	constructor(xtn, [11, 20], 7)
		22: Reg	constructor(xtn, [15, 20], 5)
		23: Reg	constructor(umlal32, [19, 21, 22, 18], 9)
		24: InstOutput	constructor(output_reg, [23], 10)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 793
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: Type	match_some(8)
		10: Option(())	extractor(not_i64x2, 9)
		11: ValueArray2	match_variant(4, InstructionData::Binary, args)
		12: (Value, Value)	extractor(value_array_2, 11)
		13: Value	match_tuple(12, 0)
		14: Reg	constructor(put_in_reg, [13], 1)
		15: Value	match_tuple(12, 1)
		16: Reg	constructor(put_in_reg, [15], 2)
		17: VectorSize	constructor(vector_size, [9], 3)
		18: Reg	constructor(mul, [14, 16, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Imul)
		8:	some
		10:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 765
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: ValueRegs	constructor(put_in_regs, [11], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 4)
		17: Reg	constructor(value_regs_get, [16, 13], 5)
		18: Reg	constructor(zero_reg, [], 10)
		19: Reg	constructor(madd, [8, 14, 17, 18], 11)
		20: usize	const_int(1, usize)
		21: Reg	constructor(value_regs_get, [12, 20], 3)
		22: Reg	constructor(value_regs_get, [16, 20], 6)
		23: Reg	constructor(umulh, [8, 14, 17], 7)
		24: Reg	constructor(madd, [8, 14, 22, 23], 8)
		25: Reg	constructor(madd, [8, 21, 17, 24], 9)
		26: ValueRegs	constructor(value_regs, [19, 25], 12)
		27: InstOutput	constructor(output, [26], 13)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Imul)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 761
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	match_some(7)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Reg	constructor(zero_reg, [], 3)
		17: Reg	constructor(madd, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Imul)
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 755
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Type	match_some(8)
		12: VectorSize	constructor(vector_size, [11], 2)
		13: Reg	constructor(neg, [10, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Ineg)
		8:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 751
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: ValueRegs	constructor(value_regs_zero, [], 1)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 2)
		11: ValueRegs	constructor(sub_i128, [8, 10], 3)
		12: InstOutput	constructor(output, [11], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Ineg)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 747
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Type	match_some(7)
		10: Reg	constructor(zero_reg, [], 1)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: Reg	constructor(sub, [9, 10, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Ineg)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 741
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(sqsub, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SsubSat)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 736
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(uqsub, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UsubSat)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 731
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(sqadd, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SaddSat)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 726
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_vec128, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: Type	match_some(8)
		16: VectorSize	constructor(vector_size, [15], 3)
		17: Reg	constructor(uqadd, [12, 14, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::UaddSat)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 721
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: ValueRegs	constructor(put_in_regs, [10], 1)
		12: Value	match_tuple(9, 1)
		13: ValueRegs	constructor(put_in_regs, [12], 2)
		14: ValueRegs	constructor(sub_i128, [11, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Isub)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 717
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		16: Reg	constructor(sub_vec, [12, 14, 15], 4)
		17: InstOutput	constructor(output_reg, [16], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Isub)
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 711
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Binary, opcode)
		16: ValueArray2	match_variant(14, InstructionData::Binary, args)
		17: (Value, Value)	extractor(value_array_2, 16)
		18: Value	match_tuple(17, 1)
		19: Option(Inst)	extractor(def_inst, 18)
		20: Inst	match_some(19)
		21: InstructionData	extractor(inst_data, 20)
		22: Opcode	match_variant(21, InstructionData::UnaryImm, opcode)
		23: Type	match_some(7)
		24: Imm64	match_variant(21, InstructionData::UnaryImm, imm)
		25: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [23, 24], 0)
		26: Value	match_tuple(10, 0)
		27: Reg	constructor(put_in_reg, [26], 1)
		28: Value	match_tuple(17, 0)
		29: Reg	constructor(put_in_reg, [28], 2)
		30: ShiftOpAndAmt	match_some(25)
		31: Reg	constructor(sub_shift, [23, 27, 29, 30], 3)
		32: InstOutput	constructor(output_reg, [31], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Isub)
		12:	some
		14:	variant(InstructionData::Binary)
		15:	variant(Opcode::Ishl)
		19:	some
		21:	variant(InstructionData::UnaryImm)
		22:	variant(Opcode::Iconst)
		25:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 706
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(ExtendedValue)	extractor(extended_value_from_value, 11)
		13: Type	match_some(7)
		14: Value	match_tuple(10, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: ExtendedValue	match_some(12)
		17: Reg	constructor(sub_extend, [13, 15, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Isub)
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 700
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Imm12)	constructor(imm12_from_negated_value, [11], 0)
		13: Type	match_some(7)
		14: Value	match_tuple(10, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Imm12	match_some(12)
		17: Reg	constructor(add_imm, [13, 15, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Isub)
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 695
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::UnaryImm, opcode)
		16: Imm64	match_variant(14, InstructionData::UnaryImm, imm)
		17: u64	extractor(u64_from_imm64, 16)
		18: Option(Imm12)	extractor(imm12_from_u64, 17)
		19: Type	match_some(7)
		20: Value	match_tuple(10, 0)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Imm12	match_some(18)
		23: Reg	constructor(sub_imm, [19, 21, 22], 2)
		24: InstOutput	constructor(output_reg, [23], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Isub)
		12:	some
		14:	variant(InstructionData::UnaryImm)
		15:	variant(Opcode::Iconst)
		18:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 691
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	match_some(7)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Reg	constructor(sub, [9, 13, 15], 3)
		17: InstOutput	constructor(output_reg, [16], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Isub)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 683
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToSintSat)
		9:	const_prim(F64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 680
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(true)
		14: Type	match_some(10)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToSintSat)
		7:	const_prim(F64)
		10:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 677
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToSintSat)
		9:	const_prim(F32)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 674
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(true)
		14: Type	match_some(10)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToSintSat)
		7:	const_prim(F32)
		10:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 671
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(64)
		10:	variant(Opcode::FcvtToSintSat)
		13:	some
		15:	const_int(64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 668
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzs, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(32)
		10:	variant(Opcode::FcvtToSintSat)
		13:	some
		15:	const_int(32)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 663
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToUintSat)
		9:	const_prim(F64)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 660
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(false)
		14: Type	match_some(10)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToUintSat)
		7:	const_prim(F64)
		10:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 657
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(I64)
		14: Reg	constructor(fpu_to_int_cvt_sat, [10, 11, 12, 13], 2)
		15: InstOutput	constructor(output_reg, [14], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToUintSat)
		9:	const_prim(F32)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 654
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(false)
		14: Type	match_some(10)
		15: Reg	constructor(fpu_to_int_cvt_sat, [11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToUintSat)
		7:	const_prim(F32)
		10:	some
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 651
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(64)
		10:	variant(Opcode::FcvtToUintSat)
		13:	some
		15:	const_int(64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 648
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Fcvtzu, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(32)
		10:	variant(Opcode::FcvtToUintSat)
		13:	some
		15:	const_int(32)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 643
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::I64ToF64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Reg	constructor(int_to_fpu, [10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromSint)
		9:	const_prim(I64)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 640
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::I64ToF32, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Reg	constructor(int_to_fpu, [10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromSint)
		9:	const_prim(I64)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 637
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF64, [])
		12: Reg	constructor(put_in_reg_sext32, [8], 1)
		13: Reg	constructor(int_to_fpu, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromSint)
		10:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 634
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::I32ToF32, [])
		12: Reg	constructor(put_in_reg_sext32, [8], 1)
		13: Reg	constructor(int_to_fpu, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromSint)
		10:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 631
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(64)
		10:	variant(Opcode::FcvtFromSint)
		13:	some
		15:	const_int(64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 628
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Scvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(32)
		10:	variant(Opcode::FcvtFromSint)
		13:	some
		15:	const_int(32)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 623
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::U64ToF64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Reg	constructor(int_to_fpu, [10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromUint)
		9:	const_prim(I64)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 620
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: IntToFpuOp	make_variant(IntToFpuOp::U64ToF32, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: Reg	constructor(int_to_fpu, [10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromUint)
		9:	const_prim(I64)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 617
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF64, [])
		12: Reg	constructor(put_in_reg_zext32, [8], 1)
		13: Reg	constructor(int_to_fpu, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromUint)
		10:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 614
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: IntToFpuOp	make_variant(IntToFpuOp::U32ToF32, [])
		12: Reg	constructor(put_in_reg_zext32, [8], 1)
		13: Reg	constructor(int_to_fpu, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtFromUint)
		10:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 611
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(64)
		10:	variant(Opcode::FcvtFromUint)
		13:	some
		15:	const_int(64)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 608
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: Opcode	match_variant(4, InstructionData::Unary, opcode)
		11: Value	match_variant(4, InstructionData::Unary, arg)
		12: Type	extractor(value_type, 11)
		13: Option((u32, u32))	extractor(multi_lane, 12)
		14: (u32, u32)	match_some(13)
		15: u32	match_tuple(14, 0)
		16: VecMisc2	make_variant(VecMisc2::Ucvtf, [])
		17: Reg	constructor(put_in_reg, [11], 1)
		18: VectorSize	constructor(vector_size, [6], 2)
		19: Reg	constructor(vec_misc, [16, 17, 18], 3)
		20: InstOutput	constructor(output_reg, [19], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		9:	const_int(32)
		10:	variant(Opcode::FcvtFromUint)
		13:	some
		15:	const_int(32)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 603
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		15: Reg	constructor(fpu_to_int_cvt, [10, 11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToSint)
		9:	const_prim(F64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 600
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToI32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(true)
		14: Type	const_prim(F64)
		15: Type	match_some(10)
		16: Reg	constructor(fpu_to_int_cvt, [11, 12, 13, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToSint)
		7:	const_prim(F64)
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 597
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToI64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(true)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		15: Reg	constructor(fpu_to_int_cvt, [10, 11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToSint)
		9:	const_prim(F32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 594
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToI32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(true)
		14: Type	const_prim(F32)
		15: Type	match_some(10)
		16: Reg	constructor(fpu_to_int_cvt, [11, 12, 13, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToSint)
		7:	const_prim(F32)
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 589
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F64ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(F64)
		14: Type	const_prim(I64)
		15: Reg	constructor(fpu_to_int_cvt, [10, 11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToUint)
		9:	const_prim(F64)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 586
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F64ToU32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(false)
		14: Type	const_prim(F64)
		15: Type	match_some(10)
		16: Reg	constructor(fpu_to_int_cvt, [11, 12, 13, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToUint)
		7:	const_prim(F64)
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 583
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Type	extractor(value_type, 8)
		10: FpuToIntOp	make_variant(FpuToIntOp::F32ToU64, [])
		11: Reg	constructor(put_in_reg, [8], 1)
		12: bool	const_prim(false)
		13: Type	const_prim(F32)
		14: Type	const_prim(I64)
		15: Reg	constructor(fpu_to_int_cvt, [10, 11, 12, 13, 14], 2)
		16: InstOutput	constructor(output_reg, [15], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::FcvtToUint)
		9:	const_prim(F32)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 580
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_variant(4, InstructionData::Unary, arg)
		7: Type	extractor(value_type, 6)
		8: Value	match_some(3)
		9: Type	extractor(value_type, 8)
		10: Option(Type)	extractor(fits_in_32, 9)
		11: FpuToIntOp	make_variant(FpuToIntOp::F32ToU32, [])
		12: Reg	constructor(put_in_reg, [6], 1)
		13: bool	const_prim(false)
		14: Type	const_prim(F32)
		15: Type	match_some(10)
		16: Reg	constructor(fpu_to_int_cvt, [11, 12, 13, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::FcvtToUint)
		7:	const_prim(F32)
		10:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 575
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Value	match_some(3)
		13: Type	extractor(value_type, 12)
		14: Reg	constructor(fcopy_sign, [9, 11, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fcopysign)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 520
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		9: VecALUModOp	make_variant(VecALUModOp::Fmla, [])
		10: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		11: (Value, Value, Value)	extractor(value_array_3, 10)
		12: Value	match_tuple(11, 0)
		13: Value	match_tuple(11, 1)
		14: Value	match_tuple(11, 2)
		15: VectorSize	constructor(vector_size, [6], 1)
		16: Reg	constructor(lower_fmla, [9, 12, 13, 14, 15], 2)
		17: InstOutput	constructor(output_reg, [16], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		7:	some
		8:	variant(Opcode::Fma)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 516
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(ty_scalar_float, 6)
		8: Opcode	match_variant(4, InstructionData::Ternary, opcode)
		9: FPUOp3	make_variant(FPUOp3::MAdd, [])
		10: Type	match_some(7)
		11: ScalarSize	constructor(scalar_size, [10], 1)
		12: ValueArray3	match_variant(4, InstructionData::Ternary, args)
		13: (Value, Value, Value)	extractor(value_array_3, 12)
		14: Value	match_tuple(13, 0)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Value	match_tuple(13, 1)
		17: Reg	constructor(put_in_reg, [16], 3)
		18: Value	match_tuple(13, 2)
		19: Reg	constructor(put_in_reg, [18], 4)
		20: Reg	constructor(fpu_rrrr, [9, 11, 15, 17, 19], 5)
		21: InstOutput	constructor(output_reg, [20], 6)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Ternary)
		7:	some
		8:	variant(Opcode::Fma)
	]
	result = 21
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 511
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Nearest64, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Nearest)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 508
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Nearest32, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Nearest)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 505
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Frintn, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Nearest)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 500
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Zero64, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Trunc)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 497
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Zero32, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Trunc)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 494
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Frintz, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Trunc)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 489
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Minus64, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Floor)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 486
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Minus32, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Floor)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 483
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Frintm, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Floor)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 478
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Plus64, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Ceil)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 475
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FpuRoundMode	make_variant(FpuRoundMode::Plus32, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(fpu_round, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Ceil)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 472
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Frintp, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Ceil)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 467
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FPUOp1	make_variant(FPUOp1::Cvt64To32, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: Reg	constructor(fpu_rr, [8, 10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Fdemote)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 462
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: FPUOp1	make_variant(FPUOp1::Cvt32To64, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: ScalarSize	make_variant(ScalarSize::Size32, [])
		12: Reg	constructor(fpu_rr, [8, 10, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Fpromote)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 457
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp1	make_variant(FPUOp1::Abs, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		14: Reg	constructor(fpu_rr, [9, 11, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Fabs)
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 454
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Fabs, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Fabs)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 449
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp1	make_variant(FPUOp1::Neg, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		14: Reg	constructor(fpu_rr, [9, 11, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Fneg)
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 446
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Fneg, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Fneg)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 441
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp1	make_variant(FPUOp1::Sqrt, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Type	match_some(8)
		13: ScalarSize	constructor(scalar_size, [12], 2)
		14: Reg	constructor(fpu_rr, [9, 11, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Sqrt)
		8:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 438
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: VecMisc2	make_variant(VecMisc2::Fsqrt, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	constructor(vector_size, [6], 2)
		13: Reg	constructor(vec_misc, [9, 11, 12], 3)
		14: InstOutput	constructor(output_reg, [13], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Sqrt)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 433
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Max, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ScalarSize	constructor(scalar_size, [16], 3)
		18: Reg	constructor(fpu_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmax)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 430
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmax, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmax)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 425
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Min, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ScalarSize	constructor(scalar_size, [16], 3)
		18: Reg	constructor(fpu_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmin)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 422
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmin, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmin)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 417
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Div, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ScalarSize	constructor(scalar_size, [16], 3)
		18: Reg	constructor(fpu_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fdiv)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 414
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fdiv, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fdiv)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 409
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Mul, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ScalarSize	constructor(scalar_size, [16], 3)
		18: Reg	constructor(fpu_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmul)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 406
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fmul, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fmul)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 401
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Sub, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ScalarSize	constructor(scalar_size, [16], 3)
		18: Reg	constructor(fpu_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fsub)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 398
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fsub, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fsub)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 393
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(ty_scalar_float, 7)
		9: FPUOp2	make_variant(FPUOp2::Add, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: ScalarSize	constructor(scalar_size, [16], 3)
		18: Reg	constructor(fpu_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fadd)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 390
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Fadd, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Fadd)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 385
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: VecALUOp	make_variant(VecALUOp::Sqrdmulh, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: VectorSize	constructor(vector_size, [7], 3)
		17: Reg	constructor(vec_rrr, [9, 13, 15, 16], 4)
		18: InstOutput	constructor(output_reg, [17], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::SqmulRoundSat)
		8:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 380
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(lane_fits_in_32, 7)
		9: VecALUOp	make_variant(VecALUOp::Urhadd, [])
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Type	match_some(8)
		17: VectorSize	constructor(vector_size, [16], 3)
		18: Reg	constructor(vec_rrr, [9, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::AvgRound)
		8:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 371
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 3)
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Reg	constructor(orr_vec, [11, 13, 14], 4)
		16: u64	const_int(1, u64)
		17: Reg	constructor(splat_const, [16, 14], 1)
		18: Reg	constructor(and_vec, [15, 17, 14], 5)
		19: Reg	constructor(put_in_reg, [10], 6)
		20: u8	const_int(1, u8)
		21: Reg	constructor(ushr_vec_imm, [19, 20, 14], 7)
		22: Reg	constructor(put_in_reg, [12], 8)
		23: Reg	constructor(ushr_vec_imm, [22, 20, 14], 9)
		24: Reg	constructor(add_vec, [21, 23, 14], 10)
		25: Reg	constructor(add_vec, [18, 24, 14], 11)
		26: InstOutput	constructor(output_reg, [25], 12)
	]
	constraints = [
		3:	some
		5:	const_prim(I64X2)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::AvgRound)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 358
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Type	const_prim(I64)
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: ValueRegs	constructor(put_in_regs, [9], 1)
		11: usize	const_int(0, usize)
		12: Reg	constructor(value_regs_get, [10, 11], 2)
		13: usize	const_int(1, usize)
		14: Reg	constructor(value_regs_get, [10, 13], 3)
		15: u8	const_int(63, u8)
		16: ImmShift	constructor(imm_shift_from_u8, [15], 4)
		17: Reg	constructor(asr_imm, [8, 14, 16], 5)
		18: Reg	constructor(eor, [8, 12, 17], 7)
		19: ProducesFlags	constructor(sub_with_flags_paired, [8, 18, 17], 8)
		20: Reg	constructor(eor, [8, 14, 17], 6)
		21: ConsumesFlags	constructor(sbc_paired, [8, 20, 17], 9)
		22: ValueRegs	constructor(with_flags, [19, 21], 10)
		23: InstOutput	constructor(output, [22], 11)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Iabs)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 348
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Unary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option(Type)	extractor(fits_in_32, 7)
		9: OperandSize	make_variant(OperandSize::Size32, [])
		10: Value	match_variant(4, InstructionData::Unary, arg)
		11: Reg	constructor(put_in_reg_sext32, [10], 1)
		12: Reg	constructor(abs, [9, 11], 2)
		13: InstOutput	constructor(output_reg, [12], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		5:	variant(Opcode::Iabs)
		8:	some
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 345
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: OperandSize	make_variant(OperandSize::Size64, [])
		9: Value	match_variant(6, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Reg	constructor(abs, [8, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I64)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::Iabs)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 342
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: Opcode	match_variant(4, InstructionData::Unary, opcode)
		9: Value	match_variant(4, InstructionData::Unary, arg)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	constructor(vector_size, [6], 2)
		12: Reg	constructor(vec_abs, [10, 11], 3)
		13: InstOutput	constructor(output_reg, [12], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Unary)
		7:	some
		8:	variant(Opcode::Iabs)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 337
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Value	match_some(3)
		13: Type	extractor(value_type, 12)
		14: VectorSize	constructor(vector_size, [13], 3)
		15: Reg	constructor(addp, [9, 11, 14], 4)
		16: InstOutput	constructor(output_reg, [15], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::IaddPairwise)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 334
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Reg	constructor(uaddlp16, [21], 2)
		23: InstOutput	constructor(output_reg, [22], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::IaddPairwise)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenLow)
		19:	variant(Opcode::UwidenHigh)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 330
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Reg	constructor(uaddlp8, [21], 2)
		23: InstOutput	constructor(output_reg, [22], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::IaddPairwise)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::UwidenLow)
		19:	variant(Opcode::UwidenHigh)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 326
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Reg	constructor(saddlp16, [21], 2)
		23: InstOutput	constructor(output_reg, [22], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I32X4)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::IaddPairwise)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenLow)
		19:	variant(Opcode::SwidenHigh)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 322
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 1)
		11: Option(Inst)	extractor(def_inst, 10)
		12: Inst	match_some(11)
		13: InstructionData	extractor(inst_data, 12)
		14: Value	match_tuple(9, 0)
		15: Option(Inst)	extractor(def_inst, 14)
		16: Inst	match_some(15)
		17: InstructionData	extractor(inst_data, 16)
		18: Opcode	match_variant(17, InstructionData::Unary, opcode)
		19: Opcode	match_variant(13, InstructionData::Unary, opcode)
		20: Value	match_variant(17, InstructionData::Unary, arg)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Reg	constructor(saddlp8, [21], 2)
		23: InstOutput	constructor(output_reg, [22], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(I16X8)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::IaddPairwise)
		11:	some
		13:	variant(InstructionData::Unary)
		15:	some
		17:	variant(InstructionData::Unary)
		18:	variant(Opcode::SwidenLow)
		19:	variant(Opcode::SwidenHigh)
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 315
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Reg	constructor(put_in_reg, [5], 1)
		7: Type	extractor(value_type, 5)
		8: ProducesFlags	constructor(vanytrue, [6, 7], 2)
		9: Cond	make_variant(Cond::Ne, [])
		10: ConsumesFlags	constructor(materialize_bool_result, [9], 3)
		11: ValueRegs	constructor(with_flags, [8, 10], 4)
		12: InstOutput	constructor(output, [11], 5)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VanyTrue)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 306
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(lane_fits_in_32, 6)
		8: Type	match_some(7)
		9: Option(Type)	constructor(not_vec32x2, [8], 0)
		10: OperandSize	make_variant(OperandSize::Size64, [])
		11: VecLanesOp	make_variant(VecLanesOp::Uminv, [])
		12: Reg	constructor(put_in_reg, [5], 1)
		13: VectorSize	constructor(vector_size, [8], 2)
		14: Reg	constructor(vec_lanes, [11, 12, 13], 3)
		15: u8	const_int(0, u8)
		16: ScalarSize	make_variant(ScalarSize::Size64, [])
		17: Reg	constructor(mov_from_vec, [14, 15, 16], 4)
		18: Imm12	constructor(u8_into_imm12, [15], 5)
		19: ProducesFlags	constructor(cmp_imm, [10, 17, 18], 6)
		20: Cond	make_variant(Cond::Ne, [])
		21: ConsumesFlags	constructor(materialize_bool_result, [20], 7)
		22: ValueRegs	constructor(with_flags, [19, 21], 8)
		23: InstOutput	constructor(output, [22], 9)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VallTrue)
		7:	some
		9:	some
	]
	result = 23
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 289
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: u32	match_tuple(8, 1)
		11: OperandSize	make_variant(OperandSize::Size64, [])
		12: Reg	constructor(zero_reg, [], 3)
		13: Reg	constructor(put_in_reg, [5], 1)
		14: u8	const_int(0, u8)
		15: ScalarSize	make_variant(ScalarSize::Size64, [])
		16: Reg	constructor(mov_from_vec, [13, 14, 15], 2)
		17: u64	const_int(32, u64)
		18: ProducesFlags	constructor(cmp_rr_shift, [11, 12, 16, 17], 4)
		19: OperandSize	make_variant(OperandSize::Size32, [])
		20: UImm5	constructor(u8_into_uimm5, [14], 5)
		21: bool	const_prim(false)
		22: bool	const_prim(true)
		23: NZCV	constructor(nzcv, [21, 22, 21, 21], 6)
		24: Cond	make_variant(Cond::Ne, [])
		25: ConsumesFlags	constructor(ccmp_imm, [19, 16, 20, 23, 24], 7)
		26: ValueRegs	constructor(with_flags, [18, 25], 8)
		27: InstOutput	constructor(output, [26], 9)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VallTrue)
		7:	some
		9:	const_int(32)
		10:	const_int(2)
	]
	result = 27
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 283
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Option((u32, u32))	extractor(multi_lane, 6)
		8: (u32, u32)	match_some(7)
		9: u32	match_tuple(8, 0)
		10: u32	match_tuple(8, 1)
		11: ScalarSize	make_variant(ScalarSize::Size64, [])
		12: Reg	constructor(put_in_reg, [5], 1)
		13: VectorSize	make_variant(VectorSize::Size64x2, [])
		14: Reg	constructor(cmeq0, [12, 13], 2)
		15: Reg	constructor(addp, [14, 14, 13], 3)
		16: ProducesFlags	constructor(fpu_cmp, [11, 15, 15], 4)
		17: Cond	make_variant(Cond::Eq, [])
		18: ConsumesFlags	constructor(materialize_bool_result, [17], 5)
		19: ValueRegs	constructor(with_flags, [16, 18], 6)
		20: InstOutput	constructor(output, [19], 7)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::VallTrue)
		7:	some
		9:	const_int(64)
		10:	const_int(2)
	]
	result = 20
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 269
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(int_fits_in_32, 6)
		8: Reg	constructor(put_in_reg_zext32, [5], 1)
		9: ScalarSize	make_variant(ScalarSize::Size32, [])
		10: Reg	constructor(mov_to_fpu, [8, 9], 2)
		11: InstOutput	constructor(output_reg, [10], 3)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::ScalarToVector)
		7:	some
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 266
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: Reg	constructor(put_in_reg, [5], 1)
		8: ScalarSize	make_variant(ScalarSize::Size64, [])
		9: Reg	constructor(mov_to_fpu, [7, 8], 2)
		10: InstOutput	constructor(output_reg, [9], 3)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::ScalarToVector)
		6:	const_prim(I64)
	]
	result = 10
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 263
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size64, [])
		11: Reg	constructor(fpu_extend, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F64X2)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::ScalarToVector)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 260
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Unary, opcode)
		8: Value	match_variant(6, InstructionData::Unary, arg)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: ScalarSize	make_variant(ScalarSize::Size32, [])
		11: Reg	constructor(fpu_extend, [9, 10], 2)
		12: InstOutput	constructor(output_reg, [11], 3)
	]
	constraints = [
		3:	some
		5:	const_prim(F32X4)
		6:	variant(InstructionData::Unary)
		7:	variant(Opcode::ScalarToVector)
	]
	result = 12
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 255
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: ValueArray2	match_variant(6, InstructionData::Binary, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: ValueRegs	constructor(value_regs, [11, 13], 3)
		15: InstOutput	constructor(output, [14], 4)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Iconcat)
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 246
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Unary, opcode)
		5: Value	match_variant(3, InstructionData::Unary, arg)
		6: Type	extractor(value_type, 5)
		7: ValueRegs	constructor(put_in_regs, [5], 1)
		8: usize	const_int(0, usize)
		9: Reg	constructor(value_regs_get, [7, 8], 2)
		10: ValueRegs	constructor(value_reg, [9], 3)
		11: usize	const_int(1, usize)
		12: Reg	constructor(value_regs_get, [7, 11], 4)
		13: ValueRegs	constructor(value_reg, [12], 5)
		14: InstOutput	constructor(output_pair, [10, 13], 6)
	]
	constraints = [
		3:	variant(InstructionData::Unary)
		4:	variant(Opcode::Isplit)
		6:	const_prim(I128)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 241
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: ValueArray2	match_variant(4, InstructionData::Binary, args)
		7: (Value, Value)	extractor(value_array_2, 6)
		8: Value	match_tuple(7, 0)
		9: Reg	constructor(put_in_reg, [8], 1)
		10: Value	match_tuple(7, 1)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Reg	constructor(vec_tbl, [9, 11], 3)
		13: InstOutput	constructor(output_reg, [12], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Swizzle)
	]
	result = 13
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 235
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Shuffle, opcode)
		6: Immediate	match_variant(4, InstructionData::Shuffle, imm)
		7: Option(u128)	extractor(u128_from_immediate, 6)
		8: ValueArray2	match_variant(4, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 2)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 3)
		14: u128	match_some(7)
		15: Reg	constructor(constant_f128, [14], 1)
		16: Value	match_some(3)
		17: Type	extractor(value_type, 16)
		18: Reg	constructor(vec_tbl2, [11, 13, 15, 17], 4)
		19: InstOutput	constructor(output_reg, [18], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Shuffle)
		5:	variant(Opcode::Shuffle)
		7:	some
	]
	result = 19
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 232
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	make_variant(VectorSize::Size32x4, [])
		13: Reg	constructor(rev64, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(14673614102390417578512422760905835780)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 230
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Reg	constructor(rev64, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(12004814239757670119517129289737963270)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 228
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Reg	constructor(rev64, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(10680758337341567148842519922299176455)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 226
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	make_variant(VectorSize::Size16x8, [])
		13: Reg	constructor(rev32, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(17342576855639742879858139805557719810)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 224
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Reg	constructor(rev32, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(16018520953223639909183530438118932995)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 222
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: VectorSize	make_variant(VectorSize::Size8x16, [])
		13: Reg	constructor(rev16, [11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(18687320815856387368178823909286805505)
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 212
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Reg	constructor(vec_trn2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362427188014754909301208165426529540)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 210
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Reg	constructor(vec_trn1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(36024664569647092737326704519438008576)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 208
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Reg	constructor(vec_trn2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362142128814346332279593629287318274)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 206
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Reg	constructor(vec_trn1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(38693260819630515246292341806293057792)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 204
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Reg	constructor(vec_trn2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41284541550424544734358823780242100481)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 202
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Reg	constructor(vec_trn1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(39950100895832629191365197868744970240)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 194
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Reg	constructor(vec_zip2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362427188014754909590568856778836232)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 192
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Reg	constructor(vec_zip1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(30686901951279430565641561564801794304)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 190
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Reg	constructor(vec_zip2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362142129435743685477327603181816072)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 188
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Reg	constructor(vec_zip1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(30686616892700419341528320311204774144)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 186
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Reg	constructor(vec_zip2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41284561912683712994304547342093195272)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 184
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Reg	constructor(vec_zip1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(30609036675948388650355540050116153344)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 179
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Reg	constructor(vec_uzp2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362427191743139026172726477975062792)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 177
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size64x2, [])
		15: Reg	constructor(vec_uzp1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(30686901955007814682223719185998020864)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 175
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Reg	constructor(vec_uzp2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362427190500344320355979912890680580)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 173
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size32x4, [])
		15: Reg	constructor(vec_uzp1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(36024664572132682148381476266902159616)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 171
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Reg	constructor(vec_uzp2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41362386467224802506860000736977486594)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 169
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size16x8, [])
		15: Reg	constructor(vec_uzp1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(38693505158040971420872748913983226112)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 167
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Reg	constructor(vec_uzp2, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(41357194091136896220700492464948314881)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 165
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u128)	extractor(u128_from_immediate, 5)
		7: u128	match_some(6)
		8: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		9: (Value, Value)	extractor(value_array_2, 8)
		10: Value	match_tuple(9, 0)
		11: Reg	constructor(put_in_reg, [10], 1)
		12: Value	match_tuple(9, 1)
		13: Reg	constructor(put_in_reg, [12], 2)
		14: VectorSize	make_variant(VectorSize::Size8x16, [])
		15: Reg	constructor(vec_uzp1, [11, 13, 14], 3)
		16: InstOutput	constructor(output_reg, [15], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
		7:	const_int(40022753436544980677706866553451184640)
	]
	result = 16
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 152
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u8)	extractor(vec_extract_imm4_from_immediate, 5)
		7: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		8: (Value, Value)	extractor(value_array_2, 7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: Value	match_tuple(8, 1)
		12: Reg	constructor(put_in_reg, [11], 2)
		13: u8	match_some(6)
		14: Reg	constructor(vec_extract, [10, 12, 13], 3)
		15: InstOutput	constructor(output_reg, [14], 4)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
	]
	result = 15
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 133
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u8)	extractor(shuffle_dup64_from_imm, 5)
		7: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		8: (Value, Value)	extractor(value_array_2, 7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	make_variant(VectorSize::Size64x2, [])
		12: u8	match_some(6)
		13: Reg	constructor(vec_dup_from_fpu, [10, 11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 131
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u8)	extractor(shuffle_dup32_from_imm, 5)
		7: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		8: (Value, Value)	extractor(value_array_2, 7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	make_variant(VectorSize::Size32x4, [])
		12: u8	match_some(6)
		13: Reg	constructor(vec_dup_from_fpu, [10, 11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 129
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u8)	extractor(shuffle_dup16_from_imm, 5)
		7: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		8: (Value, Value)	extractor(value_array_2, 7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	make_variant(VectorSize::Size16x8, [])
		12: u8	match_some(6)
		13: Reg	constructor(vec_dup_from_fpu, [10, 11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 127
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::Shuffle, opcode)
		5: Immediate	match_variant(3, InstructionData::Shuffle, imm)
		6: Option(u8)	extractor(shuffle_dup8_from_imm, 5)
		7: ValueArray2	match_variant(3, InstructionData::Shuffle, args)
		8: (Value, Value)	extractor(value_array_2, 7)
		9: Value	match_tuple(8, 0)
		10: Reg	constructor(put_in_reg, [9], 1)
		11: VectorSize	make_variant(VectorSize::Size8x16, [])
		12: u8	match_some(6)
		13: Reg	constructor(vec_dup_from_fpu, [10, 11, 12], 2)
		14: InstOutput	constructor(output_reg, [13], 3)
	]
	constraints = [
		3:	variant(InstructionData::Shuffle)
		4:	variant(Opcode::Shuffle)
		6:	some
	]
	result = 14
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 104
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: Value	match_some(3)
		5: Type	extractor(value_type, 4)
		6: InstructionData	extractor(inst_data, 0)
		7: Opcode	match_variant(6, InstructionData::Binary, opcode)
		8: Type	const_prim(I64)
		9: ValueArray2	match_variant(6, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: ValueRegs	constructor(put_in_regs, [11], 1)
		13: usize	const_int(0, usize)
		14: Reg	constructor(value_regs_get, [12, 13], 2)
		15: Value	match_tuple(10, 1)
		16: ValueRegs	constructor(put_in_regs, [15], 4)
		17: Reg	constructor(value_regs_get, [16, 13], 5)
		18: ProducesFlags	constructor(add_with_flags_paired, [8, 14, 17], 7)
		19: usize	const_int(1, usize)
		20: Reg	constructor(value_regs_get, [12, 19], 3)
		21: Reg	constructor(value_regs_get, [16, 19], 6)
		22: ConsumesFlags	constructor(adc_paired, [8, 20, 21], 8)
		23: ValueRegs	constructor(with_flags, [18, 22], 9)
		24: InstOutput	constructor(output, [23], 10)
	]
	constraints = [
		3:	some
		5:	const_prim(I128)
		6:	variant(InstructionData::Binary)
		7:	variant(Opcode::Iadd)
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 100
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::Binary, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: Option((u32, u32))	extractor(multi_lane, 7)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Reg	constructor(put_in_reg, [11], 1)
		13: Value	match_tuple(10, 1)
		14: Reg	constructor(put_in_reg, [13], 2)
		15: VectorSize	constructor(vector_size, [7], 3)
		16: Reg	constructor(add_vec, [12, 14, 15], 4)
		17: InstOutput	constructor(output_reg, [16], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		5:	variant(Opcode::Iadd)
		8:	some
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 95
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Binary, opcode)
		16: Type	match_some(7)
		17: ValueArray2	match_variant(14, InstructionData::Binary, args)
		18: (Value, Value)	extractor(value_array_2, 17)
		19: Value	match_tuple(18, 0)
		20: Reg	constructor(put_in_reg, [19], 1)
		21: Value	match_tuple(18, 1)
		22: Reg	constructor(put_in_reg, [21], 2)
		23: Value	match_tuple(10, 0)
		24: Reg	constructor(put_in_reg, [23], 3)
		25: Reg	constructor(msub, [16, 20, 22, 24], 4)
		26: InstOutput	constructor(output_reg, [25], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Isub)
		12:	some
		14:	variant(InstructionData::Binary)
		15:	variant(Opcode::Imul)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 91
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Binary, opcode)
		16: Type	match_some(7)
		17: ValueArray2	match_variant(14, InstructionData::Binary, args)
		18: (Value, Value)	extractor(value_array_2, 17)
		19: Value	match_tuple(18, 0)
		20: Reg	constructor(put_in_reg, [19], 1)
		21: Value	match_tuple(18, 1)
		22: Reg	constructor(put_in_reg, [21], 2)
		23: Value	match_tuple(10, 1)
		24: Reg	constructor(put_in_reg, [23], 3)
		25: Reg	constructor(madd, [16, 20, 22, 24], 4)
		26: InstOutput	constructor(output_reg, [25], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
		14:	variant(InstructionData::Binary)
		15:	variant(Opcode::Imul)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 88
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Binary, opcode)
		16: Type	match_some(7)
		17: ValueArray2	match_variant(14, InstructionData::Binary, args)
		18: (Value, Value)	extractor(value_array_2, 17)
		19: Value	match_tuple(18, 0)
		20: Reg	constructor(put_in_reg, [19], 1)
		21: Value	match_tuple(18, 1)
		22: Reg	constructor(put_in_reg, [21], 2)
		23: Value	match_tuple(10, 0)
		24: Reg	constructor(put_in_reg, [23], 3)
		25: Reg	constructor(madd, [16, 20, 22, 24], 4)
		26: InstOutput	constructor(output_reg, [25], 5)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
		14:	variant(InstructionData::Binary)
		15:	variant(Opcode::Imul)
	]
	result = 26
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 82
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Binary, opcode)
		16: ValueArray2	match_variant(14, InstructionData::Binary, args)
		17: (Value, Value)	extractor(value_array_2, 16)
		18: Value	match_tuple(17, 1)
		19: Option(Inst)	extractor(def_inst, 18)
		20: Inst	match_some(19)
		21: InstructionData	extractor(inst_data, 20)
		22: Opcode	match_variant(21, InstructionData::UnaryImm, opcode)
		23: Type	match_some(7)
		24: Imm64	match_variant(21, InstructionData::UnaryImm, imm)
		25: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [23, 24], 0)
		26: Value	match_tuple(10, 1)
		27: Reg	constructor(put_in_reg, [26], 1)
		28: Value	match_tuple(17, 0)
		29: Reg	constructor(put_in_reg, [28], 2)
		30: ShiftOpAndAmt	match_some(25)
		31: Reg	constructor(add_shift, [23, 27, 29, 30], 3)
		32: InstOutput	constructor(output_reg, [31], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
		14:	variant(InstructionData::Binary)
		15:	variant(Opcode::Ishl)
		19:	some
		21:	variant(InstructionData::UnaryImm)
		22:	variant(Opcode::Iconst)
		25:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 77
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::Binary, opcode)
		16: ValueArray2	match_variant(14, InstructionData::Binary, args)
		17: (Value, Value)	extractor(value_array_2, 16)
		18: Value	match_tuple(17, 1)
		19: Option(Inst)	extractor(def_inst, 18)
		20: Inst	match_some(19)
		21: InstructionData	extractor(inst_data, 20)
		22: Opcode	match_variant(21, InstructionData::UnaryImm, opcode)
		23: Type	match_some(7)
		24: Imm64	match_variant(21, InstructionData::UnaryImm, imm)
		25: Option(ShiftOpAndAmt)	constructor(lshl_from_imm64, [23, 24], 0)
		26: Value	match_tuple(10, 0)
		27: Reg	constructor(put_in_reg, [26], 1)
		28: Value	match_tuple(17, 0)
		29: Reg	constructor(put_in_reg, [28], 2)
		30: ShiftOpAndAmt	match_some(25)
		31: Reg	constructor(add_shift, [23, 27, 29, 30], 3)
		32: InstOutput	constructor(output_reg, [31], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
		14:	variant(InstructionData::Binary)
		15:	variant(Opcode::Ishl)
		19:	some
		21:	variant(InstructionData::UnaryImm)
		22:	variant(Opcode::Iconst)
		25:	some
	]
	result = 32
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 72
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(ExtendedValue)	extractor(extended_value_from_value, 11)
		13: Type	match_some(7)
		14: Value	match_tuple(10, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: ExtendedValue	match_some(12)
		17: Reg	constructor(add_extend, [13, 15, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 69
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(ExtendedValue)	extractor(extended_value_from_value, 11)
		13: Type	match_some(7)
		14: Value	match_tuple(10, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: ExtendedValue	match_some(12)
		17: Reg	constructor(add_extend, [13, 15, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 63
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Imm12)	constructor(imm12_from_negated_value, [11], 0)
		13: Type	match_some(7)
		14: Value	match_tuple(10, 1)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Imm12	match_some(12)
		17: Reg	constructor(sub_imm, [13, 15, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 59
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Imm12)	constructor(imm12_from_negated_value, [11], 0)
		13: Type	match_some(7)
		14: Value	match_tuple(10, 0)
		15: Reg	constructor(put_in_reg, [14], 1)
		16: Imm12	match_some(12)
		17: Reg	constructor(sub_imm, [13, 15, 16], 2)
		18: InstOutput	constructor(output_reg, [17], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
	]
	result = 18
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 54
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 0)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::UnaryImm, opcode)
		16: Imm64	match_variant(14, InstructionData::UnaryImm, imm)
		17: u64	extractor(u64_from_imm64, 16)
		18: Option(Imm12)	extractor(imm12_from_u64, 17)
		19: Type	match_some(7)
		20: Value	match_tuple(10, 1)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Imm12	match_some(18)
		23: Reg	constructor(add_imm, [19, 21, 22], 2)
		24: InstOutput	constructor(output_reg, [23], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
		14:	variant(InstructionData::UnaryImm)
		15:	variant(Opcode::Iconst)
		18:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 51
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: ValueArray2	match_variant(4, InstructionData::Binary, args)
		10: (Value, Value)	extractor(value_array_2, 9)
		11: Value	match_tuple(10, 1)
		12: Option(Inst)	extractor(def_inst, 11)
		13: Inst	match_some(12)
		14: InstructionData	extractor(inst_data, 13)
		15: Opcode	match_variant(14, InstructionData::UnaryImm, opcode)
		16: Imm64	match_variant(14, InstructionData::UnaryImm, imm)
		17: u64	extractor(u64_from_imm64, 16)
		18: Option(Imm12)	extractor(imm12_from_u64, 17)
		19: Type	match_some(7)
		20: Value	match_tuple(10, 0)
		21: Reg	constructor(put_in_reg, [20], 1)
		22: Imm12	match_some(18)
		23: Reg	constructor(add_imm, [19, 21, 22], 2)
		24: InstOutput	constructor(output_reg, [23], 3)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
		12:	some
		14:	variant(InstructionData::UnaryImm)
		15:	variant(Opcode::Iconst)
		18:	some
	]
	result = 24
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 47
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Value	match_some(3)
		6: Type	extractor(value_type, 5)
		7: Option(Type)	extractor(fits_in_64, 6)
		8: Opcode	match_variant(4, InstructionData::Binary, opcode)
		9: Type	match_some(7)
		10: ValueArray2	match_variant(4, InstructionData::Binary, args)
		11: (Value, Value)	extractor(value_array_2, 10)
		12: Value	match_tuple(11, 0)
		13: Reg	constructor(put_in_reg, [12], 1)
		14: Value	match_tuple(11, 1)
		15: Reg	constructor(put_in_reg, [14], 2)
		16: Reg	constructor(add, [9, 13, 15], 3)
		17: InstOutput	constructor(output_reg, [16], 4)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::Binary)
		7:	some
		8:	variant(Opcode::Iadd)
	]
	result = 17
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 39
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::NullAry, opcode)
		5: Reg	constructor(invalid_reg, [], 1)
		6: InstOutput	constructor(output_reg, [5], 2)
	]
	constraints = [
		3:	variant(InstructionData::NullAry)
		4:	variant(Opcode::Nop)
	]
	result = 6
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 34
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::UnaryIeee64, opcode)
		5: Ieee64	match_variant(3, InstructionData::UnaryIeee64, imm)
		6: u64	extractor(u64_from_ieee64, 5)
		7: Reg	constructor(constant_f64, [6], 1)
		8: InstOutput	constructor(output_reg, [7], 2)
	]
	constraints = [
		3:	variant(InstructionData::UnaryIeee64)
		4:	variant(Opcode::F64const)
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 29
	]
	bindings = [
		0: Inst	argument(0)
		3: InstructionData	extractor(inst_data, 0)
		4: Opcode	match_variant(3, InstructionData::UnaryIeee32, opcode)
		5: Ieee32	match_variant(3, InstructionData::UnaryIeee32, imm)
		6: u32	extractor(u32_from_ieee32, 5)
		7: Reg	constructor(constant_f32, [6], 1)
		8: InstOutput	constructor(output_reg, [7], 2)
	]
	constraints = [
		3:	variant(InstructionData::UnaryIeee32)
		4:	variant(Opcode::F32const)
	]
	result = 8
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 24
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::NullAry, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: u64	const_int(0, u64)
		10: Reg	constructor(imm, [7, 8, 9], 1)
		11: InstOutput	constructor(output_reg, [10], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::NullAry)
		5:	variant(Opcode::Null)
	]
	result = 11
}
expansion {
	term = lower
	rules = [
		../../codegen/src/isa/aarch64/lower.isle line 19
	]
	bindings = [
		0: Inst	argument(0)
		3: Option(Value)	extractor(first_result, 0)
		4: InstructionData	extractor(inst_data, 0)
		5: Opcode	match_variant(4, InstructionData::UnaryImm, opcode)
		6: Value	match_some(3)
		7: Type	extractor(value_type, 6)
		8: ImmExtend	make_variant(ImmExtend::Zero, [])
		9: Imm64	match_variant(4, InstructionData::UnaryImm, imm)
		10: u64	extractor(u64_from_imm64, 9)
		11: Reg	constructor(imm, [7, 8, 10], 1)
		12: InstOutput	constructor(output_reg, [11], 2)
	]
	constraints = [
		3:	some
		4:	variant(InstructionData::UnaryImm)
		5:	variant(Opcode::Iconst)
	]
	result = 12
}

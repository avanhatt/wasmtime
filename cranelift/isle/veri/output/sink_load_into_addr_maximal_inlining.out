inline term: sink_load_into_addr
expansions = 17
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2953
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Reg	constructor(load_constant64_full, [25, 18, 13], 1)
		30: ALUOp	make_variant(ALUOp::Add, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		39: MInst	make_variant(MInst::AluRRR, [30, 44, 37, 9, 26])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Option(Type)	extractor(fits_in_64, 17)
		44: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		24:	some
		43:	some
	]
	result = 41
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2953
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Reg	constructor(load_constant64_full, [25, 18, 13], 1)
		30: ALUOp	make_variant(ALUOp::Add, [])
		36: Type	const_prim(I64)
		37: WritableReg	constructor(temp_writable_reg, [36], 1)
		39: MInst	make_variant(MInst::AluRRR, [30, 44, 37, 9, 26])
		40: Unit	constructor(emit, [39], 3)
		41: Reg	constructor(writable_reg_to_reg, [37], 0)
		43: Option(Type)	extractor(fits_in_32, 17)
		44: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		24:	some
		43:	some
	]
	result = 41
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2942
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1220
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(ImmLogic)	constructor(imm_logic_from_u64, [25, 13], 0)
		27: Option(u16)	constructor(imm_size_from_type, [25], 0)
		28: Reg	constructor(zero_reg, [], 1)
		29: ImmLogic	match_some(26)
		31: u16	match_some(27)
		32: Reg	constructor(add_range_fact, [62, 31, 13, 13], 3)
		36: ALUOp	make_variant(ALUOp::Add, [])
		41: ALUOp	make_variant(ALUOp::Orr, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		50: MInst	make_variant(MInst::AluRRR, [36, 65, 48, 9, 32])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		60: MInst	make_variant(MInst::AluRRImmLogic, [41, 68, 58, 28, 29])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Option(Type)	extractor(fits_in_64, 17)
		65: OperandSize	make_variant(OperandSize::Size64, [])
		67: Option(Type)	extractor(fits_in_64, 25)
		68: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		27:	some
		64:	some
		67:	some
	]
	result = 52
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2942
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1220
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(ImmLogic)	constructor(imm_logic_from_u64, [25, 13], 0)
		27: Option(u16)	constructor(imm_size_from_type, [25], 0)
		28: Reg	constructor(zero_reg, [], 1)
		29: ImmLogic	match_some(26)
		31: u16	match_some(27)
		32: Reg	constructor(add_range_fact, [62, 31, 13, 13], 3)
		36: ALUOp	make_variant(ALUOp::Add, [])
		41: ALUOp	make_variant(ALUOp::Orr, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		50: MInst	make_variant(MInst::AluRRR, [36, 65, 48, 9, 32])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		60: MInst	make_variant(MInst::AluRRImmLogic, [41, 68, 58, 28, 29])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Option(Type)	extractor(fits_in_64, 17)
		65: OperandSize	make_variant(OperandSize::Size64, [])
		67: Option(Type)	extractor(fits_in_32, 25)
		68: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		27:	some
		64:	some
		67:	some
	]
	result = 52
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2942
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(ImmLogic)	constructor(imm_logic_from_u64, [25, 13], 0)
		27: Option(u16)	constructor(imm_size_from_type, [25], 0)
		28: Reg	constructor(zero_reg, [], 1)
		29: ImmLogic	match_some(26)
		31: u16	match_some(27)
		32: Reg	constructor(add_range_fact, [62, 31, 13, 13], 3)
		36: ALUOp	make_variant(ALUOp::Add, [])
		41: ALUOp	make_variant(ALUOp::Orr, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		50: MInst	make_variant(MInst::AluRRR, [36, 65, 48, 9, 32])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		60: MInst	make_variant(MInst::AluRRImmLogic, [41, 68, 58, 28, 29])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Option(Type)	extractor(fits_in_32, 17)
		65: OperandSize	make_variant(OperandSize::Size32, [])
		67: Option(Type)	extractor(fits_in_64, 25)
		68: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		27:	some
		64:	some
		67:	some
	]
	result = 52
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2942
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 2702
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1878
		../../codegen/src/isa/aarch64/inst.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(ImmLogic)	constructor(imm_logic_from_u64, [25, 13], 0)
		27: Option(u16)	constructor(imm_size_from_type, [25], 0)
		28: Reg	constructor(zero_reg, [], 1)
		29: ImmLogic	match_some(26)
		31: u16	match_some(27)
		32: Reg	constructor(add_range_fact, [62, 31, 13, 13], 3)
		36: ALUOp	make_variant(ALUOp::Add, [])
		41: ALUOp	make_variant(ALUOp::Orr, [])
		47: Type	const_prim(I64)
		48: WritableReg	constructor(temp_writable_reg, [47], 1)
		50: MInst	make_variant(MInst::AluRRR, [36, 65, 48, 9, 32])
		51: Unit	constructor(emit, [50], 3)
		52: Reg	constructor(writable_reg_to_reg, [48], 0)
		57: Type	const_prim(I64)
		58: WritableReg	constructor(temp_writable_reg, [57], 1)
		60: MInst	make_variant(MInst::AluRRImmLogic, [41, 68, 58, 28, 29])
		61: Unit	constructor(emit, [60], 3)
		62: Reg	constructor(writable_reg_to_reg, [58], 0)
		64: Option(Type)	extractor(fits_in_32, 17)
		65: OperandSize	make_variant(OperandSize::Size32, [])
		67: Option(Type)	extractor(fits_in_32, 25)
		68: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		27:	some
		64:	some
		67:	some
	]
	result = 52
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2934
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1220
		../../codegen/src/isa/aarch64/inst.isle line 1871
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(Type)	extractor(ty_32_or_64, 25)
		27: Type	match_some(26)
		28: Option(MoveWideConst)	constructor(move_wide_const_from_inverted_u64, [27, 13], 0)
		30: MoveWideConst	match_some(28)
		32: u16	const_int(64, u16)
		33: Reg	constructor(add_range_fact, [49, 32, 13, 13], 3)
		37: ALUOp	make_variant(ALUOp::Add, [])
		40: Option(Type)	extractor(fits_in_64, 27)
		41: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MoveWideOp	make_variant(MoveWideOp::MovN, [])
		47: MInst	make_variant(MInst::MovWide, [46, 45, 30, 41])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		57: MInst	make_variant(MInst::AluRRR, [37, 62, 55, 9, 33])
		58: Unit	constructor(emit, [57], 3)
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		61: Option(Type)	extractor(fits_in_64, 17)
		62: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		28:	some
		40:	some
		61:	some
	]
	result = 59
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2934
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1220
		../../codegen/src/isa/aarch64/inst.isle line 1871
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(Type)	extractor(ty_32_or_64, 25)
		27: Type	match_some(26)
		28: Option(MoveWideConst)	constructor(move_wide_const_from_inverted_u64, [27, 13], 0)
		30: MoveWideConst	match_some(28)
		32: u16	const_int(64, u16)
		33: Reg	constructor(add_range_fact, [49, 32, 13, 13], 3)
		37: ALUOp	make_variant(ALUOp::Add, [])
		40: Option(Type)	extractor(fits_in_64, 27)
		41: OperandSize	make_variant(OperandSize::Size64, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MoveWideOp	make_variant(MoveWideOp::MovN, [])
		47: MInst	make_variant(MInst::MovWide, [46, 45, 30, 41])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		57: MInst	make_variant(MInst::AluRRR, [37, 62, 55, 9, 33])
		58: Unit	constructor(emit, [57], 3)
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		61: Option(Type)	extractor(fits_in_32, 17)
		62: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		28:	some
		40:	some
		61:	some
	]
	result = 59
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2934
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 1871
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(Type)	extractor(ty_32_or_64, 25)
		27: Type	match_some(26)
		28: Option(MoveWideConst)	constructor(move_wide_const_from_inverted_u64, [27, 13], 0)
		30: MoveWideConst	match_some(28)
		32: u16	const_int(64, u16)
		33: Reg	constructor(add_range_fact, [49, 32, 13, 13], 3)
		37: ALUOp	make_variant(ALUOp::Add, [])
		40: Option(Type)	extractor(fits_in_32, 27)
		41: OperandSize	make_variant(OperandSize::Size32, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MoveWideOp	make_variant(MoveWideOp::MovN, [])
		47: MInst	make_variant(MInst::MovWide, [46, 45, 30, 41])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		57: MInst	make_variant(MInst::AluRRR, [37, 62, 55, 9, 33])
		58: Unit	constructor(emit, [57], 3)
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		61: Option(Type)	extractor(fits_in_64, 17)
		62: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		28:	some
		40:	some
		61:	some
	]
	result = 59
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2934
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 1871
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(Type)	extractor(ty_32_or_64, 25)
		27: Type	match_some(26)
		28: Option(MoveWideConst)	constructor(move_wide_const_from_inverted_u64, [27, 13], 0)
		30: MoveWideConst	match_some(28)
		32: u16	const_int(64, u16)
		33: Reg	constructor(add_range_fact, [49, 32, 13, 13], 3)
		37: ALUOp	make_variant(ALUOp::Add, [])
		40: Option(Type)	extractor(fits_in_32, 27)
		41: OperandSize	make_variant(OperandSize::Size32, [])
		44: Type	const_prim(I64)
		45: WritableReg	constructor(temp_writable_reg, [44], 1)
		46: MoveWideOp	make_variant(MoveWideOp::MovN, [])
		47: MInst	make_variant(MInst::MovWide, [46, 45, 30, 41])
		48: Unit	constructor(emit, [47], 2)
		49: Reg	constructor(writable_reg_to_reg, [45], 0)
		54: Type	const_prim(I64)
		55: WritableReg	constructor(temp_writable_reg, [54], 1)
		57: MInst	make_variant(MInst::AluRRR, [37, 62, 55, 9, 33])
		58: Unit	constructor(emit, [57], 3)
		59: Reg	constructor(writable_reg_to_reg, [55], 0)
		61: Option(Type)	extractor(fits_in_32, 17)
		62: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		28:	some
		40:	some
		61:	some
	]
	result = 59
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2929
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1220
		../../codegen/src/isa/aarch64/inst.isle line 1864
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(MoveWideConst)	constructor(move_wide_const_from_u64, [25, 13], 0)
		28: MoveWideConst	match_some(26)
		30: u16	const_int(64, u16)
		31: Reg	constructor(add_range_fact, [47, 30, 13, 13], 3)
		35: ALUOp	make_variant(ALUOp::Add, [])
		38: Option(Type)	extractor(fits_in_64, 25)
		39: OperandSize	make_variant(OperandSize::Size64, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MoveWideOp	make_variant(MoveWideOp::MovZ, [])
		45: MInst	make_variant(MInst::MovWide, [44, 43, 28, 39])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		55: MInst	make_variant(MInst::AluRRR, [35, 60, 53, 9, 31])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		59: Option(Type)	extractor(fits_in_64, 17)
		60: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		38:	some
		59:	some
	]
	result = 57
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2929
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1220
		../../codegen/src/isa/aarch64/inst.isle line 1864
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(MoveWideConst)	constructor(move_wide_const_from_u64, [25, 13], 0)
		28: MoveWideConst	match_some(26)
		30: u16	const_int(64, u16)
		31: Reg	constructor(add_range_fact, [47, 30, 13, 13], 3)
		35: ALUOp	make_variant(ALUOp::Add, [])
		38: Option(Type)	extractor(fits_in_64, 25)
		39: OperandSize	make_variant(OperandSize::Size64, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MoveWideOp	make_variant(MoveWideOp::MovZ, [])
		45: MInst	make_variant(MInst::MovWide, [44, 43, 28, 39])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		55: MInst	make_variant(MInst::AluRRR, [35, 60, 53, 9, 31])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		59: Option(Type)	extractor(fits_in_32, 17)
		60: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		38:	some
		59:	some
	]
	result = 57
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2929
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 1864
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(MoveWideConst)	constructor(move_wide_const_from_u64, [25, 13], 0)
		28: MoveWideConst	match_some(26)
		30: u16	const_int(64, u16)
		31: Reg	constructor(add_range_fact, [47, 30, 13, 13], 3)
		35: ALUOp	make_variant(ALUOp::Add, [])
		38: Option(Type)	extractor(fits_in_32, 25)
		39: OperandSize	make_variant(OperandSize::Size32, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MoveWideOp	make_variant(MoveWideOp::MovZ, [])
		45: MInst	make_variant(MInst::MovWide, [44, 43, 28, 39])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		55: MInst	make_variant(MInst::AluRRR, [35, 60, 53, 9, 31])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		59: Option(Type)	extractor(fits_in_64, 17)
		60: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		38:	some
		59:	some
	]
	result = 57
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3227
		../../codegen/src/isa/aarch64/inst.isle line 2929
		../../codegen/src/isa/aarch64/inst.isle line 2425
		../../codegen/src/isa/aarch64/inst.isle line 1219
		../../codegen/src/isa/aarch64/inst.isle line 1864
		../../codegen/src/isa/aarch64/inst.isle line 1892
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Type	const_prim(I64)
		18: ImmExtend	make_variant(ImmExtend::Zero, [])
		24: Option(Type)	extractor(integral_ty, 17)
		25: Type	match_some(24)
		26: Option(MoveWideConst)	constructor(move_wide_const_from_u64, [25, 13], 0)
		28: MoveWideConst	match_some(26)
		30: u16	const_int(64, u16)
		31: Reg	constructor(add_range_fact, [47, 30, 13, 13], 3)
		35: ALUOp	make_variant(ALUOp::Add, [])
		38: Option(Type)	extractor(fits_in_32, 25)
		39: OperandSize	make_variant(OperandSize::Size32, [])
		42: Type	const_prim(I64)
		43: WritableReg	constructor(temp_writable_reg, [42], 1)
		44: MoveWideOp	make_variant(MoveWideOp::MovZ, [])
		45: MInst	make_variant(MInst::MovWide, [44, 43, 28, 39])
		46: Unit	constructor(emit, [45], 2)
		47: Reg	constructor(writable_reg_to_reg, [43], 0)
		52: Type	const_prim(I64)
		53: WritableReg	constructor(temp_writable_reg, [52], 1)
		55: MInst	make_variant(MInst::AluRRR, [35, 60, 53, 9, 31])
		56: Unit	constructor(emit, [55], 3)
		57: Reg	constructor(writable_reg_to_reg, [53], 0)
		59: Option(Type)	extractor(fits_in_32, 17)
		60: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		18:	variant(ImmExtend::Zero)
		24:	some
		26:	some
		38:	some
		59:	some
	]
	result = 57
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3226
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/isa/aarch64/inst.isle line 1996
		../../codegen/src/isa/aarch64/inst.isle line 1220
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Option(Imm12)	extractor(imm12_from_u64, 13)
		18: Type	const_prim(I64)
		19: Imm12	match_some(17)
		24: ALUOp	make_variant(ALUOp::Add, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		33: MInst	make_variant(MInst::AluRRImm12, [24, 38, 31, 9, 19])
		34: Unit	constructor(emit, [33], 3)
		35: Reg	constructor(writable_reg_to_reg, [31], 0)
		37: Option(Type)	extractor(fits_in_64, 18)
		38: OperandSize	make_variant(OperandSize::Size64, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		17:	some
		37:	some
	]
	result = 35
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3226
		../../codegen/src/isa/aarch64/inst.isle line 2428
		../../codegen/src/isa/aarch64/inst.isle line 1996
		../../codegen/src/isa/aarch64/inst.isle line 1219
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
		17: Option(Imm12)	extractor(imm12_from_u64, 13)
		18: Type	const_prim(I64)
		19: Imm12	match_some(17)
		24: ALUOp	make_variant(ALUOp::Add, [])
		30: Type	const_prim(I64)
		31: WritableReg	constructor(temp_writable_reg, [30], 1)
		33: MInst	make_variant(MInst::AluRRImm12, [24, 38, 31, 9, 19])
		34: Unit	constructor(emit, [33], 3)
		35: Reg	constructor(writable_reg_to_reg, [31], 0)
		37: Option(Type)	extractor(fits_in_32, 18)
		38: OperandSize	make_variant(OperandSize::Size32, [])
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		17:	some
		37:	some
	]
	result = 35
	feasible = true
}
expansion {
	term = sink_load_into_addr
	rules = [
		../../codegen/src/isa/aarch64/inst.isle line 3220
		../../codegen/src/isa/aarch64/inst.isle line 3225
	]
	bindings = [
		0: Type	argument(0)
		1: Inst	argument(1)
		5: InstructionData	extractor(inst_data, 1)
		6: Opcode	match_variant(5, InstructionData::Load, opcode)
		7: Unit	constructor(sink_inst, [1], 1)
		8: Value	match_variant(5, InstructionData::Load, arg)
		9: Reg	constructor(put_in_reg, [8], 2)
		10: Offset32	match_variant(5, InstructionData::Load, offset)
		11: i32	extractor(offset32, 10)
		12: i64	constructor(i32_as_i64, [11], 0)
		13: u64	constructor(i64_as_u64, [12], 0)
	]
	constraints = [
		5:	variant(InstructionData::Load)
		6:	variant(Opcode::Load)
		13:	const_int(0)
	]
	result = 9
	feasible = true
}

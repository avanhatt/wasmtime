// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/algebraic.isle
// - src/opts/cprop.isle
// - /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_sextend_u32(&mut self, arg0: u64) -> u64;
    fn u64_uextend_u32(&mut self, arg0: u64) -> u64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let pattern0_0 = arg0;
    let mut iter = C::inst_data_etor(ctx, pattern0_0);
    while let Some((pattern1_0, pattern1_1)) = iter.next(ctx) {
        if pattern1_0 == I32 {
            if let &InstructionData::Binary {
                opcode: ref pattern3_0,
                args: ref pattern3_1,
            } = &pattern1_1
            {
                match pattern3_0 {
                    &Opcode::Band => {
                        let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                        let mut iter = C::inst_data_etor(ctx, pattern5_0);
                        while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                            if pattern6_0 == I32 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern8_0,
                                    imm: pattern8_1,
                                } = &pattern6_1
                                {
                                    if let &Opcode::Iconst = pattern8_0 {
                                        let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                        if pattern10_0 == 4294967295i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 122.
                                            let expr0_0 = C::subsume(ctx, pattern5_1);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern5_1);
                        while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                            if pattern6_0 == I32 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern8_0,
                                    imm: pattern8_1,
                                } = &pattern6_1
                                {
                                    if let &Opcode::Iconst = pattern8_0 {
                                        let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                        if pattern10_0 == 4294967295i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 121.
                                            let expr0_0 = C::subsume(ctx, pattern5_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                        let mut iter = C::inst_data_etor(ctx, pattern5_0);
                        while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                            if pattern6_0 == I32 {
                                if let &InstructionData::Unary {
                                    opcode: ref pattern8_0,
                                    arg: pattern8_1,
                                } = &pattern6_1
                                {
                                    if let &Opcode::Bnot = pattern8_0 {
                                        if pattern5_1 == pattern8_1 {
                                            // Rule at src/opts/algebraic.isle line 115.
                                            let expr0_0: Type = I32;
                                            let expr1_0: u64 = 4294967295i128 as u64;
                                            let expr2_0 = C::imm64(ctx, expr1_0);
                                            let expr3_0 = constructor_iconst(ctx, expr0_0, expr2_0);
                                            let expr4_0 = C::subsume(ctx, expr3_0);
                                            returns.push(expr4_0);
                                        }
                                    }
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern5_1);
                        while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                            if pattern6_0 == I32 {
                                if let &InstructionData::Unary {
                                    opcode: ref pattern8_0,
                                    arg: pattern8_1,
                                } = &pattern6_1
                                {
                                    if let &Opcode::Bnot = pattern8_0 {
                                        if pattern8_1 == pattern5_0 {
                                            // Rule at src/opts/algebraic.isle line 114.
                                            let expr0_0: Type = I32;
                                            let expr1_0: u64 = 4294967295i128 as u64;
                                            let expr2_0 = C::imm64(ctx, expr1_0);
                                            let expr3_0 = constructor_iconst(ctx, expr0_0, expr2_0);
                                            let expr4_0 = C::subsume(ctx, expr3_0);
                                            returns.push(expr4_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern1_0 == I64 {
            match &pattern1_1 {
                &InstructionData::Unary {
                    opcode: ref pattern3_0,
                    arg: pattern3_1,
                } => {
                    match pattern3_0 {
                        &Opcode::Uextend => {
                            let mut iter = C::inst_data_etor(ctx, pattern3_1);
                            while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                                if pattern5_0 == I32 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } = &pattern5_1
                                    {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            // Rule at src/opts/algebraic.isle line 10.
                                            let expr0_0: Type = I64;
                                            let expr1_0 = C::u64_uextend_u32(ctx, pattern9_0);
                                            let expr2_0 = C::imm64(ctx, expr1_0);
                                            let expr3_0 = constructor_iconst(ctx, expr0_0, expr2_0);
                                            returns.push(expr3_0);
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Sextend => {
                            let mut iter = C::inst_data_etor(ctx, pattern3_1);
                            while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                                if pattern5_0 == I32 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } = &pattern5_1
                                    {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            // Rule at src/opts/algebraic.isle line 12.
                                            let expr0_0: Type = I64;
                                            let expr1_0 = C::u64_sextend_u32(ctx, pattern9_0);
                                            let expr2_0 = C::imm64(ctx, expr1_0);
                                            let expr3_0 = constructor_iconst(ctx, expr0_0, expr2_0);
                                            returns.push(expr3_0);
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern3_0,
                    args: ref pattern3_1,
                } => {
                    match pattern3_0 {
                        &Opcode::Band => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == I64 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            if pattern10_0 == 18446744073709551615i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 124.
                                                let expr0_0 = C::subsume(ctx, pattern5_1);
                                                returns.push(expr0_0);
                                            }
                                        }
                                    }
                                }
                            }
                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == I64 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            if pattern10_0 == 18446744073709551615i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 123.
                                                let expr0_0 = C::subsume(ctx, pattern5_0);
                                                returns.push(expr0_0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bxor => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref pattern8_0,
                                        arg: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Bnot = pattern8_0 {
                                            if pattern5_1 == pattern8_1 {
                                                // Rule at src/opts/algebraic.isle line 117.
                                                let expr0_0: Type = I64;
                                                let expr1_0: u64 = 18446744073709551615i128 as u64;
                                                let expr2_0 = C::imm64(ctx, expr1_0);
                                                let expr3_0 =
                                                    constructor_iconst(ctx, expr0_0, expr2_0);
                                                let expr4_0 = C::subsume(ctx, expr3_0);
                                                returns.push(expr4_0);
                                            }
                                        }
                                    }
                                }
                            }
                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref pattern8_0,
                                        arg: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Bnot = pattern8_0 {
                                            if pattern8_1 == pattern5_0 {
                                                // Rule at src/opts/algebraic.isle line 116.
                                                let expr0_0: Type = I64;
                                                let expr1_0: u64 = 18446744073709551615i128 as u64;
                                                let expr2_0 = C::imm64(ctx, expr1_0);
                                                let expr3_0 =
                                                    constructor_iconst(ctx, expr0_0, expr2_0);
                                                let expr4_0 = C::subsume(ctx, expr3_0);
                                                returns.push(expr4_0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Ushr => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == I64 {
                                    if let &InstructionData::Binary {
                                        opcode: ref pattern8_0,
                                        args: ref pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Ishl = pattern8_0 {
                                            let (pattern10_0, pattern10_1) =
                                                C::unpack_value_array_2(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern10_0);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == I64 {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref pattern13_0,
                                                        arg: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Uextend = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::value_type(ctx, pattern13_1);
                                                            if pattern15_0 == I32 {
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx,
                                                                    pattern10_1,
                                                                );
                                                                while let Some((
                                                                    pattern17_0,
                                                                    pattern17_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern17_1 {
                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                            if let Some(pattern20_0) = C::simm32(ctx, pattern18_1) {
                                                                                if pattern20_0 == 32i128 as u32  {
                                                                                    let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                                                                    while let Some((pattern22_0, pattern22_1)) = iter.next(ctx) {
                                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern23_0, imm: pattern23_1 } = &pattern22_1 {
                                                                                            if let &Opcode::Iconst  = pattern23_0 {
                                                                                                if let Some(pattern25_0) = C::simm32(ctx, pattern23_1) {
                                                                                                    if pattern25_0 == 32i128 as u32  {
                                                                                                        // Rule at src/opts/algebraic.isle line 148.
                                                                                                        let expr0_0: Type = I64;
                                                                                                        let expr1_0 = constructor_uextend(ctx, expr0_0, pattern13_1);
                                                                                                        returns.push(expr1_0);
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Sshr => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == I64 {
                                    if let &InstructionData::Binary {
                                        opcode: ref pattern8_0,
                                        args: ref pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Ishl = pattern8_0 {
                                            let (pattern10_0, pattern10_1) =
                                                C::unpack_value_array_2(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern10_0);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == I64 {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref pattern13_0,
                                                        arg: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Uextend = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::value_type(ctx, pattern13_1);
                                                            if pattern15_0 == I32 {
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx,
                                                                    pattern10_1,
                                                                );
                                                                while let Some((
                                                                    pattern17_0,
                                                                    pattern17_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm { opcode: ref pattern18_0, imm: pattern18_1 } = &pattern17_1 {
                                                                        if let &Opcode::Iconst  = pattern18_0 {
                                                                            if let Some(pattern20_0) = C::simm32(ctx, pattern18_1) {
                                                                                if pattern20_0 == 32i128 as u32  {
                                                                                    let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                                                                    while let Some((pattern22_0, pattern22_1)) = iter.next(ctx) {
                                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern23_0, imm: pattern23_1 } = &pattern22_1 {
                                                                                            if let &Opcode::Iconst  = pattern23_0 {
                                                                                                if let Some(pattern25_0) = C::simm32(ctx, pattern23_1) {
                                                                                                    if pattern25_0 == 32i128 as u32  {
                                                                                                        // Rule at src/opts/algebraic.isle line 151.
                                                                                                        let expr0_0: Type = I64;
                                                                                                        let expr1_0 = constructor_sextend(ctx, expr0_0, pattern13_1);
                                                                                                        returns.push(expr1_0);
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        match &pattern1_1 {
            &InstructionData::Unary {
                opcode: ref pattern2_0,
                arg: pattern2_1,
            } => {
                if let &Opcode::Bnot = pattern2_0 {
                    let mut iter = C::inst_data_etor(ctx, pattern2_1);
                    while let Some((pattern4_0, pattern4_1)) = iter.next(ctx) {
                        if pattern4_0 == pattern1_0 {
                            match &pattern4_1 {
                                &InstructionData::Unary {
                                    opcode: ref pattern6_0,
                                    arg: pattern6_1,
                                } => {
                                    if let &Opcode::Bnot = pattern6_0 {
                                        // Rule at src/opts/algebraic.isle line 131.
                                        let expr0_0 = C::subsume(ctx, pattern6_1);
                                        returns.push(expr0_0);
                                    }
                                }
                                &InstructionData::Binary {
                                    opcode: ref pattern6_0,
                                    args: ref pattern6_1,
                                } => {
                                    if let &Opcode::Bor = pattern6_0 {
                                        let (pattern8_0, pattern8_1) =
                                            C::unpack_value_array_2(ctx, pattern6_1);
                                        // Rule at src/opts/algebraic.isle line 135.
                                        let expr0_0 = constructor_bnot(ctx, pattern1_0, pattern8_0);
                                        let expr1_0 = constructor_bnot(ctx, pattern1_0, pattern8_1);
                                        let expr2_0 =
                                            constructor_band(ctx, pattern1_0, expr0_0, expr1_0);
                                        returns.push(expr2_0);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if let &InstructionData::Binary {
                            opcode: ref pattern5_0,
                            args: ref pattern5_1,
                        } = &pattern4_1
                        {
                            if let &Opcode::Band = pattern5_0 {
                                let (pattern7_0, pattern7_1) =
                                    C::unpack_value_array_2(ctx, pattern5_1);
                                // Rule at src/opts/algebraic.isle line 138.
                                let expr0_0 = constructor_bnot(ctx, pattern1_0, pattern7_0);
                                let expr1_0 = constructor_bnot(ctx, pattern1_0, pattern7_1);
                                let expr2_0 = constructor_bor(ctx, pattern1_0, expr0_0, expr1_0);
                                returns.push(expr2_0);
                            }
                        }
                    }
                    // Rule at src/opts/algebraic.isle line 180.
                    let expr0_0 = C::remat(ctx, pattern0_0);
                    returns.push(expr0_0);
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref pattern2_0,
                imm: pattern2_1,
            } => {
                if let &Opcode::F32const = pattern2_0 {
                    // Rule at src/opts/algebraic.isle line 184.
                    let expr0_0 = C::remat(ctx, pattern0_0);
                    returns.push(expr0_0);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref pattern2_0,
                imm: pattern2_1,
            } => {
                if let &Opcode::F64const = pattern2_0 {
                    // Rule at src/opts/algebraic.isle line 186.
                    let expr0_0 = C::remat(ctx, pattern0_0);
                    returns.push(expr0_0);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref pattern2_0,
                imm: pattern2_1,
            } => {
                if let &Opcode::Iconst = pattern2_0 {
                    // Rule at src/opts/algebraic.isle line 182.
                    let expr0_0 = C::remat(ctx, pattern0_0);
                    returns.push(expr0_0);
                }
            }
            &InstructionData::Binary {
                opcode: ref pattern2_0,
                args: ref pattern2_1,
            } => {
                match pattern2_0 {
                    &Opcode::Iadd => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_0);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                match &pattern5_1 {
                                    &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } => {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            if pattern9_0 == 0i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 20.
                                                let expr0_0 = C::subsume(ctx, pattern4_1);
                                                returns.push(expr0_0);
                                            }
                                            // Rule at src/opts/cprop.isle line 62.
                                            let expr0_0 = constructor_iadd(
                                                ctx, pattern1_0, pattern4_1, pattern4_0,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                    &InstructionData::Binary {
                                        opcode: ref pattern7_0,
                                        args: ref pattern7_1,
                                    } => {
                                        match pattern7_0 {
                                            &Opcode::Iadd => {
                                                let (pattern9_0, pattern9_1) =
                                                    C::unpack_value_array_2(ctx, pattern7_1);
                                                let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                                while let Some((pattern10_0, pattern10_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if pattern10_0 == pattern1_0 {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern12_0,
                                                            imm: pattern12_1,
                                                        } = &pattern10_1
                                                        {
                                                            if let &Opcode::Iconst = pattern12_0 {
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx, pattern4_1,
                                                                );
                                                                while let Some((
                                                                    pattern14_0,
                                                                    pattern14_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern14_0 == pattern1_0 {
                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern16_0, imm: pattern16_1 } = &pattern14_1 {
                                                                            if let &Opcode::Iconst  = pattern16_0 {
                                                                                // Rule at src/opts/cprop.isle line 89.
                                                                                let expr0_0 = constructor_iadd(ctx, pattern1_0, pattern9_1, pattern4_1);
                                                                                let expr1_0 = constructor_iadd(ctx, pattern1_0, pattern9_0, expr0_0);
                                                                                returns.push(expr1_0);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::Isub => {
                                                let (pattern9_0, pattern9_1) =
                                                    C::unpack_value_array_2(ctx, pattern7_1);
                                                let mut iter = C::inst_data_etor(ctx, pattern9_0);
                                                while let Some((pattern10_0, pattern10_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if pattern10_0 == pattern1_0 {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern12_0,
                                                            imm: pattern12_1,
                                                        } = &pattern10_1
                                                        {
                                                            if let &Opcode::Iconst = pattern12_0 {
                                                                let pattern14_0 = C::u64_from_imm64(
                                                                    ctx,
                                                                    pattern12_1,
                                                                );
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx, pattern4_1,
                                                                );
                                                                while let Some((
                                                                    pattern15_0,
                                                                    pattern15_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern15_0 == pattern1_0 {
                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                            if let &Opcode::Iconst  = pattern17_0 {
                                                                                let pattern19_0 = C::u64_from_imm64(ctx, pattern17_1);
                                                                                // Rule at src/opts/cprop.isle line 115.
                                                                                let expr0_0 = C::u64_add(ctx, pattern14_0, pattern19_0);
                                                                                let expr1_0 = C::imm64_masked(ctx, pattern1_0, expr0_0);
                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0);
                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, expr2_0, pattern9_1);
                                                                                returns.push(expr3_0);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                                while let Some((pattern10_0, pattern10_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if pattern10_0 == pattern1_0 {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern12_0,
                                                            imm: pattern12_1,
                                                        } = &pattern10_1
                                                        {
                                                            if let &Opcode::Iconst = pattern12_0 {
                                                                let pattern14_0 = C::u64_from_imm64(
                                                                    ctx,
                                                                    pattern12_1,
                                                                );
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx, pattern4_1,
                                                                );
                                                                while let Some((
                                                                    pattern15_0,
                                                                    pattern15_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern15_0 == pattern1_0 {
                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                            if let &Opcode::Iconst  = pattern17_0 {
                                                                                let pattern19_0 = C::u64_from_imm64(ctx, pattern17_1);
                                                                                // Rule at src/opts/cprop.isle line 111.
                                                                                let expr0_0 = C::u64_sub(ctx, pattern19_0, pattern14_0);
                                                                                let expr1_0 = C::imm64_masked(ctx, pattern1_0, expr0_0);
                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0);
                                                                                let expr3_0 = constructor_iadd(ctx, pattern1_0, pattern9_0, expr2_0);
                                                                                returns.push(expr3_0);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 160.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 16.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 162.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_0);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                match &pattern5_1 {
                                    &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } => {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            if pattern9_0 == 0i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 30.
                                                let expr0_0 =
                                                    constructor_ineg(ctx, pattern1_0, pattern4_1);
                                                returns.push(expr0_0);
                                            }
                                            // Rule at src/opts/cprop.isle line 67.
                                            let expr0_0 = constructor_isub(
                                                ctx, pattern1_0, pattern4_1, pattern4_0,
                                            );
                                            let expr1_0 =
                                                constructor_ineg(ctx, pattern1_0, expr0_0);
                                            returns.push(expr1_0);
                                        }
                                    }
                                    &InstructionData::Binary {
                                        opcode: ref pattern7_0,
                                        args: ref pattern7_1,
                                    } => {
                                        match pattern7_0 {
                                            &Opcode::Iadd => {
                                                let (pattern9_0, pattern9_1) =
                                                    C::unpack_value_array_2(ctx, pattern7_1);
                                                let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                                while let Some((pattern10_0, pattern10_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if pattern10_0 == pattern1_0 {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern12_0,
                                                            imm: pattern12_1,
                                                        } = &pattern10_1
                                                        {
                                                            if let &Opcode::Iconst = pattern12_0 {
                                                                let pattern14_0 = C::u64_from_imm64(
                                                                    ctx,
                                                                    pattern12_1,
                                                                );
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx, pattern4_1,
                                                                );
                                                                while let Some((
                                                                    pattern15_0,
                                                                    pattern15_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern15_0 == pattern1_0 {
                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                            if let &Opcode::Iconst  = pattern17_0 {
                                                                                let pattern19_0 = C::u64_from_imm64(ctx, pattern17_1);
                                                                                // Rule at src/opts/cprop.isle line 107.
                                                                                let expr0_0 = C::u64_sub(ctx, pattern19_0, pattern14_0);
                                                                                let expr1_0 = C::imm64_masked(ctx, pattern1_0, expr0_0);
                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0);
                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, pattern9_0, expr2_0);
                                                                                returns.push(expr3_0);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::Isub => {
                                                let (pattern9_0, pattern9_1) =
                                                    C::unpack_value_array_2(ctx, pattern7_1);
                                                let mut iter = C::inst_data_etor(ctx, pattern9_0);
                                                while let Some((pattern10_0, pattern10_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if pattern10_0 == pattern1_0 {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern12_0,
                                                            imm: pattern12_1,
                                                        } = &pattern10_1
                                                        {
                                                            if let &Opcode::Iconst = pattern12_0 {
                                                                let pattern14_0 = C::u64_from_imm64(
                                                                    ctx,
                                                                    pattern12_1,
                                                                );
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx, pattern4_1,
                                                                );
                                                                while let Some((
                                                                    pattern15_0,
                                                                    pattern15_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern15_0 == pattern1_0 {
                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                            if let &Opcode::Iconst  = pattern17_0 {
                                                                                let pattern19_0 = C::u64_from_imm64(ctx, pattern17_1);
                                                                                // Rule at src/opts/cprop.isle line 103.
                                                                                let expr0_0 = C::u64_sub(ctx, pattern14_0, pattern19_0);
                                                                                let expr1_0 = C::imm64_masked(ctx, pattern1_0, expr0_0);
                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0);
                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, expr2_0, pattern9_1);
                                                                                returns.push(expr3_0);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                                while let Some((pattern10_0, pattern10_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if pattern10_0 == pattern1_0 {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref pattern12_0,
                                                            imm: pattern12_1,
                                                        } = &pattern10_1
                                                        {
                                                            if let &Opcode::Iconst = pattern12_0 {
                                                                let pattern14_0 = C::u64_from_imm64(
                                                                    ctx,
                                                                    pattern12_1,
                                                                );
                                                                let mut iter = C::inst_data_etor(
                                                                    ctx, pattern4_1,
                                                                );
                                                                while let Some((
                                                                    pattern15_0,
                                                                    pattern15_1,
                                                                )) = iter.next(ctx)
                                                                {
                                                                    if pattern15_0 == pattern1_0 {
                                                                        if let &InstructionData::UnaryImm { opcode: ref pattern17_0, imm: pattern17_1 } = &pattern15_1 {
                                                                            if let &Opcode::Iconst  = pattern17_0 {
                                                                                let pattern19_0 = C::u64_from_imm64(ctx, pattern17_1);
                                                                                // Rule at src/opts/cprop.isle line 99.
                                                                                let expr0_0 = C::u64_add(ctx, pattern14_0, pattern19_0);
                                                                                let expr1_0 = C::imm64_masked(ctx, pattern1_0, expr0_0);
                                                                                let expr2_0 = constructor_iconst(ctx, pattern1_0, expr1_0);
                                                                                let expr3_0 = constructor_isub(ctx, pattern1_0, pattern9_0, expr2_0);
                                                                                returns.push(expr3_0);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 164.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 25.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 166.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_0);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                match &pattern5_1 {
                                    &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } => {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            if pattern9_0 == 0i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 50.
                                                let expr0_0: u64 = 0i128 as u64;
                                                let expr1_0 = C::imm64(ctx, expr0_0);
                                                let expr2_0 =
                                                    constructor_iconst(ctx, pattern1_0, expr1_0);
                                                returns.push(expr2_0);
                                            }
                                            if pattern9_0 == 1i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 40.
                                                let expr0_0 = C::subsume(ctx, pattern4_1);
                                                returns.push(expr0_0);
                                            }
                                            // Rule at src/opts/cprop.isle line 70.
                                            let expr0_0 = constructor_imul(
                                                ctx, pattern1_0, pattern4_1, pattern4_0,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                    &InstructionData::Binary {
                                        opcode: ref pattern7_0,
                                        args: ref pattern7_1,
                                    } => {
                                        if let &Opcode::Imul = pattern7_0 {
                                            let (pattern9_0, pattern9_1) =
                                                C::unpack_value_array_2(ctx, pattern7_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                            while let Some((pattern10_0, pattern10_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern10_0 == pattern1_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern12_0,
                                                        imm: pattern12_1,
                                                    } = &pattern10_1
                                                    {
                                                        if let &Opcode::Iconst = pattern12_0 {
                                                            let mut iter =
                                                                C::inst_data_etor(ctx, pattern4_1);
                                                            while let Some((
                                                                pattern14_0,
                                                                pattern14_1,
                                                            )) = iter.next(ctx)
                                                            {
                                                                if pattern14_0 == pattern1_0 {
                                                                    if let &InstructionData::UnaryImm { opcode: ref pattern16_0, imm: pattern16_1 } = &pattern14_1 {
                                                                        if let &Opcode::Iconst  = pattern16_0 {
                                                                            // Rule at src/opts/cprop.isle line 120.
                                                                            let expr0_0 = constructor_imul(ctx, pattern1_0, pattern9_1, pattern4_1);
                                                                            let expr1_0 = constructor_imul(ctx, pattern1_0, pattern9_0, expr0_0);
                                                                            returns.push(expr1_0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    if let Some(pattern8_0) = C::simm32(ctx, pattern6_1) {
                                        if pattern8_0 == 2i128 as u32 {
                                            // Rule at src/opts/algebraic.isle line 144.
                                            let expr0_0 = constructor_iadd(
                                                ctx, pattern1_0, pattern4_1, pattern4_1,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 46.
                                            let expr0_0: u64 = 0i128 as u64;
                                            let expr1_0 = C::imm64(ctx, expr0_0);
                                            let expr2_0 =
                                                constructor_iconst(ctx, pattern1_0, expr1_0);
                                            returns.push(expr2_0);
                                        }
                                        if pattern9_0 == 1i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 36.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    if let Some(pattern8_0) = C::simm32(ctx, pattern6_1) {
                                        if pattern8_0 == 2i128 as u32 {
                                            // Rule at src/opts/algebraic.isle line 142.
                                            let expr0_0 = constructor_iadd(
                                                ctx, pattern1_0, pattern4_0, pattern4_0,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 1i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 60.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 1i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 56.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        if pattern4_1 == pattern4_0 {
                            // Rule at src/opts/algebraic.isle line 120.
                            returns.push(pattern4_0);
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_0);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                match &pattern5_1 {
                                    &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } => {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            if pattern9_0 == 0i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 128.
                                                let expr0_0: u64 = 0i128 as u64;
                                                let expr1_0 = C::imm64(ctx, expr0_0);
                                                let expr2_0 =
                                                    constructor_iconst(ctx, pattern1_0, expr1_0);
                                                returns.push(expr2_0);
                                            }
                                            // Rule at src/opts/cprop.isle line 77.
                                            let expr0_0 = constructor_band(
                                                ctx, pattern1_0, pattern4_1, pattern4_0,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                    &InstructionData::Binary {
                                        opcode: ref pattern7_0,
                                        args: ref pattern7_1,
                                    } => {
                                        if let &Opcode::Band = pattern7_0 {
                                            let (pattern9_0, pattern9_1) =
                                                C::unpack_value_array_2(ctx, pattern7_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                            while let Some((pattern10_0, pattern10_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern10_0 == pattern1_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern12_0,
                                                        imm: pattern12_1,
                                                    } = &pattern10_1
                                                    {
                                                        if let &Opcode::Iconst = pattern12_0 {
                                                            let mut iter =
                                                                C::inst_data_etor(ctx, pattern4_1);
                                                            while let Some((
                                                                pattern14_0,
                                                                pattern14_1,
                                                            )) = iter.next(ctx)
                                                            {
                                                                if pattern14_0 == pattern1_0 {
                                                                    if let &InstructionData::UnaryImm { opcode: ref pattern16_0, imm: pattern16_1 } = &pattern14_1 {
                                                                        if let &Opcode::Iconst  = pattern16_0 {
                                                                            // Rule at src/opts/cprop.isle line 126.
                                                                            let expr0_0 = constructor_band(ctx, pattern1_0, pattern9_1, pattern4_1);
                                                                            let expr1_0 = constructor_band(ctx, pattern1_0, pattern9_0, expr0_0);
                                                                            returns.push(expr1_0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 168.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 127.
                                            let expr0_0: u64 = 0i128 as u64;
                                            let expr1_0 = C::imm64(ctx, expr0_0);
                                            let expr2_0 =
                                                constructor_iconst(ctx, pattern1_0, expr1_0);
                                            returns.push(expr2_0);
                                        }
                                    }
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 170.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                    }
                    &Opcode::Bor => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        if pattern4_1 == pattern4_0 {
                            // Rule at src/opts/algebraic.isle line 96.
                            let expr0_0 = C::subsume(ctx, pattern4_0);
                            returns.push(expr0_0);
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_0);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                match &pattern5_1 {
                                    &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } => {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            if pattern9_0 == 0i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 92.
                                                let expr0_0 = C::subsume(ctx, pattern4_1);
                                                returns.push(expr0_0);
                                            }
                                            // Rule at src/opts/cprop.isle line 74.
                                            let expr0_0 = constructor_bor(
                                                ctx, pattern1_0, pattern4_1, pattern4_0,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                    &InstructionData::Binary {
                                        opcode: ref pattern7_0,
                                        args: ref pattern7_1,
                                    } => {
                                        if let &Opcode::Bor = pattern7_0 {
                                            let (pattern9_0, pattern9_1) =
                                                C::unpack_value_array_2(ctx, pattern7_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                            while let Some((pattern10_0, pattern10_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern10_0 == pattern1_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern12_0,
                                                        imm: pattern12_1,
                                                    } = &pattern10_1
                                                    {
                                                        if let &Opcode::Iconst = pattern12_0 {
                                                            let mut iter =
                                                                C::inst_data_etor(ctx, pattern4_1);
                                                            while let Some((
                                                                pattern14_0,
                                                                pattern14_1,
                                                            )) = iter.next(ctx)
                                                            {
                                                                if pattern14_0 == pattern1_0 {
                                                                    if let &InstructionData::UnaryImm { opcode: ref pattern16_0, imm: pattern16_1 } = &pattern14_1 {
                                                                        if let &Opcode::Iconst  = pattern16_0 {
                                                                            // Rule at src/opts/cprop.isle line 123.
                                                                            let expr0_0 = constructor_bor(ctx, pattern1_0, pattern9_1, pattern4_1);
                                                                            let expr1_0 = constructor_bor(ctx, pattern1_0, pattern9_0, expr0_0);
                                                                            returns.push(expr1_0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 172.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 88.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 174.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_0);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                match &pattern5_1 {
                                    &InstructionData::UnaryImm {
                                        opcode: ref pattern7_0,
                                        imm: pattern7_1,
                                    } => {
                                        if let &Opcode::Iconst = pattern7_0 {
                                            let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                            if pattern9_0 == 0i128 as u64 {
                                                // Rule at src/opts/algebraic.isle line 104.
                                                let expr0_0 = C::subsume(ctx, pattern4_1);
                                                returns.push(expr0_0);
                                            }
                                            // Rule at src/opts/cprop.isle line 80.
                                            let expr0_0 = constructor_bxor(
                                                ctx, pattern1_0, pattern4_1, pattern4_0,
                                            );
                                            returns.push(expr0_0);
                                        }
                                    }
                                    &InstructionData::Binary {
                                        opcode: ref pattern7_0,
                                        args: ref pattern7_1,
                                    } => {
                                        if let &Opcode::Bxor = pattern7_0 {
                                            let (pattern9_0, pattern9_1) =
                                                C::unpack_value_array_2(ctx, pattern7_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern9_1);
                                            while let Some((pattern10_0, pattern10_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern10_0 == pattern1_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern12_0,
                                                        imm: pattern12_1,
                                                    } = &pattern10_1
                                                    {
                                                        if let &Opcode::Iconst = pattern12_0 {
                                                            let mut iter =
                                                                C::inst_data_etor(ctx, pattern4_1);
                                                            while let Some((
                                                                pattern14_0,
                                                                pattern14_1,
                                                            )) = iter.next(ctx)
                                                            {
                                                                if pattern14_0 == pattern1_0 {
                                                                    if let &InstructionData::UnaryImm { opcode: ref pattern16_0, imm: pattern16_1 } = &pattern14_1 {
                                                                        if let &Opcode::Iconst  = pattern16_0 {
                                                                            // Rule at src/opts/cprop.isle line 129.
                                                                            let expr0_0 = constructor_bxor(ctx, pattern1_0, pattern9_1, pattern4_1);
                                                                            let expr1_0 = constructor_bxor(ctx, pattern1_0, pattern9_0, expr0_0);
                                                                            returns.push(expr1_0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 176.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 100.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } = &pattern5_1
                            {
                                if let &Opcode::Iconst = pattern6_0 {
                                    // Rule at src/opts/algebraic.isle line 178.
                                    let expr0_0 = C::remat(ctx, pattern0_0);
                                    returns.push(expr0_0);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 82.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 78.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 66.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 70.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                        let mut iter = C::inst_data_etor(ctx, pattern4_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern1_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        if pattern9_0 == 0i128 as u64 {
                                            // Rule at src/opts/algebraic.isle line 74.
                                            let expr0_0 = C::subsume(ctx, pattern4_0);
                                            returns.push(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref pattern2_0,
                args: ref pattern2_1,
                cond: ref pattern2_2,
            } => {
                if let &Opcode::Icmp = pattern2_0 {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let mut iter = C::inst_data_etor(ctx, pattern4_0);
                    while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                        if let &InstructionData::Unary {
                            opcode: ref pattern6_0,
                            arg: pattern6_1,
                        } = &pattern5_1
                        {
                            if let &Opcode::Uextend = pattern6_0 {
                                let mut iter = C::inst_data_etor(ctx, pattern6_1);
                                while let Some((pattern8_0, pattern8_1)) = iter.next(ctx) {
                                    if pattern8_0 == pattern1_0 {
                                        if let &InstructionData::IntCompare {
                                            opcode: ref pattern10_0,
                                            args: ref pattern10_1,
                                            cond: ref pattern10_2,
                                        } = &pattern8_1
                                        {
                                            if let &Opcode::Icmp = pattern10_0 {
                                                let (pattern12_0, pattern12_1) =
                                                    C::unpack_value_array_2(ctx, pattern10_1);
                                                let mut iter = C::inst_data_etor(ctx, pattern4_1);
                                                while let Some((pattern13_0, pattern13_1)) =
                                                    iter.next(ctx)
                                                {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern14_0,
                                                        imm: pattern14_1,
                                                    } = &pattern13_1
                                                    {
                                                        if let &Opcode::Iconst = pattern14_0 {
                                                            let pattern16_0 =
                                                                C::u64_from_imm64(ctx, pattern14_1);
                                                            if pattern16_0 == 0i128 as u64 {
                                                                match pattern2_2 {
                                                                    &IntCC::Equal => {
                                                                        // Rule at src/opts/algebraic.isle line 196.
                                                                        let expr0_0 =
                                                                            C::intcc_inverse(
                                                                                ctx,
                                                                                pattern10_2,
                                                                            );
                                                                        let expr1_0 =
                                                                            constructor_icmp(
                                                                                ctx,
                                                                                pattern1_0,
                                                                                &expr0_0,
                                                                                pattern12_0,
                                                                                pattern12_1,
                                                                            );
                                                                        let expr2_0 = C::subsume(
                                                                            ctx, expr1_0,
                                                                        );
                                                                        returns.push(expr2_0);
                                                                    }
                                                                    &IntCC::NotEqual => {
                                                                        // Rule at src/opts/algebraic.isle line 190.
                                                                        let expr0_0 = C::subsume(
                                                                            ctx, pattern6_1,
                                                                        );
                                                                        returns.push(expr0_0);
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref pattern2_0,
                args: ref pattern2_1,
            } => {
                if let &Opcode::Select = pattern2_0 {
                    let (pattern4_0, pattern4_1, pattern4_2) =
                        C::unpack_value_array_3(ctx, pattern2_1);
                    let mut iter = C::inst_data_etor(ctx, pattern4_0);
                    while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                        match &pattern5_1 {
                            &InstructionData::Unary {
                                opcode: ref pattern6_0,
                                arg: pattern6_1,
                            } => {
                                if let &Opcode::Uextend = pattern6_0 {
                                    let mut iter = C::inst_data_etor(ctx, pattern6_1);
                                    while let Some((pattern8_0, pattern8_1)) = iter.next(ctx) {
                                        if let &InstructionData::IntCompare {
                                            opcode: ref pattern9_0,
                                            args: ref pattern9_1,
                                            cond: ref pattern9_2,
                                        } = &pattern8_1
                                        {
                                            if let &Opcode::Icmp = pattern9_0 {
                                                let (pattern11_0, pattern11_1) =
                                                    C::unpack_value_array_2(ctx, pattern9_1);
                                                // Rule at src/opts/algebraic.isle line 204.
                                                let expr0_0 = constructor_select(
                                                    ctx, pattern1_0, pattern6_1, pattern4_1,
                                                    pattern4_2,
                                                );
                                                returns.push(expr0_0);
                                            }
                                        }
                                    }
                                }
                            }
                            &InstructionData::UnaryImm {
                                opcode: ref pattern6_0,
                                imm: pattern6_1,
                            } => {
                                if let &Opcode::Iconst = pattern6_0 {
                                    let pattern8_0 = C::u64_from_imm64(ctx, pattern6_1);
                                    if pattern8_0 == 0i128 as u64 {
                                        // Rule at src/opts/cprop.isle line 136.
                                        returns.push(pattern4_2);
                                    }
                                    let pattern9_0 = C::u64_is_zero(ctx, pattern8_0);
                                    if pattern9_0 == false {
                                        // Rule at src/opts/cprop.isle line 133.
                                        returns.push(pattern4_1);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            _ => {}
        }
        if let Some(pattern2_0) = C::fits_in_64(ctx, pattern1_0) {
            match &pattern1_1 {
                &InstructionData::Unary {
                    opcode: ref pattern3_0,
                    arg: pattern3_1,
                } => {
                    if let &Opcode::Bnot = pattern3_0 {
                        let mut iter = C::inst_data_etor(ctx, pattern3_1);
                        while let Some((pattern5_0, pattern5_1)) = iter.next(ctx) {
                            if pattern5_0 == pattern2_0 {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern7_0,
                                    imm: pattern7_1,
                                } = &pattern5_1
                                {
                                    if let &Opcode::Iconst = pattern7_0 {
                                        let pattern9_0 = C::u64_from_imm64(ctx, pattern7_1);
                                        // Rule at src/opts/cprop.isle line 53.
                                        let expr0_0 = C::u64_not(ctx, pattern9_0);
                                        let expr1_0 = C::imm64_masked(ctx, pattern2_0, expr0_0);
                                        let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                        let expr3_0 = C::subsume(ctx, expr2_0);
                                        returns.push(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern3_0,
                    args: ref pattern3_1,
                } => {
                    match pattern3_0 {
                        &Opcode::Iadd => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            // Rule at src/opts/cprop.isle line 3.
                                                            let expr0_0 = C::u64_add(
                                                                ctx,
                                                                pattern10_0,
                                                                pattern15_0,
                                                            );
                                                            let expr1_0 = C::imm64_masked(
                                                                ctx, pattern2_0, expr0_0,
                                                            );
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern2_0, expr1_0,
                                                            );
                                                            let expr3_0 = C::subsume(ctx, expr2_0);
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Isub => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            // Rule at src/opts/cprop.isle line 9.
                                                            let expr0_0 = C::u64_sub(
                                                                ctx,
                                                                pattern10_0,
                                                                pattern15_0,
                                                            );
                                                            let expr1_0 = C::imm64_masked(
                                                                ctx, pattern2_0, expr0_0,
                                                            );
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern2_0, expr1_0,
                                                            );
                                                            let expr3_0 = C::subsume(ctx, expr2_0);
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Imul => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            // Rule at src/opts/cprop.isle line 15.
                                                            let expr0_0 = C::u64_mul(
                                                                ctx,
                                                                pattern10_0,
                                                                pattern15_0,
                                                            );
                                                            let expr1_0 = C::imm64_masked(
                                                                ctx, pattern2_0, expr0_0,
                                                            );
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern2_0, expr1_0,
                                                            );
                                                            let expr3_0 = C::subsume(ctx, expr2_0);
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Udiv => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            let mut closure16 = || {
                                                                let expr0_0 = C::u64_udiv(
                                                                    ctx,
                                                                    pattern10_0,
                                                                    pattern15_0,
                                                                )?;
                                                                return Some(expr0_0);
                                                            };
                                                            if let Some(pattern16_0) = closure16() {
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                let expr0_0 = C::imm64_masked(
                                                                    ctx,
                                                                    pattern2_0,
                                                                    pattern16_0,
                                                                );
                                                                let expr1_0 = constructor_iconst(
                                                                    ctx, pattern2_0, expr0_0,
                                                                );
                                                                let expr2_0 =
                                                                    C::subsume(ctx, expr1_0);
                                                                returns.push(expr2_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Sdiv => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            let mut closure16 = || {
                                                                let expr0_0 = C::u64_sdiv(
                                                                    ctx,
                                                                    pattern10_0,
                                                                    pattern15_0,
                                                                )?;
                                                                return Some(expr0_0);
                                                            };
                                                            if let Some(pattern16_0) = closure16() {
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                let expr0_0 = C::imm64_masked(
                                                                    ctx,
                                                                    pattern2_0,
                                                                    pattern16_0,
                                                                );
                                                                let expr1_0 = constructor_iconst(
                                                                    ctx, pattern2_0, expr0_0,
                                                                );
                                                                let expr2_0 =
                                                                    C::subsume(ctx, expr1_0);
                                                                returns.push(expr2_0);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Band => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            // Rule at src/opts/cprop.isle line 41.
                                                            let expr0_0 = C::u64_and(
                                                                ctx,
                                                                pattern10_0,
                                                                pattern15_0,
                                                            );
                                                            let expr1_0 = C::imm64_masked(
                                                                ctx, pattern2_0, expr0_0,
                                                            );
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern2_0, expr1_0,
                                                            );
                                                            let expr3_0 = C::subsume(ctx, expr2_0);
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bor => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            // Rule at src/opts/cprop.isle line 35.
                                                            let expr0_0 = C::u64_or(
                                                                ctx,
                                                                pattern10_0,
                                                                pattern15_0,
                                                            );
                                                            let expr1_0 = C::imm64_masked(
                                                                ctx, pattern2_0, expr0_0,
                                                            );
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern2_0, expr1_0,
                                                            );
                                                            let expr3_0 = C::subsume(ctx, expr2_0);
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &Opcode::Bxor => {
                            let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                            if pattern5_1 == pattern5_0 {
                                // Rule at src/opts/algebraic.isle line 110.
                                let expr0_0: u64 = 0i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                let expr3_0 = C::subsume(ctx, expr2_0);
                                returns.push(expr3_0);
                            }
                            let mut iter = C::inst_data_etor(ctx, pattern5_0);
                            while let Some((pattern6_0, pattern6_1)) = iter.next(ctx) {
                                if pattern6_0 == pattern2_0 {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref pattern8_0,
                                        imm: pattern8_1,
                                    } = &pattern6_1
                                    {
                                        if let &Opcode::Iconst = pattern8_0 {
                                            let pattern10_0 = C::u64_from_imm64(ctx, pattern8_1);
                                            let mut iter = C::inst_data_etor(ctx, pattern5_1);
                                            while let Some((pattern11_0, pattern11_1)) =
                                                iter.next(ctx)
                                            {
                                                if pattern11_0 == pattern2_0 {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref pattern13_0,
                                                        imm: pattern13_1,
                                                    } = &pattern11_1
                                                    {
                                                        if let &Opcode::Iconst = pattern13_0 {
                                                            let pattern15_0 =
                                                                C::u64_from_imm64(ctx, pattern13_1);
                                                            // Rule at src/opts/cprop.isle line 47.
                                                            let expr0_0 = C::u64_xor(
                                                                ctx,
                                                                pattern10_0,
                                                                pattern15_0,
                                                            );
                                                            let expr1_0 = C::imm64_masked(
                                                                ctx, pattern2_0, expr0_0,
                                                            );
                                                            let expr2_0 = constructor_iconst(
                                                                ctx, pattern2_0, expr1_0,
                                                            );
                                                            let expr3_0 = C::subsume(ctx, expr2_0);
                                                            returns.push(expr3_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern2_0) = C::ty_int(ctx, pattern1_0) {
            if let &InstructionData::IntCompare {
                opcode: ref pattern3_0,
                args: ref pattern3_1,
                cond: ref pattern3_2,
            } = &pattern1_1
            {
                if let &Opcode::Icmp = pattern3_0 {
                    let (pattern5_0, pattern5_1) = C::unpack_value_array_2(ctx, pattern3_1);
                    if pattern5_1 == pattern5_0 {
                        match pattern3_2 {
                            &IntCC::Equal => {
                                // Rule at src/opts/algebraic.isle line 213.
                                let expr0_0: u64 = 1i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::NotEqual => {
                                // Rule at src/opts/algebraic.isle line 216.
                                let expr0_0: u64 = 0i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::SignedGreaterThan => {
                                // Rule at src/opts/algebraic.isle line 225.
                                let expr0_0: u64 = 0i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::SignedGreaterThanOrEqual => {
                                // Rule at src/opts/algebraic.isle line 228.
                                let expr0_0: u64 = 1i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::SignedLessThan => {
                                // Rule at src/opts/algebraic.isle line 237.
                                let expr0_0: u64 = 0i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::SignedLessThanOrEqual => {
                                // Rule at src/opts/algebraic.isle line 240.
                                let expr0_0: u64 = 1i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::UnsignedGreaterThan => {
                                // Rule at src/opts/algebraic.isle line 219.
                                let expr0_0: u64 = 0i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::UnsignedGreaterThanOrEqual => {
                                // Rule at src/opts/algebraic.isle line 222.
                                let expr0_0: u64 = 1i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::UnsignedLessThan => {
                                // Rule at src/opts/algebraic.isle line 231.
                                let expr0_0: u64 = 0i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            &IntCC::UnsignedLessThanOrEqual => {
                                // Rule at src/opts/algebraic.isle line 234.
                                let expr0_0: u64 = 1i128 as u64;
                                let expr1_0 = C::imm64(ctx, expr0_0);
                                let expr2_0 = constructor_iconst(ctx, pattern2_0, expr1_0);
                                returns.push(expr2_0);
                            }
                            _ => {}
                        }
                    }
                }
            }
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term br_table.
pub fn constructor_br_table<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Block,
    arg3: JumpTable,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 348.
    let expr0_0 = Opcode::BrTable;
    let expr1_0 = InstructionData::BranchTable {
        opcode: expr0_0,
        arg: pattern1_0,
        destination: pattern2_0,
        table: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term debugtrap.
pub fn constructor_debugtrap<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 357.
    let expr0_0 = Opcode::Debugtrap;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term trap.
pub fn constructor_trap<C: Context>(ctx: &mut C, arg0: Type, arg1: &TrapCode) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 366.
    let expr0_0 = Opcode::Trap;
    let expr1_0 = InstructionData::Trap {
        opcode: expr0_0,
        code: pattern1_0.clone(),
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term trapz.
pub fn constructor_trapz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: &TrapCode,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 375.
    let expr0_0 = Opcode::Trapz;
    let expr1_0 = InstructionData::CondTrap {
        opcode: expr0_0,
        arg: pattern1_0,
        code: pattern2_0.clone(),
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term resumable_trap.
pub fn constructor_resumable_trap<C: Context>(ctx: &mut C, arg0: Type, arg1: &TrapCode) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 384.
    let expr0_0 = Opcode::ResumableTrap;
    let expr1_0 = InstructionData::Trap {
        opcode: expr0_0,
        code: pattern1_0.clone(),
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term trapnz.
pub fn constructor_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: &TrapCode,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 393.
    let expr0_0 = Opcode::Trapnz;
    let expr1_0 = InstructionData::CondTrap {
        opcode: expr0_0,
        arg: pattern1_0,
        code: pattern2_0.clone(),
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term resumable_trapnz.
pub fn constructor_resumable_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: &TrapCode,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 402.
    let expr0_0 = Opcode::ResumableTrapnz;
    let expr1_0 = InstructionData::CondTrap {
        opcode: expr0_0,
        arg: pattern1_0,
        code: pattern2_0.clone(),
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 411.
    let expr0_0 = Opcode::FuncAddr;
    let expr1_0 = InstructionData::FuncAddr {
        opcode: expr0_0,
        func_ref: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 420.
    let expr0_0 = Opcode::Splat;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 429.
    let expr0_0 = Opcode::Swizzle;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 438.
    let expr0_0 = Opcode::Insertlane;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::TernaryImm8 {
        opcode: expr0_0,
        args: expr1_0,
        imm: pattern3_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 447.
    let expr0_0 = Opcode::Extractlane;
    let expr1_0 = InstructionData::BinaryImm8 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 456.
    let expr0_0 = Opcode::Smin;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 465.
    let expr0_0 = Opcode::Umin;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 474.
    let expr0_0 = Opcode::Smax;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 483.
    let expr0_0 = Opcode::Umax;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 492.
    let expr0_0 = Opcode::AvgRound;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 501.
    let expr0_0 = Opcode::UaddSat;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 510.
    let expr0_0 = Opcode::SaddSat;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 519.
    let expr0_0 = Opcode::UsubSat;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 528.
    let expr0_0 = Opcode::SsubSat;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 537.
    let expr0_0 = Opcode::Load;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term store.
pub fn constructor_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 546.
    let expr0_0 = Opcode::Store;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Store {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 555.
    let expr0_0 = Opcode::Uload8;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 564.
    let expr0_0 = Opcode::Sload8;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term istore8.
pub fn constructor_istore8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 573.
    let expr0_0 = Opcode::Istore8;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Store {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 582.
    let expr0_0 = Opcode::Uload16;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 591.
    let expr0_0 = Opcode::Sload16;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term istore16.
pub fn constructor_istore16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 600.
    let expr0_0 = Opcode::Istore16;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Store {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 609.
    let expr0_0 = Opcode::Uload32;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 618.
    let expr0_0 = Opcode::Sload32;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term istore32.
pub fn constructor_istore32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 627.
    let expr0_0 = Opcode::Istore32;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Store {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
        offset: pattern4_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 636.
    let expr0_0 = Opcode::Uload8x8;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 645.
    let expr0_0 = Opcode::Sload8x8;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 654.
    let expr0_0 = Opcode::Uload16x4;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 663.
    let expr0_0 = Opcode::Sload16x4;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 672.
    let expr0_0 = Opcode::Uload32x2;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 681.
    let expr0_0 = Opcode::Sload32x2;
    let expr1_0 = InstructionData::Load {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 690.
    let expr0_0 = Opcode::StackLoad;
    let expr1_0 = InstructionData::StackLoad {
        opcode: expr0_0,
        stack_slot: pattern1_0,
        offset: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term stack_store.
pub fn constructor_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: StackSlot,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 699.
    let expr0_0 = Opcode::StackStore;
    let expr1_0 = InstructionData::StackStore {
        opcode: expr0_0,
        arg: pattern1_0,
        stack_slot: pattern2_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 708.
    let expr0_0 = Opcode::StackAddr;
    let expr1_0 = InstructionData::StackLoad {
        opcode: expr0_0,
        stack_slot: pattern1_0,
        offset: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 717.
    let expr0_0 = Opcode::DynamicStackLoad;
    let expr1_0 = InstructionData::DynamicStackLoad {
        opcode: expr0_0,
        dynamic_stack_slot: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term dynamic_stack_store.
pub fn constructor_dynamic_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: DynamicStackSlot,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 726.
    let expr0_0 = Opcode::DynamicStackStore;
    let expr1_0 = InstructionData::DynamicStackStore {
        opcode: expr0_0,
        arg: pattern1_0,
        dynamic_stack_slot: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 735.
    let expr0_0 = Opcode::DynamicStackAddr;
    let expr1_0 = InstructionData::DynamicStackLoad {
        opcode: expr0_0,
        dynamic_stack_slot: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 744.
    let expr0_0 = Opcode::GlobalValue;
    let expr1_0 = InstructionData::UnaryGlobalValue {
        opcode: expr0_0,
        global_value: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 753.
    let expr0_0 = Opcode::SymbolValue;
    let expr1_0 = InstructionData::UnaryGlobalValue {
        opcode: expr0_0,
        global_value: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 762.
    let expr0_0 = Opcode::TlsValue;
    let expr1_0 = InstructionData::UnaryGlobalValue {
        opcode: expr0_0,
        global_value: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 771.
    let expr0_0 = Opcode::GetPinnedReg;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term set_pinned_reg.
pub fn constructor_set_pinned_reg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 780.
    let expr0_0 = Opcode::SetPinnedReg;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 789.
    let expr0_0 = Opcode::GetFramePointer;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 798.
    let expr0_0 = Opcode::GetStackPointer;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 807.
    let expr0_0 = Opcode::GetReturnAddress;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 816.
    let expr0_0 = Opcode::TableAddr;
    let expr1_0 = InstructionData::TableAddr {
        opcode: expr0_0,
        arg: pattern2_0,
        table: pattern1_0,
        offset: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 825.
    let expr0_0 = Opcode::Iconst;
    let expr1_0 = InstructionData::UnaryImm {
        opcode: expr0_0,
        imm: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 834.
    let expr0_0 = Opcode::F32const;
    let expr1_0 = InstructionData::UnaryIeee32 {
        opcode: expr0_0,
        imm: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 843.
    let expr0_0 = Opcode::F64const;
    let expr1_0 = InstructionData::UnaryIeee64 {
        opcode: expr0_0,
        imm: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 852.
    let expr0_0 = Opcode::Vconst;
    let expr1_0 = InstructionData::UnaryConst {
        opcode: expr0_0,
        constant_handle: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 861.
    let expr0_0 = Opcode::Shuffle;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Shuffle {
        opcode: expr0_0,
        args: expr1_0,
        imm: pattern3_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 870.
    let expr0_0 = Opcode::Null;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term nop.
pub fn constructor_nop<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 879.
    let expr0_0 = Opcode::Nop;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 888.
    let expr0_0 = Opcode::Select;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 897.
    let expr0_0 = Opcode::SelectSpectreGuard;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 906.
    let expr0_0 = Opcode::Bitselect;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term vselect.
pub fn constructor_vselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 915.
    let expr0_0 = Opcode::Vselect;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 924.
    let expr0_0 = Opcode::VanyTrue;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 933.
    let expr0_0 = Opcode::VallTrue;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 942.
    let expr0_0 = Opcode::VhighBits;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 951.
    let expr0_0 = Opcode::Icmp;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::IntCompare {
        opcode: expr0_0,
        args: expr1_0,
        cond: pattern1_0.clone(),
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 960.
    let expr0_0 = Opcode::IcmpImm;
    let expr1_0 = InstructionData::IntCompareImm {
        opcode: expr0_0,
        arg: pattern2_0,
        cond: pattern1_0.clone(),
        imm: pattern3_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 969.
    let expr0_0 = Opcode::Iadd;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 978.
    let expr0_0 = Opcode::Isub;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 987.
    let expr0_0 = Opcode::Ineg;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 996.
    let expr0_0 = Opcode::Iabs;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1005.
    let expr0_0 = Opcode::Imul;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1014.
    let expr0_0 = Opcode::Umulhi;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1023.
    let expr0_0 = Opcode::Smulhi;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1032.
    let expr0_0 = Opcode::SqmulRoundSat;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1041.
    let expr0_0 = Opcode::Udiv;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1050.
    let expr0_0 = Opcode::Sdiv;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1059.
    let expr0_0 = Opcode::Urem;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1068.
    let expr0_0 = Opcode::Srem;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1077.
    let expr0_0 = Opcode::IaddImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1086.
    let expr0_0 = Opcode::ImulImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1095.
    let expr0_0 = Opcode::UdivImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1104.
    let expr0_0 = Opcode::SdivImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1113.
    let expr0_0 = Opcode::UremImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1122.
    let expr0_0 = Opcode::SremImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1131.
    let expr0_0 = Opcode::IrsubImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1140.
    let expr0_0 = Opcode::IaddCin;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term iadd_cout.
pub fn constructor_iadd_cout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1149.
    let expr0_0 = Opcode::IaddCout;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term iadd_carry.
pub fn constructor_iadd_carry<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1158.
    let expr0_0 = Opcode::IaddCarry;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1167.
    let expr0_0 = Opcode::UaddOverflowTrap;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::IntAddTrap {
        opcode: expr0_0,
        args: expr1_0,
        code: pattern3_0.clone(),
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1176.
    let expr0_0 = Opcode::IsubBin;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term isub_bout.
pub fn constructor_isub_bout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1185.
    let expr0_0 = Opcode::IsubBout;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term isub_borrow.
pub fn constructor_isub_borrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1194.
    let expr0_0 = Opcode::IsubBorrow;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1203.
    let expr0_0 = Opcode::Band;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1212.
    let expr0_0 = Opcode::Bor;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1221.
    let expr0_0 = Opcode::Bxor;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1230.
    let expr0_0 = Opcode::Bnot;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1239.
    let expr0_0 = Opcode::BandNot;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1248.
    let expr0_0 = Opcode::BorNot;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1257.
    let expr0_0 = Opcode::BxorNot;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1266.
    let expr0_0 = Opcode::BandImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1275.
    let expr0_0 = Opcode::BorImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1284.
    let expr0_0 = Opcode::BxorImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1293.
    let expr0_0 = Opcode::Rotl;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1302.
    let expr0_0 = Opcode::Rotr;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1311.
    let expr0_0 = Opcode::RotlImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1320.
    let expr0_0 = Opcode::RotrImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1329.
    let expr0_0 = Opcode::Ishl;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1338.
    let expr0_0 = Opcode::Ushr;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1347.
    let expr0_0 = Opcode::Sshr;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1356.
    let expr0_0 = Opcode::IshlImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1365.
    let expr0_0 = Opcode::UshrImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1374.
    let expr0_0 = Opcode::SshrImm;
    let expr1_0 = InstructionData::BinaryImm64 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1383.
    let expr0_0 = Opcode::Bitrev;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1392.
    let expr0_0 = Opcode::Clz;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1401.
    let expr0_0 = Opcode::Cls;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1410.
    let expr0_0 = Opcode::Ctz;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1419.
    let expr0_0 = Opcode::Bswap;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1428.
    let expr0_0 = Opcode::Popcnt;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1437.
    let expr0_0 = Opcode::Fcmp;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::FloatCompare {
        opcode: expr0_0,
        args: expr1_0,
        cond: pattern1_0.clone(),
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1446.
    let expr0_0 = Opcode::Fadd;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1455.
    let expr0_0 = Opcode::Fsub;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1464.
    let expr0_0 = Opcode::Fmul;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1473.
    let expr0_0 = Opcode::Fdiv;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1482.
    let expr0_0 = Opcode::Sqrt;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1491.
    let expr0_0 = Opcode::Fma;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern1_0, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::Ternary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1500.
    let expr0_0 = Opcode::Fneg;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1509.
    let expr0_0 = Opcode::Fabs;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1518.
    let expr0_0 = Opcode::Fcopysign;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1527.
    let expr0_0 = Opcode::Fmin;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1536.
    let expr0_0 = Opcode::FminPseudo;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1545.
    let expr0_0 = Opcode::Fmax;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1554.
    let expr0_0 = Opcode::FmaxPseudo;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1563.
    let expr0_0 = Opcode::Ceil;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1572.
    let expr0_0 = Opcode::Floor;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1581.
    let expr0_0 = Opcode::Trunc;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1590.
    let expr0_0 = Opcode::Nearest;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1599.
    let expr0_0 = Opcode::IsNull;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1608.
    let expr0_0 = Opcode::IsInvalid;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1617.
    let expr0_0 = Opcode::Bitcast;
    let expr1_0 = InstructionData::LoadNoOffset {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1626.
    let expr0_0 = Opcode::ScalarToVector;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1635.
    let expr0_0 = Opcode::Bmask;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1644.
    let expr0_0 = Opcode::Ireduce;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1653.
    let expr0_0 = Opcode::Snarrow;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1662.
    let expr0_0 = Opcode::Unarrow;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1671.
    let expr0_0 = Opcode::Uunarrow;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1680.
    let expr0_0 = Opcode::SwidenLow;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1689.
    let expr0_0 = Opcode::SwidenHigh;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1698.
    let expr0_0 = Opcode::UwidenLow;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1707.
    let expr0_0 = Opcode::UwidenHigh;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1716.
    let expr0_0 = Opcode::IaddPairwise;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term widening_pairwise_dot_product_s.
pub fn constructor_widening_pairwise_dot_product_s<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1725.
    let expr0_0 = Opcode::WideningPairwiseDotProductS;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1734.
    let expr0_0 = Opcode::Uextend;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1743.
    let expr0_0 = Opcode::Sextend;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1752.
    let expr0_0 = Opcode::Fpromote;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1761.
    let expr0_0 = Opcode::Fdemote;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1770.
    let expr0_0 = Opcode::Fvdemote;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1779.
    let expr0_0 = Opcode::FvpromoteLow;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1788.
    let expr0_0 = Opcode::FcvtToUint;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1797.
    let expr0_0 = Opcode::FcvtToSint;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1806.
    let expr0_0 = Opcode::FcvtToUintSat;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1815.
    let expr0_0 = Opcode::FcvtToSintSat;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1824.
    let expr0_0 = Opcode::FcvtFromUint;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1833.
    let expr0_0 = Opcode::FcvtFromSint;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term fcvt_low_from_sint.
pub fn constructor_fcvt_low_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1842.
    let expr0_0 = Opcode::FcvtLowFromSint;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term isplit.
pub fn constructor_isplit<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1851.
    let expr0_0 = Opcode::Isplit;
    let expr1_0 = InstructionData::Unary {
        opcode: expr0_0,
        arg: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1860.
    let expr0_0 = Opcode::Iconcat;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern1_0, pattern2_0);
    let expr2_0 = InstructionData::Binary {
        opcode: expr0_0,
        args: expr1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1869.
    let expr0_0 = Opcode::AtomicRmw;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern3_0, pattern4_0);
    let expr2_0 = InstructionData::AtomicRmw {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
        op: pattern2_0.clone(),
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1878.
    let expr0_0 = Opcode::AtomicCas;
    let expr1_0 = C::value_array_3_ctor(ctx, pattern2_0, pattern3_0, pattern4_0);
    let expr2_0 = InstructionData::AtomicCas {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1887.
    let expr0_0 = Opcode::AtomicLoad;
    let expr1_0 = InstructionData::LoadNoOffset {
        opcode: expr0_0,
        arg: pattern2_0,
        flags: pattern1_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term atomic_store.
pub fn constructor_atomic_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1896.
    let expr0_0 = Opcode::AtomicStore;
    let expr1_0 = C::value_array_2_ctor(ctx, pattern2_0, pattern3_0);
    let expr2_0 = InstructionData::StoreNoOffset {
        opcode: expr0_0,
        args: expr1_0,
        flags: pattern1_0,
    };
    let expr3_0 = C::make_inst_ctor(ctx, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term fence.
pub fn constructor_fence<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let pattern0_0 = arg0;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1905.
    let expr0_0 = Opcode::Fence;
    let expr1_0 = InstructionData::NullAry { opcode: expr0_0 };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1914.
    let expr0_0 = Opcode::ExtractVector;
    let expr1_0 = InstructionData::BinaryImm8 {
        opcode: expr0_0,
        arg: pattern1_0,
        imm: pattern2_0,
    };
    let expr2_0 = C::make_inst_ctor(ctx, pattern0_0, &expr1_0);
    return expr2_0;
}
